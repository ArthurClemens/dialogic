{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:////Users/arthur/code/Github Projects/dialogic/master/node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack:////Users/arthur/code/Github Projects/dialogic/master/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","webpack:////Users/arthur/code/Github Projects/dialogic/master/node_modules/@babel/runtime/helpers/asyncToGenerator.js","webpack:////Users/arthur/code/Github Projects/dialogic/master/node_modules/@babel/runtime/helpers/defineProperty.js","webpack:////Users/arthur/code/Github Projects/dialogic/master/node_modules/@babel/runtime/helpers/iterableToArray.js","webpack:////Users/arthur/code/Github Projects/dialogic/master/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack:////Users/arthur/code/Github Projects/dialogic/master/node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack:////Users/arthur/code/Github Projects/dialogic/master/node_modules/@babel/runtime/helpers/nonIterableSpread.js","webpack:////Users/arthur/code/Github Projects/dialogic/master/node_modules/@babel/runtime/helpers/slicedToArray.js","webpack:////Users/arthur/code/Github Projects/dialogic/master/node_modules/@babel/runtime/helpers/toConsumableArray.js","webpack:////Users/arthur/code/Github Projects/dialogic/master/node_modules/@babel/runtime/regenerator/index.js","webpack:////Users/arthur/code/Github Projects/dialogic/master/node_modules/process/browser.js","webpack:////Users/arthur/code/Github Projects/dialogic/master/node_modules/regenerator-runtime/runtime.js","webpack:////Users/arthur/code/Github Projects/dialogic/master/node_modules/setimmediate/setImmediate.js","webpack:////Users/arthur/code/Github Projects/dialogic/master/node_modules/timers-browserify/main.js","webpack:///(webpack)/buildin/global.js","webpack:////Users/arthur/code/Github Projects/dialogic/master/packages/dialogic-mithril/dist/dialogic-mithril.mjs","webpack:///../node_modules/mithril/mithril.js","webpack:///./default/Content.ts","webpack:///./index.ts","webpack:///./styles.css"],"names":["MODE","SHOW","HIDE","transitionOptionKeys","className","component","didHide","didShow","hideDelay","hideDuration","hideTimingFunction","showClassName","showDelay","showDuration","showTimingFunction","timeout","transitionClassName","transitions","transition","props","mode","domElement","domElements","Error","Promise","resolve","style","computedStyle","window","getComputedStyle","isShow","transitionProps","getTransitionProps","duration","undefined","styleDurationToMs","transitionDuration","delay","transitionDelay","totalDuration","before","after","applyTransition","timingFunction","transitionTimingFunction","classList","add","showClassElement","setTimeout","remove","durationStr","parsed","parseFloat","indexOf","isNaN","show","hide","createCommonjsModule","fn","module","exports","stream","Stream","SKIP","lift","scan","merge","combine","scanMerge","warnedHalt","Object","defineProperty","get","console","log","value","dependentStreams","dependentFns","v","arguments","length","open","_changing","_state","forEach","s","i","constructor","_parents","_map","ignoreInitial","target","push","map","end","createEnd","p","_unregisterChild","toJSON","x","s1","s2","child","childIndex","splice","streams","ready","every","apply","concat","changed","mappers","endStream","mapper","acc","origin","next","tuples","seed","tuple","Array","prototype","slice","call","findItem","id","items","find","item","itemIndex","removeItem","index","createId","spawnOptions","ns","spawn","filter","Boolean","join","store","initialState","actions","update","state","timer","states","refresh","remaining","replace","newItem","removeAll","newItems","selectors","fns","getStore","just","nothing","getAll","instanceSpawnOptions","getCount","patch","timerId","isPaused","startTime","callback","timeoutFn","promise","onDone","onAbort","appendStartTimer","updateState","reject","Date","getTime","appendStopTimeout","clearTimeout","appendStopTimer","appendPauseTimer","getRemaining","appendResumeTimer","minimumDuration","Math","max","Timer","start","done","stop","pause","resume","abort","getResultPromise","uid","getUid","Number","MAX_SAFE_INTEGER","transitionStates","none","hiding","filterBySpawnId","nsItems","filterQueued","queuedCount","queueCount","queued","getOptionsByKind","options","initial","transitionOptions","instanceOptions","keys","reduce","key","isTransitionKey","createInstance","defaultSpawnOptions","defaultTransitionOptions","instanceTransitionOptions","toString","transitionState","maybeExistingItem","existingItem","replacingItem","getMaybeItem","performOnItem","fnOptions","maybeItem","hideItem","getTimerProperty","timerProp","getRemaining$1","resetAll","getOverridingTransitionOptions","hideAll","allItems","regularItems","queuedItems","current","then","transitionItem","e","deferredHideItem","showItem","dialogicable","defaultId","defaultSpawn","dialog","notification","handleDispatch","event","detail","maybeTransitioningItem","onInstanceMounted","onShowInstance","onHideInstance","Instance","attrs","classNames","dispatchTransition","dispatchFn","onMount","onShow","onHide","oncreate","vnode","dom","view","m","onclick","Wrapper","nsOnInstanceMounted","nsOnShowInstance","nsOnHideInstance","filtered","Dialog","Notification","redraw"],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA;;AAEA,iC;;;;;;;;;;;ACJA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;;AAEA;AACA;AACA;;AAEA,oC;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,mC;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;;AAEA,iC;;;;;;;;;;;ACfA;AACA;AACA;;AAEA,kC;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,+BAA+B;AAC5E;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA,uC;;;;;;;;;;;AC1BA;AACA;AACA;;AAEA,kC;;;;;;;;;;;ACJA;AACA;AACA;;AAEA,oC;;;;;;;;;;;ACJA,qBAAqB,mBAAO,CAAC,wFAAkB;;AAE/C,2BAA2B,mBAAO,CAAC,oGAAwB;;AAE3D,sBAAsB,mBAAO,CAAC,0FAAmB;;AAEjD;AACA;AACA;;AAEA,gC;;;;;;;;;;;ACVA,wBAAwB,mBAAO,CAAC,8FAAqB;;AAErD,sBAAsB,mBAAO,CAAC,0FAAmB;;AAEjD,wBAAwB,mBAAO,CAAC,8FAAqB;;AAErD;AACA;AACA;;AAEA,oC;;;;;;;;;;;ACVA,iBAAiB,mBAAO,CAAC,iFAAqB;;;;;;;;;;;;ACA9C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;ACvLtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;;AAEA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,kBAAkB;AACnD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA,EAAE,KAA0B,oBAAoB,SAAE;AAClD;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrtBA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,sBAAsB,EAAE;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;;;;;;;;;;ACzLD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,mBAAO,CAAC,wEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA,mCAAmC;AACnC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,mCAAmC,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6BAA6B,YAAY;AACtD,GAAG;AACH;AACA;AACA;AACA,8DAA8D,2CAA2C;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA,uDAAuD,cAAc;AACrE;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;AACF;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,0DAA0D;AAC1D,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B,YAAY,eAAe;AAC3B;AACA,YAAY,eAAe;AAC3B,YAAY,WAAW;AACvB,YAAY,eAAe;AAC3B;AACA;AACA,YAAY,+BAA+B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,sBAAsB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,gEAAgE;AAChE,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,aAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mBAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,mBAAmB,4BAA4B;AAC/C;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,eAAe;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C,QAAQ;AACR,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,8BAA8B;AACtF;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,YAAY;AACZ,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA,gDAAgD,GAAG;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,+BAA+B;AACnD;AACA;AACA,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,EAAE;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8BAA8B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,qBAAqB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAA6B;AACjC,KAAK,EAAY;AACjB,CAAC,I;;;;;;;;;;;;;AC5yDD;AAAA;AAAA;AAAA;AAAwB;AACjB;AACP,YAAY,QAAQ;AACpB,eAAe,8CAAC;AAChB;AACA,YAAY,8CAAC;AACb,YAAY,8CAAC;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwB;AACsD;AAChB;AACxC;AACtB,sBAAsB,uDAAM;AAC5B,sBAAsB,uDAAM;AAC5B,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAC;AACjB;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAC;AACb;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAC,sBAAsB,aAAa;AACxD;AACA;AACA;AACA;AACA,eAAe,wDAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","file":"js/index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.ts\");\n","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nmodule.exports = _nonIterableRest;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","module.exports = require(\"regenerator-runtime\");\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n","var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import m from 'mithril';\n\nconst MODE = {\r\n    SHOW: \"show\",\r\n    HIDE: \"hide\"\r\n};\r\nconst transitionOptionKeys = {\r\n    className: true,\r\n    component: true,\r\n    didHide: true,\r\n    didShow: true,\r\n    hideDelay: true,\r\n    hideDuration: true,\r\n    hideTimingFunction: true,\r\n    showClassName: true,\r\n    showDelay: true,\r\n    showDuration: true,\r\n    showTimingFunction: true,\r\n    timeout: true,\r\n    transitionClassName: true,\r\n    transitions: true,\r\n};\r\nconst transition = (props, mode) => {\r\n    const domElement = props.domElements\r\n        ? props.domElements.domElement\r\n        : null;\r\n    if (!domElement) {\r\n        throw new Error(\"No DOM element\");\r\n    }\r\n    return new Promise(resolve => {\r\n        const style = domElement.style;\r\n        const computedStyle =  window.getComputedStyle(domElement)\r\n            ;\r\n        const isShow = mode === MODE.SHOW;\r\n        const transitionProps = getTransitionProps(props, isShow);\r\n        const duration = transitionProps.duration !== undefined\r\n            ? transitionProps.duration * 1000\r\n            : computedStyle\r\n                ? styleDurationToMs(computedStyle.transitionDuration)\r\n                : 0;\r\n        const delay = transitionProps.delay !== undefined\r\n            ? transitionProps.delay * 1000\r\n            : computedStyle\r\n                ? styleDurationToMs(computedStyle.transitionDelay)\r\n                : 0;\r\n        const totalDuration = duration + delay;\r\n        const before = () => {\r\n            if (transitionProps.before && typeof transitionProps.before === \"function\") {\r\n                style.transitionDuration = \"0ms\";\r\n                style.transitionDelay = \"0ms\";\r\n                transitionProps.before();\r\n            }\r\n        };\r\n        const after = () => {\r\n            if (transitionProps.after && typeof transitionProps.after === \"function\") {\r\n                transitionProps.after();\r\n            }\r\n        };\r\n        const applyTransition = () => {\r\n            // Set styles\r\n            const timingFunction = transitionProps.timingFunction\r\n                // or when set in CSS:\r\n                || (computedStyle\r\n                    ? computedStyle.transitionTimingFunction\r\n                    : undefined);\r\n            if (timingFunction) {\r\n                style.transitionTimingFunction = timingFunction;\r\n            }\r\n            style.transitionDuration = duration + \"ms\";\r\n            style.transitionDelay = delay + \"ms\";\r\n            // Set classes (need to be set after styles)\r\n            if (props.transitionClassName) {\r\n                domElement.classList.add(props.transitionClassName);\r\n            }\r\n            if (props.showClassName) {\r\n                const showClassElement = props.showClassElement || domElement;\r\n                showClassElement.classList[isShow ? \"add\" : \"remove\"](props.showClassName);\r\n            }\r\n            // Call transition function\r\n            if (transitionProps.transition) {\r\n                transitionProps.transition();\r\n            }\r\n        };\r\n        before();\r\n        applyTransition();\r\n        setTimeout(() => {\r\n            after();\r\n            if (props.transitionClassName) {\r\n                domElement.classList.remove(props.transitionClassName);\r\n            }\r\n            resolve();\r\n        }, totalDuration);\r\n    });\r\n};\r\nconst styleDurationToMs = (durationStr) => {\r\n    const parsed = parseFloat(durationStr) * (durationStr.indexOf(\"ms\") === -1 ? 1000 : 1);\r\n    return isNaN(parsed)\r\n        ? 0\r\n        : parsed;\r\n};\r\nconst getTransitionProps = (props, isShow) => {\r\n    const [duration, delay, timingFunction, transition] = isShow\r\n        ? [props.showDuration, props.showDelay, props.showTimingFunction, props.transitions ? props.transitions.show : undefined]\r\n        : [props.hideDuration, props.hideDelay, props.hideTimingFunction, props.transitions ? props.transitions.hide : undefined];\r\n    return {\r\n        duration,\r\n        delay,\r\n        timingFunction,\r\n        ...(transition\r\n            ? transition(props.domElements)\r\n            : undefined)\r\n    };\r\n};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar stream = createCommonjsModule(function (module) {\n(function() {\n/* eslint-enable */\nStream.SKIP = {};\nStream.lift = lift;\nStream.scan = scan;\nStream.merge = merge;\nStream.combine = combine;\nStream.scanMerge = scanMerge;\nStream[\"fantasy-land/of\"] = Stream;\n\nvar warnedHalt = false;\nObject.defineProperty(Stream, \"HALT\", {\n\tget: function() {\n\t\twarnedHalt || console.log(\"HALT is deprecated and has been renamed to SKIP\");\n\t\twarnedHalt = true;\n\t\treturn Stream.SKIP\n\t}\n});\n\nfunction Stream(value) {\n\tvar dependentStreams = [];\n\tvar dependentFns = [];\n\n\tfunction stream(v) {\n\t\tif (arguments.length && v !== Stream.SKIP) {\n\t\t\tvalue = v;\n\t\t\tif (open(stream)) {\n\t\t\t\tstream._changing();\n\t\t\t\tstream._state = \"active\";\n\t\t\t\tdependentStreams.forEach(function(s, i) { s(dependentFns[i](value)); });\n\t\t\t}\n\t\t}\n\n\t\treturn value\n\t}\n\n\tstream.constructor = Stream;\n\tstream._state = arguments.length && value !== Stream.SKIP ? \"active\" : \"pending\";\n\tstream._parents = [];\n\n\tstream._changing = function() {\n\t\tif (open(stream)) stream._state = \"changing\";\n\t\tdependentStreams.forEach(function(s) {\n\t\t\ts._changing();\n\t\t});\n\t};\n\n\tstream._map = function(fn, ignoreInitial) {\n\t\tvar target = ignoreInitial ? Stream() : Stream(fn(value));\n\t\ttarget._parents.push(stream);\n\t\tdependentStreams.push(target);\n\t\tdependentFns.push(fn);\n\t\treturn target\n\t};\n\n\tstream.map = function(fn) {\n\t\treturn stream._map(fn, stream._state !== \"active\")\n\t};\n\n\tvar end;\n\tfunction createEnd() {\n\t\tend = Stream();\n\t\tend.map(function(value) {\n\t\t\tif (value === true) {\n\t\t\t\tstream._parents.forEach(function (p) {p._unregisterChild(stream);});\n\t\t\t\tstream._state = \"ended\";\n\t\t\t\tstream._parents.length = dependentStreams.length = dependentFns.length = 0;\n\t\t\t}\n\t\t\treturn value\n\t\t});\n\t\treturn end\n\t}\n\n\tstream.toJSON = function() { return value != null && typeof value.toJSON === \"function\" ? value.toJSON() : value };\n\n\tstream[\"fantasy-land/map\"] = stream.map;\n\tstream[\"fantasy-land/ap\"] = function(x) { return combine(function(s1, s2) { return s1()(s2()) }, [x, stream]) };\n\n\tstream._unregisterChild = function(child) {\n\t\tvar childIndex = dependentStreams.indexOf(child);\n\t\tif (childIndex !== -1) {\n\t\t\tdependentStreams.splice(childIndex, 1);\n\t\t\tdependentFns.splice(childIndex, 1);\n\t\t}\n\t};\n\n\tObject.defineProperty(stream, \"end\", {\n\t\tget: function() { return end || createEnd() }\n\t});\n\n\treturn stream\n}\n\nfunction combine(fn, streams) {\n\tvar ready = streams.every(function(s) {\n\t\tif (s.constructor !== Stream)\n\t\t\tthrow new Error(\"Ensure that each item passed to stream.combine/stream.merge/lift is a stream\")\n\t\treturn s._state === \"active\"\n\t});\n\tvar stream = ready\n\t\t? Stream(fn.apply(null, streams.concat([streams])))\n\t\t: Stream();\n\n\tvar changed = [];\n\n\tvar mappers = streams.map(function(s) {\n\t\treturn s._map(function(value) {\n\t\t\tchanged.push(s);\n\t\t\tif (ready || streams.every(function(s) { return s._state !== \"pending\" })) {\n\t\t\t\tready = true;\n\t\t\t\tstream(fn.apply(null, streams.concat([changed])));\n\t\t\t\tchanged = [];\n\t\t\t}\n\t\t\treturn value\n\t\t}, true)\n\t});\n\n\tvar endStream = stream.end.map(function(value) {\n\t\tif (value === true) {\n\t\t\tmappers.forEach(function(mapper) { mapper.end(true); });\n\t\t\tendStream.end(true);\n\t\t}\n\t\treturn undefined\n\t});\n\n\treturn stream\n}\n\nfunction merge(streams) {\n\treturn combine(function() { return streams.map(function(s) { return s() }) }, streams)\n}\n\nfunction scan(fn, acc, origin) {\n\tvar stream = origin.map(function(v) {\n\t\tvar next = fn(acc, v);\n\t\tif (next !== Stream.SKIP) acc = next;\n\t\treturn next\n\t});\n\tstream(acc);\n\treturn stream\n}\n\nfunction scanMerge(tuples, seed) {\n\tvar streams = tuples.map(function(tuple) { return tuple[0] });\n\n\tvar stream = combine(function() {\n\t\tvar changed = arguments[arguments.length - 1];\n\t\tstreams.forEach(function(stream, i) {\n\t\t\tif (changed.indexOf(stream) > -1)\n\t\t\t\tseed = tuples[i][1](seed, stream());\n\t\t});\n\n\t\treturn seed\n\t}, streams);\n\n\tstream(seed);\n\n\treturn stream\n}\n\nfunction lift() {\n\tvar fn = arguments[0];\n\tvar streams = Array.prototype.slice.call(arguments, 1);\n\treturn merge(streams).map(function(streams) {\n\t\treturn fn.apply(undefined, streams)\n\t})\n}\n\nfunction open(s) {\n\treturn s._state === \"pending\" || s._state === \"active\" || s._state === \"changing\"\n}\n\nmodule[\"exports\"] = Stream;\n\n}());\n});\n\nconst findItem = (id, items) => {\r\n    return items.find(item => item.id === id);\r\n};\r\nconst itemIndex = (id, items) => {\r\n    const item = findItem(id, items);\r\n    return items.indexOf(item);\r\n};\r\nconst removeItem = (id, items) => {\r\n    const index = itemIndex(id, items);\r\n    if (index !== -1) {\r\n        items.splice(index, 1);\r\n    }\r\n    return items;\r\n};\r\nconst createId = (spawnOptions, ns) => [ns, spawnOptions.id, spawnOptions.spawn].filter(Boolean).join(\"-\");\r\nconst store = {\r\n    initialState: {\r\n        store: {},\r\n    },\r\n    actions: (update) => {\r\n        return {\r\n            /**\r\n             * Add an item to the end of the list.\r\n             */\r\n            add: (ns, item) => {\r\n                update((state) => {\r\n                    const items = state.store[ns] || [];\r\n                    state.store[ns] = [...items, item];\r\n                    if (item.timer) {\r\n                        // When the timer state updates, refresh the store so that UI can pick up the change\r\n                        item.timer.states.map(() => store.actions(update).refresh());\r\n                    }\r\n                    return state;\r\n                });\r\n            },\r\n            /**\r\n             * Removes the first item with a match on `id`.\r\n             */\r\n            remove: (ns, id) => {\r\n                update((state) => {\r\n                    const items = state.store[ns] || [];\r\n                    const remaining = removeItem(id, items);\r\n                    state.store[ns] = remaining;\r\n                    return state;\r\n                });\r\n            },\r\n            /**\r\n             * Replaces the first item with a match on `id` with a newItem.\r\n             */\r\n            replace: (ns, id, newItem) => {\r\n                update((state) => {\r\n                    const items = state.store[ns] || [];\r\n                    if (items) {\r\n                        const index = itemIndex(id, items);\r\n                        if (index !== -1) {\r\n                            items[index] = newItem;\r\n                            state.store[ns] = [...items];\r\n                        }\r\n                    }\r\n                    return state;\r\n                });\r\n            },\r\n            /**\r\n             * Removes all items within a namespace.\r\n             */\r\n            removeAll: (ns) => {\r\n                update((state) => {\r\n                    state.store[ns] = [];\r\n                    return state;\r\n                });\r\n            },\r\n            /**\r\n             * Replaces all items within a namespace.\r\n             */\r\n            store: (ns, newItems) => {\r\n                update((state) => {\r\n                    state.store[ns] = [...newItems];\r\n                    return state;\r\n                });\r\n            },\r\n            refresh: () => {\r\n                update((state) => {\r\n                    return {\r\n                        ...state,\r\n                    };\r\n                });\r\n            },\r\n        };\r\n    },\r\n    selectors: (states) => {\r\n        const fns = {\r\n            getStore: () => {\r\n                const state = states();\r\n                return state.store;\r\n            },\r\n            find: (ns, spawnOptions) => {\r\n                const state = states();\r\n                const items = state.store[ns] || [];\r\n                const id = createId(spawnOptions, ns);\r\n                const item = items.find((item) => item.id === id);\r\n                return item\r\n                    ? { just: item }\r\n                    : { nothing: undefined };\r\n            },\r\n            getAll: (ns, instanceSpawnOptions) => {\r\n                const state = states();\r\n                const items = state.store[ns] || [];\r\n                const spawn = instanceSpawnOptions !== undefined\r\n                    ? instanceSpawnOptions.spawn\r\n                    : undefined;\r\n                return spawn !== undefined\r\n                    ? items.filter(item => item.spawnOptions.spawn === spawn)\r\n                    : items;\r\n            },\r\n            getCount: (ns, instanceSpawnOptions) => fns.getAll(ns, instanceSpawnOptions).length,\r\n        };\r\n        return fns;\r\n    },\r\n};\r\nconst update = stream();\r\nconst states = stream.scan((state, patch) => patch(state), {\r\n    ...store.initialState,\r\n}, update);\r\nconst actions = {\r\n    ...store.actions(update),\r\n};\r\nconst selectors = {\r\n    ...store.selectors(states),\r\n};\r\n// states.map(state => \r\n//   console.log(JSON.stringify(state, null, 2))\r\n// );\n\nconst initialState = {\r\n    timerId: undefined,\r\n    isPaused: undefined,\r\n    remaining: undefined,\r\n    startTime: undefined,\r\n    callback: () => { },\r\n    timeoutFn: () => { },\r\n    promise: undefined,\r\n    onDone: () => { },\r\n    onAbort: () => { },\r\n};\r\nconst appendStartTimer = (state, callback, duration, updateState) => {\r\n    const timeoutFn = () => {\r\n        callback();\r\n        state.onDone();\r\n        updateState();\r\n    };\r\n    return {\r\n        timeoutFn,\r\n        promise: new Promise((resolve, reject) => {\r\n            state.onDone = () => resolve();\r\n            state.onAbort = () => reject();\r\n        }),\r\n        ...(state.isPaused\r\n            ? {}\r\n            : {\r\n                startTime: new Date().getTime(),\r\n                timerId: window.setTimeout(timeoutFn, duration),\r\n                remaining: duration,\r\n            })\r\n    };\r\n};\r\nconst appendStopTimeout = (state) => {\r\n    window.clearTimeout(state.timerId);\r\n    return {\r\n        timerId: initialState.timerId\r\n    };\r\n};\r\nconst appendStopTimer = (state) => {\r\n    return {\r\n        ...appendStopTimeout(state),\r\n    };\r\n};\r\nconst appendPauseTimer = (state) => {\r\n    return {\r\n        ...appendStopTimeout(state),\r\n        isPaused: true,\r\n        remaining: getRemaining(state)\r\n    };\r\n};\r\nconst appendResumeTimer = (state, minimumDuration) => {\r\n    window.clearTimeout(state.timerId);\r\n    const remaining = minimumDuration\r\n        ? Math.max(state.remaining || 0, minimumDuration)\r\n        : state.remaining;\r\n    return {\r\n        startTime: new Date().getTime(),\r\n        isPaused: false,\r\n        remaining,\r\n        timerId: window.setTimeout(state.timeoutFn, remaining),\r\n    };\r\n};\r\nconst getRemaining = (state) => state.remaining === undefined\r\n    ? undefined\r\n    : state.remaining - (new Date().getTime() - (state.startTime || 0));\r\nconst Timer = () => {\r\n    const timer = {\r\n        initialState,\r\n        actions: (update) => {\r\n            return {\r\n                start: (callback, duration) => {\r\n                    update((state) => {\r\n                        return {\r\n                            ...state,\r\n                            ...appendStopTimeout(state),\r\n                            ...appendStartTimer(state, callback, duration, () => timer.actions(update).done()),\r\n                            ...(state.isPaused && appendPauseTimer(state)),\r\n                        };\r\n                    });\r\n                },\r\n                stop: () => {\r\n                    update((state) => {\r\n                        return {\r\n                            ...state,\r\n                            ...appendStopTimer(state),\r\n                            ...initialState\r\n                        };\r\n                    });\r\n                },\r\n                pause: () => {\r\n                    update((state) => {\r\n                        return {\r\n                            ...state,\r\n                            ...appendPauseTimer(state),\r\n                        };\r\n                    });\r\n                },\r\n                resume: (minimumDuration) => {\r\n                    update((state) => {\r\n                        return {\r\n                            ...state,\r\n                            ...(state.isPaused && appendResumeTimer(state, minimumDuration))\r\n                        };\r\n                    });\r\n                },\r\n                abort: () => {\r\n                    update((state) => {\r\n                        state.onAbort();\r\n                        return {\r\n                            ...state,\r\n                            ...appendStopTimeout(state),\r\n                        };\r\n                    });\r\n                },\r\n                done: () => {\r\n                    update((state) => {\r\n                        return initialState;\r\n                    });\r\n                },\r\n                refresh: () => {\r\n                    update((state) => {\r\n                        return {\r\n                            ...state,\r\n                        };\r\n                    });\r\n                },\r\n            };\r\n        },\r\n        selectors: (states) => {\r\n            return {\r\n                isPaused: () => {\r\n                    const state = states();\r\n                    return state.isPaused;\r\n                },\r\n                getRemaining: () => {\r\n                    const state = states();\r\n                    return state.isPaused\r\n                        ? state.remaining\r\n                        : getRemaining(state);\r\n                },\r\n                getResultPromise: () => {\r\n                    const state = states();\r\n                    return state.promise;\r\n                },\r\n            };\r\n        },\r\n    };\r\n    const update = stream();\r\n    const states = stream.scan((state, patch) => patch(state), {\r\n        ...timer.initialState,\r\n    }, update);\r\n    const actions = {\r\n        ...timer.actions(update),\r\n    };\r\n    const selectors = {\r\n        ...timer.selectors(states),\r\n    };\r\n    // states.map(state => \r\n    //   console.log(JSON.stringify(state, null, 2))\r\n    // );\r\n    return {\r\n        states,\r\n        actions,\r\n        selectors,\r\n    };\r\n};\n\nlet uid = 0;\r\nconst getUid = () => uid === Number.MAX_SAFE_INTEGER\r\n    ? 0\r\n    : uid++;\r\nconst transitionStates = {\r\n    none: \"none\",\r\n    hiding: \"hiding\"\r\n};\r\nconst filterBySpawnId = (nsItems, spawn) => nsItems.filter(item => item.spawnOptions.spawn === spawn);\r\n/**\r\n * Gets a list of all non-queued items.\r\n * From the queued items only the first item is listed.\r\n * */\r\nconst filterQueued = (nsItems, ns) => {\r\n    let queuedCount = 0;\r\n    return nsItems\r\n        .map(item => ({\r\n        item,\r\n        queueCount: item.spawnOptions.queued\r\n            ? queuedCount++\r\n            : 0\r\n    }))\r\n        .filter(({ queueCount }) => queueCount === 0)\r\n        .map(({ item }) => item);\r\n};\r\nconst filter = (ns, items, spawn) => {\r\n    const nsItems = items[ns] || [];\r\n    return filterBySpawnId(filterQueued(nsItems), spawn);\r\n};\r\nconst getOptionsByKind = options => {\r\n    const initial = {\r\n        transitionOptions: {},\r\n        instanceOptions: {}\r\n    };\r\n    return Object.keys(options).reduce((acc, key) => {\r\n        const value = options[key];\r\n        const isTransitionKey = transitionOptionKeys[key];\r\n        if (isTransitionKey) {\r\n            acc.transitionOptions[key] = value;\r\n        }\r\n        else {\r\n            acc.instanceOptions[key] = value;\r\n        }\r\n        return acc;\r\n    }, initial);\r\n};\r\nconst createInstance = (ns) => (defaultSpawnOptions) => (defaultTransitionOptions) => (options, instanceSpawnOptions) => {\r\n    return new Promise((resolve) => {\r\n        const spawnOptions = {\r\n            ...defaultSpawnOptions,\r\n            ...instanceSpawnOptions,\r\n        };\r\n        const id = createId(spawnOptions, ns);\r\n        const { transitionOptions: instanceTransitionOptions, instanceOptions } = getOptionsByKind(options);\r\n        const transitionOptions = {\r\n            ...defaultTransitionOptions,\r\n            ...instanceTransitionOptions,\r\n        };\r\n        transitionOptions.didShow = (id) => {\r\n            if (options.didShow) {\r\n                options.didShow(id);\r\n            }\r\n            return resolve(id);\r\n        };\r\n        transitionOptions.didHide = (id) => {\r\n            if (options.didHide) {\r\n                options.didHide(id);\r\n            }\r\n            return resolve(id);\r\n        };\r\n        const uid = getUid().toString();\r\n        const item = {\r\n            spawnOptions,\r\n            transitionOptions,\r\n            instanceTransitionOptions,\r\n            instanceOptions,\r\n            id,\r\n            timer: transitionOptions.timeout\r\n                ? Timer()\r\n                : undefined,\r\n            key: uid,\r\n            transitionState: transitionStates.none,\r\n        };\r\n        const maybeExistingItem = selectors.find(ns, spawnOptions);\r\n        if (maybeExistingItem.just && !spawnOptions.queued) {\r\n            const existingItem = maybeExistingItem.just;\r\n            // Preserve instanceTransitionOptions\r\n            const instanceTransitionOptions = existingItem.instanceTransitionOptions;\r\n            const replacingItem = {\r\n                ...item,\r\n                instanceTransitionOptions\r\n            };\r\n            actions.replace(ns, existingItem.id, replacingItem);\r\n            // While this is a replace action, mimic a show\r\n            transitionOptions.didShow(spawnOptions.id);\r\n        }\r\n        else {\r\n            actions.add(ns, item);\r\n            // This will instantiate and draw the instance\r\n            // The instance will call `showDialog` in `onMount`\r\n        }\r\n    });\r\n};\r\nconst show = createInstance;\r\nconst getMaybeItem = (ns) => (defaultSpawnOptions) => (instanceSpawnOptions) => {\r\n    const spawnOptions = {\r\n        ...defaultSpawnOptions,\r\n        ...instanceSpawnOptions,\r\n    };\r\n    return selectors.find(ns, spawnOptions);\r\n};\r\nconst performOnItem = fn => ns => defaultSpawnOptions => (instanceSpawnOptions, fnOptions) => {\r\n    const maybeItem = getMaybeItem(ns)(defaultSpawnOptions)(instanceSpawnOptions);\r\n    if (maybeItem.just) {\r\n        return fn(ns, maybeItem.just, fnOptions);\r\n    }\r\n    else {\r\n        return Promise.resolve();\r\n    }\r\n};\r\nconst hide = performOnItem((ns, item) => {\r\n    if (item.transitionState !== transitionStates.hiding) {\r\n        item.transitionState = transitionStates.hiding;\r\n        return hideItem(ns, item);\r\n    }\r\n    else {\r\n        return Promise.resolve();\r\n    }\r\n});\r\nconst pause = performOnItem((ns, item) => {\r\n    if (item && item.timer) {\r\n        item.timer.actions.pause();\r\n    }\r\n    return Promise.resolve();\r\n});\r\nconst resume = performOnItem((ns, item, fnOptions = {}) => {\r\n    if (item && item.timer) {\r\n        item.timer.actions.resume(fnOptions.minimumDuration);\r\n    }\r\n    return Promise.resolve();\r\n});\r\nconst getTimerProperty = (timerProp) => (ns) => (defaultSpawnOptions) => (instanceSpawnOptions) => {\r\n    const maybeItem = getMaybeItem(ns)(defaultSpawnOptions)(instanceSpawnOptions);\r\n    if (maybeItem.just) {\r\n        if (maybeItem.just && maybeItem.just.timer) {\r\n            return maybeItem.just.timer.selectors[timerProp]();\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n};\r\nconst isPaused = getTimerProperty(\"isPaused\");\r\nconst getRemaining$1 = getTimerProperty(\"getRemaining\");\r\nconst resetAll = (ns) => () => {\r\n    selectors.getAll(ns).forEach((item) => item.timer && item.timer.actions.abort());\r\n    actions.removeAll(ns);\r\n    return Promise.resolve();\r\n};\r\nconst getOverridingTransitionOptions = (item, options) => {\r\n    const { transitionOptions } = getOptionsByKind(options);\r\n    return {\r\n        ...item,\r\n        transitionOptions: {\r\n            ...item.transitionOptions,\r\n            ...transitionOptions\r\n        }\r\n    };\r\n};\r\n/**\r\n * Triggers a `hideItem` for each item in the store.\r\n * Queued items: will trigger `hideItem` only for the first item, then reset the store.\r\n * `options` may contain specific transition options. This comes in handy when all items should hide in the same manner.\r\n * */\r\nconst hideAll = (ns) => (defaultSpawnOptions) => (options, instanceSpawnOptions) => {\r\n    const spawnOptions = {\r\n        ...defaultSpawnOptions,\r\n        ...instanceSpawnOptions,\r\n    };\r\n    const allItems = selectors.getAll(ns);\r\n    const regularItems = allItems.filter((item) => !spawnOptions.queued && !item.spawnOptions.queued);\r\n    const queuedItems = allItems.filter((item) => spawnOptions.queued || item.spawnOptions.queued);\r\n    regularItems.forEach((item) => hideItem(ns, getOverridingTransitionOptions(item, options)));\r\n    if (queuedItems.length > 0) {\r\n        const [current,] = queuedItems;\r\n        // Make sure that any remaining items don't suddenly appear\r\n        actions.store(ns, [current]);\r\n        // Transition the current item\r\n        hideItem(ns, getOverridingTransitionOptions(current, options))\r\n            .then(() => actions.removeAll(ns));\r\n    }\r\n};\r\nconst getCount = (ns) => (instanceSpawnOptions) => selectors.getCount(ns, instanceSpawnOptions);\r\nconst transitionItem = (item, mode) => {\r\n    try {\r\n        return transition({\r\n            ...item.instanceTransitionOptions,\r\n            ...item.transitionOptions,\r\n        }, mode);\r\n    }\r\n    catch (e) {\r\n        throw new Error(`Transition error: ${e}`);\r\n    }\r\n};\r\nconst deferredHideItem = async function (ns, item, timer, timeout) {\r\n    timer.actions.start(() => (hideItem(ns, item)), timeout);\r\n    return getTimerProperty(\"getResultPromise\"); // timer.selectors.getResultPromise();\r\n};\r\nconst showItem = async function (ns, item) {\r\n    await (transitionItem(item, MODE.SHOW));\r\n    item.transitionOptions.didShow && await (item.transitionOptions.didShow(item.spawnOptions.id));\r\n    if (item.transitionOptions.timeout && item.timer) {\r\n        await (deferredHideItem(ns, item, item.timer, item.transitionOptions.timeout));\r\n    }\r\n    return item.spawnOptions.id;\r\n};\r\nconst hideItem = async function (ns, item) {\r\n    // Stop any running timer\r\n    if (item.timer) {\r\n        item.timer.actions.stop();\r\n    }\r\n    await (transitionItem(item, MODE.HIDE));\r\n    item.transitionOptions.didHide && await (item.transitionOptions.didHide(item.spawnOptions.id));\r\n    actions.remove(ns, item.id);\r\n    return item.spawnOptions.id;\r\n};\n\nconst dialogicable = ({ ns, queued, timeout }) => {\r\n    const defaultId = `default_${ns}`;\r\n    const defaultSpawn = `default_${ns}`;\r\n    const defaultSpawnOptions = {\r\n        id: defaultId,\r\n        spawn: defaultSpawn,\r\n        queued\r\n    };\r\n    const defaultTransitionOptions = {\r\n        timeout\r\n    };\r\n    return {\r\n        defaultId,\r\n        defaultSpawn,\r\n        defaultSpawnOptions,\r\n        show: show(ns)(defaultSpawnOptions)(defaultTransitionOptions),\r\n        hide: hide(ns)(defaultSpawnOptions),\r\n        pause: pause(ns)(defaultSpawnOptions),\r\n        resume: resume(ns)(defaultSpawnOptions),\r\n        isPaused: isPaused(ns)(defaultSpawnOptions),\r\n        getMaybeItem: getMaybeItem(ns)(defaultSpawnOptions),\r\n        getRemaining: getRemaining$1(ns)(defaultSpawnOptions),\r\n        hideAll: hideAll(ns)(defaultSpawnOptions),\r\n        resetAll: resetAll(ns),\r\n        getCount: getCount(ns),\r\n    };\r\n};\n\nconst dialog = dialogicable({ ns: \"dialog\" });\r\n// import { show as _show, hide as _hide, hideAll as _hideAll, resetAll as _resetAll, getCount as _getCount, pause as _pause, resume as _resume, isPaused as _isPaused, getRemaining as _getRemaining, getMaybeItem as _getMaybeItem } from \"./dialogic\";\r\n// import { Dialogic } from \"../index\";\r\n// export const ns = \"dialog\";\r\n// export const defaultId = `default_${ns}`;\r\n// export const defaultSpawn = `default_${ns}`;\r\n// export const defaultSpawnOptions: Dialogic.DefaultSpawnOptions = {\r\n//   id: defaultId,\r\n//   spawn: defaultSpawn,\r\n// };\r\n// const defaultTransitionOptions: Dialogic.DefaultTransitionOptions = {};\r\n// export const show = _show(ns)(defaultSpawnOptions)(defaultTransitionOptions);\r\n// export const hide = _hide(ns)(defaultSpawnOptions);\r\n// export const pause = _pause(ns)(defaultSpawnOptions);\r\n// export const resume = _resume(ns)(defaultSpawnOptions);\r\n// export const isPaused = _isPaused(ns)(defaultSpawnOptions);\r\n// export const getMaybeItem = _getMaybeItem(ns)(defaultSpawnOptions);\r\n// export const getRemaining = _getRemaining(ns)(defaultSpawnOptions);\r\n// export const hideAll = _hideAll(ns)(defaultSpawnOptions);\r\n// export const resetAll = _resetAll(ns);\r\n// export const getCount = _getCount(ns);\n\nconst notification = dialogicable({ ns: \"notification\", queued: true, timeout: 3000 });\n\nconst handleDispatch = (ns) => (event, fn) => {\r\n    // Update dispatching item:\r\n    const maybeItem = selectors.find(ns, event.detail.spawnOptions);\r\n    if (maybeItem.just) {\r\n        maybeItem.just.instanceTransitionOptions = event.detail.transitionOptions;\r\n    }\r\n    // Find item to transition:\r\n    const maybeTransitioningItem = selectors.find(ns, event.detail.spawnOptions);\r\n    if (maybeTransitioningItem.just) {\r\n        fn(ns, maybeTransitioningItem.just);\r\n    }\r\n};\r\nconst onInstanceMounted = (ns) => (event) => handleDispatch(ns)(event, showItem);\r\nconst onShowInstance = (ns) => (event) => handleDispatch(ns)(event, showItem);\r\nconst onHideInstance = (ns) => (event) => handleDispatch(ns)(event, hideItem);\n\nconst Instance = ({ attrs }) => {\r\n    let domElement;\r\n    const classNames = [\r\n        attrs.transitionOptions.className,\r\n        attrs.instanceOptions.className\r\n    ].join(\" \");\r\n    const dispatchTransition = (dispatchFn) => {\r\n        dispatchFn({\r\n            detail: {\r\n                spawnOptions: attrs.spawnOptions,\r\n                transitionOptions: {\r\n                    className: attrs.transitionOptions.className,\r\n                    showClassName: attrs.transitionOptions.showClassName,\r\n                    domElements: {\r\n                        domElement\r\n                    },\r\n                },\r\n            }\r\n        });\r\n    };\r\n    const onMount = () => {\r\n        dispatchTransition(attrs.onMount);\r\n    };\r\n    const show = () => {\r\n        dispatchTransition(attrs.onShow);\r\n    };\r\n    const hide = () => {\r\n        dispatchTransition(attrs.onHide);\r\n    };\r\n    return {\r\n        oncreate: (vnode) => {\r\n            domElement = vnode.dom;\r\n            onMount();\r\n        },\r\n        view: () => {\r\n            return m(\"div\", {\r\n                className: classNames,\r\n            }, m(attrs.transitionOptions.component, {\r\n                ...attrs.instanceOptions,\r\n                show,\r\n                hide,\r\n            }, [\r\n                m(\"div\", \"Instance\"),\r\n                m(\"button\", { onclick: () => hide() }, \"Hide from instance\"),\r\n            ]));\r\n        }\r\n    };\r\n};\n\nconst Wrapper = {\r\n    view: ({ attrs }) => {\r\n        const nsOnInstanceMounted = onInstanceMounted(attrs.ns);\r\n        const nsOnShowInstance = onShowInstance(attrs.ns);\r\n        const nsOnHideInstance = onHideInstance(attrs.ns);\r\n        const spawnOptions = attrs.spawnOptions || {};\r\n        const spawn = spawnOptions.spawn || \"\";\r\n        const filtered = filter(attrs.ns, selectors.getStore(), spawn);\r\n        console.log(\"Wrapper\", \"spawnOptions\", spawnOptions, \"filtered\", filtered);\r\n        return filtered.map(item => m(Instance, {\r\n            key: item.key,\r\n            spawnOptions: item.spawnOptions,\r\n            transitionOptions: item.transitionOptions,\r\n            instanceOptions: item.instanceOptions,\r\n            onMount: nsOnInstanceMounted,\r\n            onShow: nsOnShowInstance,\r\n            onHide: nsOnHideInstance,\r\n        }));\r\n    }\r\n};\n\nconst Dialog = {\r\n    view: ({ attrs }) => {\r\n        const spawnOptions = {\r\n            id: attrs.id || dialog.defaultId,\r\n            spawn: attrs.spawn || dialog.defaultSpawn,\r\n        };\r\n        console.log(\"Dialog\", \"spawnOptions\", spawnOptions, \"dialog.ns\", dialog.ns);\r\n        return m(Wrapper, {\r\n            spawnOptions,\r\n            ns: dialog.ns,\r\n        });\r\n    }\r\n};\n\nconst Notification = ({ attrs }) => {\r\n    const spawnOptions = {\r\n        id: attrs.id || notification.defaultId,\r\n        spawn: attrs.spawn || notification.defaultSpawn,\r\n    };\r\n    return {\r\n        view: () => m(Wrapper, {\r\n            spawnOptions,\r\n            ns: notification.ns,\r\n        })\r\n    };\r\n};\n\nstates.map(state => (m.redraw()));\n\nexport { Dialog, Notification, dialog, notification };\n",";(function() {\n\"use strict\"\nfunction Vnode(tag, key, attrs0, children0, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs0, children: children0, text: text, dom: dom, domSize: undefined, state: undefined, events: undefined, instance: undefined}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode(\"[\", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node == null || typeof node === \"boolean\") return null\n\tif (typeof node === \"object\") return node\n\treturn Vnode(\"#\", undefined, undefined, String(node), undefined, undefined)\n}\nVnode.normalizeChildren = function(input) {\n\tvar children0 = []\n\tif (input.length) {\n\t\tvar isKeyed = input[0] != null && input[0].key != null\n\t\t// Note: this is a *very* perf-sensitive check.\n\t\t// Fun fact: merging the loop like this is somehow faster than splitting\n\t\t// it, noticeably so.\n\t\tfor (var i = 1; i < input.length; i++) {\n\t\t\tif ((input[i] != null && input[i].key != null) !== isKeyed) {\n\t\t\t\tthrow new TypeError(\"Vnodes must either always have keys or never have keys!\")\n\t\t\t}\n\t\t}\n\t\tfor (var i = 0; i < input.length; i++) {\n\t\t\tchildren0[i] = Vnode.normalize(input[i])\n\t\t}\n\t}\n\treturn children0\n}\n// Call via `hyperscriptVnode0.apply(startOffset, arguments)`\n//\n// The reason I do it this way, forwarding the arguments and passing the start\n// offset in `this`, is so I don't have to create a temporary array in a\n// performance-critical path.\n//\n// In native ES6, I'd instead add a final `...args` parameter to the\n// `hyperscript0` and `fragment` factories and define this as\n// `hyperscriptVnode0(...args)`, since modern engines do optimize that away. But\n// ES5 (what Mithril requires thanks to IE support) doesn't give me that luxury,\n// and engines aren't nearly intelligent enough to do either of these:\n//\n// 1. Elide the allocation for `[].slice.call(arguments, 1)` when it's passed to\n//    another function only to be indexed.\n// 2. Elide an `arguments` allocation when it's passed to any function other\n//    than `Function.prototype.apply` or `Reflect.apply`.\n//\n// In ES6, it'd probably look closer to this (I'd need to profile it, though):\n// var hyperscriptVnode = function(attrs1, ...children1) {\n//     if (attrs1 == null || typeof attrs1 === \"object\" && attrs1.tag == null && !Array.isArray(attrs1)) {\n//         if (children1.length === 1 && Array.isArray(children1[0])) children1 = children1[0]\n//     } else {\n//         children1 = children1.length === 0 && Array.isArray(attrs1) ? attrs1 : [attrs1, ...children1]\n//         attrs1 = undefined\n//     }\n//\n//     if (attrs1 == null) attrs1 = {}\n//     return Vnode(\"\", attrs1.key, attrs1, children1)\n// }\nvar hyperscriptVnode = function() {\n\tvar attrs1 = arguments[this], start = this + 1, children1\n\tif (attrs1 == null) {\n\t\tattrs1 = {}\n\t} else if (typeof attrs1 !== \"object\" || attrs1.tag != null || Array.isArray(attrs1)) {\n\t\tattrs1 = {}\n\t\tstart = this\n\t}\n\tif (arguments.length === start + 1) {\n\t\tchildren1 = arguments[start]\n\t\tif (!Array.isArray(children1)) children1 = [children1]\n\t} else {\n\t\tchildren1 = []\n\t\twhile (start < arguments.length) children1.push(arguments[start++])\n\t}\n\treturn Vnode(\"\", attrs1.key, attrs1, children1)\n}\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*(\"|'|)((?:\\\\[\"'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = {}\nvar hasOwn = {}.hasOwnProperty\nfunction isEmpty(object) {\n\tfor (var key in object) if (hasOwn.call(object, key)) return false\n\treturn true\n}\nfunction compileSelector(selector) {\n\tvar match, tag = \"div\", classes = [], attrs = {}\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === \"\" && value !== \"\") tag = value\n\t\telse if (type === \"#\") attrs.id = value\n\t\telse if (type === \".\") classes.push(value)\n\t\telse if (match[3][0] === \"[\") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\([\"'])/g, \"$1\").replace(/\\\\\\\\/g, \"\\\\\")\n\t\t\tif (match[4] === \"class\") classes.push(attrValue)\n\t\t\telse attrs[match[4]] = attrValue === \"\" ? attrValue : attrValue || true\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(\" \")\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs}\n}\nfunction execSelector(state, vnode) {\n\tvar attrs = vnode.attrs\n\tvar children = Vnode.normalizeChildren(vnode.children)\n\tvar hasClass = hasOwn.call(attrs, \"class\")\n\tvar className = hasClass ? attrs.class : attrs.className\n\tvnode.tag = state.tag\n\tvnode.attrs = null\n\tvnode.children = undefined\n\tif (!isEmpty(state.attrs) && !isEmpty(attrs)) {\n\t\tvar newAttrs = {}\n\t\tfor (var key in attrs) {\n\t\t\tif (hasOwn.call(attrs, key)) newAttrs[key] = attrs[key]\n\t\t}\n\t\tattrs = newAttrs\n\t}\n\tfor (var key in state.attrs) {\n\t\tif (hasOwn.call(state.attrs, key) && key !== \"className\" && !hasOwn.call(attrs, key)){\n\t\t\tattrs[key] = state.attrs[key]\n\t\t}\n\t}\n\tif (className != null || state.attrs.className != null) attrs.className =\n\t\tclassName != null\n\t\t\t? state.attrs.className != null\n\t\t\t\t? String(state.attrs.className) + \" \" + String(className)\n\t\t\t\t: className\n\t\t\t: state.attrs.className != null\n\t\t\t\t? state.attrs.className\n\t\t\t\t: null\n\tif (hasClass) attrs.class = null\n\tfor (var key in attrs) {\n\t\tif (hasOwn.call(attrs, key) && key !== \"key\") {\n\t\t\tvnode.attrs = attrs\n\t\t\tbreak\n\t\t}\n\t}\n\tif (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === \"#\") {\n\t\tvnode.text = children[0].children\n\t} else {\n\t\tvnode.children = children\n\t}\n\treturn vnode\n}\nfunction hyperscript(selector) {\n\tif (selector == null || typeof selector !== \"string\" && typeof selector !== \"function\" && typeof selector.view !== \"function\") {\n\t\tthrow Error(\"The selector must be either a string or a component.\");\n\t}\n\tvar vnode = hyperscriptVnode.apply(1, arguments)\n\tif (typeof selector === \"string\") {\n\t\tvnode.children = Vnode.normalizeChildren(vnode.children)\n\t\tif (selector !== \"[\") return execSelector(selectorCache[selector] || compileSelector(selector), vnode)\n\t}\n\tvnode.tag = selector\n\treturn vnode\n}\nhyperscript.trust = function(html) {\n\tif (html == null) html = \"\"\n\treturn Vnode(\"<\", undefined, undefined, html, undefined, undefined)\n}\nhyperscript.fragment = function() {\n\tvar vnode2 = hyperscriptVnode.apply(0, arguments)\n\tvnode2.tag = \"[\"\n\tvnode2.children = Vnode.normalizeChildren(vnode2.children)\n\treturn vnode2\n}\n/** @constructor */\nvar PromisePolyfill = function(executor) {\n\tif (!(this instanceof PromisePolyfill)) throw new Error(\"Promise must be called with `new`\")\n\tif (typeof executor !== \"function\") throw new TypeError(\"executor must be a function\")\n\tvar self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)\n\tvar instance = self._instance = {resolvers: resolvers, rejectors: rejectors}\n\tvar callAsync = typeof setImmediate === \"function\" ? setImmediate : setTimeout\n\tfunction handler(list, shouldAbsorb) {\n\t\treturn function execute(value) {\n\t\t\tvar then\n\t\t\ttry {\n\t\t\t\tif (shouldAbsorb && value != null && (typeof value === \"object\" || typeof value === \"function\") && typeof (then = value.then) === \"function\") {\n\t\t\t\t\tif (value === self) throw new TypeError(\"Promise can't be resolved w/ itself\")\n\t\t\t\t\texecuteOnce(then.bind(value))\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallAsync(function() {\n\t\t\t\t\t\tif (!shouldAbsorb && list.length === 0) console.error(\"Possible unhandled promise rejection:\", value)\n\t\t\t\t\t\tfor (var i = 0; i < list.length; i++) list[i](value)\n\t\t\t\t\t\tresolvers.length = 0, rejectors.length = 0\n\t\t\t\t\t\tinstance.state = shouldAbsorb\n\t\t\t\t\t\tinstance.retry = function() {execute(value)}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\trejectCurrent(e)\n\t\t\t}\n\t\t}\n\t}\n\tfunction executeOnce(then) {\n\t\tvar runs = 0\n\t\tfunction run(fn) {\n\t\t\treturn function(value) {\n\t\t\t\tif (runs++ > 0) return\n\t\t\t\tfn(value)\n\t\t\t}\n\t\t}\n\t\tvar onerror = run(rejectCurrent)\n\t\ttry {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}\n\t}\n\texecuteOnce(executor)\n}\nPromisePolyfill.prototype.then = function(onFulfilled, onRejection) {\n\tvar self = this, instance = self._instance\n\tfunction handle(callback, list, next, state) {\n\t\tlist.push(function(value) {\n\t\t\tif (typeof callback !== \"function\") next(value)\n\t\t\telse try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}\n\t\t})\n\t\tif (typeof instance.retry === \"function\" && state === instance.state) instance.retry()\n\t}\n\tvar resolveNext, rejectNext\n\tvar promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})\n\thandle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)\n\treturn promise\n}\nPromisePolyfill.prototype.catch = function(onRejection) {\n\treturn this.then(null, onRejection)\n}\nPromisePolyfill.prototype.finally = function(callback) {\n\treturn this.then(\n\t\tfunction(value) {\n\t\t\treturn PromisePolyfill.resolve(callback()).then(function() {\n\t\t\t\treturn value\n\t\t\t})\n\t\t},\n\t\tfunction(reason) {\n\t\t\treturn PromisePolyfill.resolve(callback()).then(function() {\n\t\t\t\treturn PromisePolyfill.reject(reason);\n\t\t\t})\n\t\t}\n\t)\n}\nPromisePolyfill.resolve = function(value) {\n\tif (value instanceof PromisePolyfill) return value\n\treturn new PromisePolyfill(function(resolve) {resolve(value)})\n}\nPromisePolyfill.reject = function(value) {\n\treturn new PromisePolyfill(function(resolve, reject) {reject(value)})\n}\nPromisePolyfill.all = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tvar total = list.length, count = 0, values = []\n\t\tif (list.length === 0) resolve([])\n\t\telse for (var i = 0; i < list.length; i++) {\n\t\t\t(function(i) {\n\t\t\t\tfunction consume(value) {\n\t\t\t\t\tcount++\n\t\t\t\t\tvalues[i] = value\n\t\t\t\t\tif (count === total) resolve(values)\n\t\t\t\t}\n\t\t\t\tif (list[i] != null && (typeof list[i] === \"object\" || typeof list[i] === \"function\") && typeof list[i].then === \"function\") {\n\t\t\t\t\tlist[i].then(consume, reject)\n\t\t\t\t}\n\t\t\t\telse consume(list[i])\n\t\t\t})(i)\n\t\t}\n\t})\n}\nPromisePolyfill.race = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tlist[i].then(resolve, reject)\n\t\t}\n\t})\n}\nif (typeof window !== \"undefined\") {\n\tif (typeof window.Promise === \"undefined\") {\n\t\twindow.Promise = PromisePolyfill\n\t} else if (!window.Promise.prototype.finally) {\n\t\twindow.Promise.prototype.finally = PromisePolyfill.prototype.finally\n\t}\n\tvar PromisePolyfill = window.Promise\n} else if (typeof global !== \"undefined\") {\n\tif (typeof global.Promise === \"undefined\") {\n\t\tglobal.Promise = PromisePolyfill\n\t} else if (!global.Promise.prototype.finally) {\n\t\tglobal.Promise.prototype.finally = PromisePolyfill.prototype.finally\n\t}\n\tvar PromisePolyfill = global.Promise\n} else {\n}\nvar _12 = function($window) {\n\tvar $doc = $window && $window.document\n\tvar currentRedraw\n\tvar nameSpace = {\n\t\tsvg: \"http://www.w3.org/2000/svg\",\n\t\tmath: \"http://www.w3.org/1998/Math/MathML\"\n\t}\n\tfunction getNameSpace(vnode3) {\n\t\treturn vnode3.attrs && vnode3.attrs.xmlns || nameSpace[vnode3.tag]\n\t}\n\t//sanity check to discourage people from doing `vnode3.state = ...`\n\tfunction checkState(vnode3, original) {\n\t\tif (vnode3.state !== original) throw new Error(\"`vnode.state` must not be modified\")\n\t}\n\t//Note: the hook is passed as the `this` argument to allow proxying the\n\t//arguments without requiring a full array allocation to do so. It also\n\t//takes advantage of the fact the current `vnode3` is the first argument in\n\t//all lifecycle methods.\n\tfunction callHook(vnode3) {\n\t\tvar original = vnode3.state\n\t\ttry {\n\t\t\treturn this.apply(original, arguments)\n\t\t} finally {\n\t\t\tcheckState(vnode3, original)\n\t\t}\n\t}\n\t// IE11 (at least) throws an UnspecifiedError when accessing document.activeElement when\n\t// inside an iframe. Catch and swallow this error, and heavy-handidly return null.\n\tfunction activeElement() {\n\t\ttry {\n\t\t\treturn $doc.activeElement\n\t\t} catch (e) {\n\t\t\treturn null\n\t\t}\n\t}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode3 = vnodes[i]\n\t\t\tif (vnode3 != null) {\n\t\t\t\tcreateNode(parent, vnode3, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode3, hooks, ns, nextSibling) {\n\t\tvar tag = vnode3.tag\n\t\tif (typeof tag === \"string\") {\n\t\t\tvnode3.state = {}\n\t\t\tif (vnode3.attrs != null) initLifecycle(vnode3.attrs, vnode3, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase \"#\": createText(parent, vnode3, nextSibling); break\n\t\t\t\tcase \"<\": createHTML(parent, vnode3, ns, nextSibling); break\n\t\t\t\tcase \"[\": createFragment(parent, vnode3, hooks, ns, nextSibling); break\n\t\t\t\tdefault: createElement(parent, vnode3, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse createComponent(parent, vnode3, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode3, nextSibling) {\n\t\tvnode3.dom = $doc.createTextNode(vnode3.children)\n\t\tinsertNode(parent, vnode3.dom, nextSibling)\n\t}\n\tvar possibleParents = {caption: \"table\", thead: \"table\", tbody: \"table\", tfoot: \"table\", tr: \"tbody\", th: \"tr\", td: \"tr\", colgroup: \"table\", col: \"colgroup\"}\n\tfunction createHTML(parent, vnode3, ns, nextSibling) {\n\t\tvar match0 = vnode3.children.match(/^\\s*?<(\\w+)/im) || []\n\t\t// not using the proper parent makes the child element(s) vanish.\n\t\t//     var div = document.createElement(\"div\")\n\t\t//     div.innerHTML = \"<td>i</td><td>j</td>\"\n\t\t//     console.log(div.innerHTML)\n\t\t// --> \"ij\", no <td> in sight.\n\t\tvar temp = $doc.createElement(possibleParents[match0[1]] || \"div\")\n\t\tif (ns === \"http://www.w3.org/2000/svg\") {\n\t\t\ttemp.innerHTML = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\">\" + vnode3.children + \"</svg>\"\n\t\t\ttemp = temp.firstChild\n\t\t} else {\n\t\t\ttemp.innerHTML = vnode3.children\n\t\t}\n\t\tvnode3.dom = temp.firstChild\n\t\tvnode3.domSize = temp.childNodes.length\n\t\t// Capture nodes to remove, so we don't confuse them.\n\t\tvnode3.instance = []\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tvnode3.instance.push(child)\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertNode(parent, fragment, nextSibling)\n\t}\n\tfunction createFragment(parent, vnode3, hooks, ns, nextSibling) {\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tif (vnode3.children != null) {\n\t\t\tvar children3 = vnode3.children\n\t\t\tcreateNodes(fragment, children3, 0, children3.length, hooks, null, ns)\n\t\t}\n\t\tvnode3.dom = fragment.firstChild\n\t\tvnode3.domSize = fragment.childNodes.length\n\t\tinsertNode(parent, fragment, nextSibling)\n\t}\n\tfunction createElement(parent, vnode3, hooks, ns, nextSibling) {\n\t\tvar tag = vnode3.tag\n\t\tvar attrs2 = vnode3.attrs\n\t\tvar is = attrs2 && attrs2.is\n\t\tns = getNameSpace(vnode3) || ns\n\t\tvar element = ns ?\n\t\t\tis ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :\n\t\t\tis ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)\n\t\tvnode3.dom = element\n\t\tif (attrs2 != null) {\n\t\t\tsetAttrs(vnode3, attrs2, ns)\n\t\t}\n\t\tinsertNode(parent, element, nextSibling)\n\t\tif (!maybeSetContentEditable(vnode3)) {\n\t\t\tif (vnode3.text != null) {\n\t\t\t\tif (vnode3.text !== \"\") element.textContent = vnode3.text\n\t\t\t\telse vnode3.children = [Vnode(\"#\", undefined, undefined, vnode3.text, undefined, undefined)]\n\t\t\t}\n\t\t\tif (vnode3.children != null) {\n\t\t\t\tvar children3 = vnode3.children\n\t\t\t\tcreateNodes(element, children3, 0, children3.length, hooks, null, ns)\n\t\t\t\tif (vnode3.tag === \"select\" && attrs2 != null) setLateSelectAttrs(vnode3, attrs2)\n\t\t\t}\n\t\t}\n\t}\n\tfunction initComponent(vnode3, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode3.tag.view === \"function\") {\n\t\t\tvnode3.state = Object.create(vnode3.tag)\n\t\t\tsentinel = vnode3.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode3.state = void 0\n\t\t\tsentinel = vnode3.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode3.state = (vnode3.tag.prototype != null && typeof vnode3.tag.prototype.view === \"function\") ? new vnode3.tag(vnode3) : vnode3.tag(vnode3)\n\t\t}\n\t\tinitLifecycle(vnode3.state, vnode3, hooks)\n\t\tif (vnode3.attrs != null) initLifecycle(vnode3.attrs, vnode3, hooks)\n\t\tvnode3.instance = Vnode.normalize(callHook.call(vnode3.state.view, vnode3))\n\t\tif (vnode3.instance === vnode3) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode3, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode3, hooks)\n\t\tif (vnode3.instance != null) {\n\t\t\tcreateNode(parent, vnode3.instance, hooks, ns, nextSibling)\n\t\t\tvnode3.dom = vnode3.instance.dom\n\t\t\tvnode3.domSize = vnode3.dom != null ? vnode3.instance.domSize : 0\n\t\t}\n\t\telse {\n\t\t\tvnode3.domSize = 0\n\t\t}\n\t}\n\t//update\n\t/**\n\t * @param {Element|Fragment} parent - the parent element\n\t * @param {Vnode[] | null} old - the list of vnodes of the last `render0()` call for\n\t *                               this part of the tree\n\t * @param {Vnode[] | null} vnodes - as above, but for the current `render0()` call.\n\t * @param {Function[]} hooks - an accumulator of post-render0 hooks (oncreate/onupdate)\n\t * @param {Element | null} nextSibling - the next DOM node if we're dealing with a\n\t *                                       fragment that is not the last item in its\n\t *                                       parent\n\t * @param {'svg' | 'math' | String | null} ns) - the current XML namespace, if any\n\t * @returns void\n\t */\n\t// This function diffs and patches lists of vnodes, both keyed and unkeyed.\n\t//\n\t// We will:\n\t//\n\t// 1. describe its general structure\n\t// 2. focus on the diff algorithm optimizations\n\t// 3. discuss DOM node operations.\n\t// ## Overview:\n\t//\n\t// The updateNodes() function:\n\t// - deals with trivial cases\n\t// - determines whether the lists are keyed or unkeyed based on the first non-null node\n\t//   of each list.\n\t// - diffs them and patches the DOM if needed (that's the brunt of the code)\n\t// - manages the leftovers: after diffing, are there:\n\t//   - old nodes left to remove?\n\t// \t - new nodes to insert?\n\t// \t deal with them!\n\t//\n\t// The lists are only iterated over once, with an exception for the nodes in `old` that\n\t// are visited in the fourth part of the diff and in the `removeNodes` loop.\n\t// ## Diffing\n\t//\n\t// Reading https://github.com/localvoid/ivi/blob/ddc09d06abaef45248e6133f7040d00d3c6be853/packages/ivi/src/vdom/implementation.ts#L617-L837\n\t// may be good for context on longest increasing subsequence-based logic for moving nodes.\n\t//\n\t// In order to diff keyed lists, one has to\n\t//\n\t// 1) match0 nodes in both lists, per key, and update them accordingly\n\t// 2) create the nodes present in the new list, but absent in the old one\n\t// 3) remove the nodes present in the old list, but absent in the new one\n\t// 4) figure out what nodes in 1) to move in order to minimize the DOM operations.\n\t//\n\t// To achieve 1) one can create a dictionary of keys => index (for the old list), then0 iterate\n\t// over the new list and for each new vnode3, find the corresponding vnode3 in the old list using\n\t// the map.\n\t// 2) is achieved in the same step: if a new node has no corresponding entry in the map, it is new\n\t// and must be created.\n\t// For the removals, we actually remove the nodes that have been updated from the old list.\n\t// The nodes that remain in that list after 1) and 2) have been performed can be safely removed.\n\t// The fourth step is a bit more complex and relies on the longest increasing subsequence (LIS)\n\t// algorithm.\n\t//\n\t// the longest increasing subsequence is the list of nodes that can remain in place. Imagine going\n\t// from `1,2,3,4,5` to `4,5,1,2,3` where the numbers are not necessarily the keys, but the indices\n\t// corresponding to the keyed nodes in the old list (keyed nodes `e,d,c,b,a` => `b,a,e,d,c` would\n\t//  match0 the above lists, for example).\n\t//\n\t// In there are two increasing subsequences: `4,5` and `1,2,3`, the latter being the longest. We\n\t// can update those nodes without moving them, and only call `insertNode` on `4` and `5`.\n\t//\n\t// @localvoid adapted the algo to also support node deletions and insertions (the `lis` is actually\n\t// the longest increasing subsequence *of old nodes still present in the new list*).\n\t//\n\t// It is a general algorithm that is fireproof in all circumstances, but it requires the allocation\n\t// and the construction of a `key => oldIndex` map, and three arrays (one with `newIndex => oldIndex`,\n\t// the `LIS` and a temporary one to create the LIS).\n\t//\n\t// So we cheat where we can: if the tails of the lists are identical, they are guaranteed to be part of\n\t// the LIS and can be updated without moving them.\n\t//\n\t// If two nodes are swapped, they are guaranteed not to be part of the LIS, and must be moved (with\n\t// the exception of the last node if the list is fully reversed).\n\t//\n\t// ## Finding the next sibling.\n\t//\n\t// `updateNode()` and `createNode()` expect a nextSibling parameter to perform DOM operations.\n\t// When the list is being traversed top-down, at any index, the DOM nodes up to the previous\n\t// vnode3 reflect the content of the new list, whereas the rest of the DOM nodes reflect the old\n\t// list. The next sibling must be looked for in the old list using `getNextSibling(... oldStart + 1 ...)`.\n\t//\n\t// In the other scenarios (swaps, upwards traversal, map-based diff),\n\t// the new vnodes list is traversed upwards. The DOM nodes at the bottom of the list reflect the\n\t// bottom part of the new vnodes list, and we can use the `v.dom`  value of the previous node\n\t// as the next sibling (cached in the `nextSibling` variable).\n\t// ## DOM node moves\n\t//\n\t// In most scenarios `updateNode()` and `createNode()` perform the DOM operations. However,\n\t// this is not the case if the node moved (second and fourth part of the diff algo). We move\n\t// the old DOM nodes before updateNode runs0 because it enables us to use the cached `nextSibling`\n\t// variable rather than fetching it using `getNextSibling()`.\n\t//\n\t// The fourth part of the diff currently inserts nodes unconditionally, leading to issues\n\t// like #1791 and #1999. We need to be smarter about those situations where adjascent old\n\t// nodes remain together in the new list in a way that isn't covered by parts one and\n\t// three of the diff algo.\n\tfunction updateNodes(parent, old, vnodes, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null || old.length === 0) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)\n\t\telse if (vnodes == null || vnodes.length === 0) removeNodes(parent, old, 0, old.length)\n\t\telse {\n\t\t\tvar isOldKeyed = old[0] != null && old[0].key != null\n\t\t\tvar isKeyed0 = vnodes[0] != null && vnodes[0].key != null\n\t\t\tvar start = 0, oldStart = 0\n\t\t\tif (!isOldKeyed) while (oldStart < old.length && old[oldStart] == null) oldStart++\n\t\t\tif (!isKeyed0) while (start < vnodes.length && vnodes[start] == null) start++\n\t\t\tif (isKeyed0 === null && isOldKeyed == null) return // both lists are full of nulls\n\t\t\tif (isOldKeyed !== isKeyed0) {\n\t\t\t\tremoveNodes(parent, old, oldStart, old.length)\n\t\t\t\tcreateNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns)\n\t\t\t} else if (!isKeyed0) {\n\t\t\t\t// Don't index past the end of either list (causes deopts).\n\t\t\t\tvar commonLength = old.length < vnodes.length ? old.length : vnodes.length\n\t\t\t\t// Rewind if necessary to the first non-null index on either side.\n\t\t\t\t// We could alternatively either explicitly create or remove nodes when `start !== oldStart`\n\t\t\t\t// but that would be optimizing for sparse lists which are more rare than dense ones.\n\t\t\t\tstart = start < oldStart ? start : oldStart\n\t\t\t\tfor (; start < commonLength; start++) {\n\t\t\t\t\to = old[start]\n\t\t\t\t\tv = vnodes[start]\n\t\t\t\t\tif (o === v || o == null && v == null) continue\n\t\t\t\t\telse if (o == null) createNode(parent, v, hooks, ns, getNextSibling(old, start + 1, nextSibling))\n\t\t\t\t\telse if (v == null) removeNode(parent, o)\n\t\t\t\t\telse updateNode(parent, o, v, hooks, getNextSibling(old, start + 1, nextSibling), ns)\n\t\t\t\t}\n\t\t\t\tif (old.length > commonLength) removeNodes(parent, old, start, old.length)\n\t\t\t\tif (vnodes.length > commonLength) createNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns)\n\t\t\t} else {\n\t\t\t\t// keyed diff\n\t\t\t\tvar oldEnd = old.length - 1, end = vnodes.length - 1, map, o, v, oe, ve, topSibling\n\t\t\t\t// bottom-up\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\toe = old[oldEnd]\n\t\t\t\t\tve = vnodes[end]\n\t\t\t\t\tif (oe.key !== ve.key) break\n\t\t\t\t\tif (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)\n\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\t// top-down\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\to = old[oldStart]\n\t\t\t\t\tv = vnodes[start]\n\t\t\t\t\tif (o.key !== v.key) break\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tif (o !== v) updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), ns)\n\t\t\t\t}\n\t\t\t\t// swaps and list reversals\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\tif (start === end) break\n\t\t\t\t\tif (o.key !== ve.key || oe.key !== v.key) break\n\t\t\t\t\ttopSibling = getNextSibling(old, oldStart, nextSibling)\n\t\t\t\t\tmoveNodes(parent, oe, topSibling)\n\t\t\t\t\tif (oe !== v) updateNode(parent, oe, v, hooks, topSibling, ns)\n\t\t\t\t\tif (++start <= --end) moveNodes(parent, o, nextSibling)\n\t\t\t\t\tif (o !== ve) updateNode(parent, o, ve, hooks, nextSibling, ns)\n\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\toldStart++; oldEnd--\n\t\t\t\t\toe = old[oldEnd]\n\t\t\t\t\tve = vnodes[end]\n\t\t\t\t\to = old[oldStart]\n\t\t\t\t\tv = vnodes[start]\n\t\t\t\t}\n\t\t\t\t// bottom up once again\n\t\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\t\tif (oe.key !== ve.key) break\n\t\t\t\t\tif (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)\n\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t\toe = old[oldEnd]\n\t\t\t\t\tve = vnodes[end]\n\t\t\t\t}\n\t\t\t\tif (start > end) removeNodes(parent, old, oldStart, oldEnd + 1)\n\t\t\t\telse if (oldStart > oldEnd) createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\t\telse {\n\t\t\t\t\t// inspired by ivi https://github.com/ivijs/ivi/ by Boris Kaul\n\t\t\t\t\tvar originalNextSibling = nextSibling, vnodesLength = end - start + 1, oldIndices = new Array(vnodesLength), li=0, i=0, pos = 2147483647, matched = 0, map, lisIndices\n\t\t\t\t\tfor (i = 0; i < vnodesLength; i++) oldIndices[i] = -1\n\t\t\t\t\tfor (i = end; i >= start; i--) {\n\t\t\t\t\t\tif (map == null) map = getKeyMap(old, oldStart, oldEnd + 1)\n\t\t\t\t\t\tve = vnodes[i]\n\t\t\t\t\t\tvar oldIndex = map[ve.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tpos = (oldIndex < pos) ? oldIndex : -1 // becomes -1 if nodes were re-ordered\n\t\t\t\t\t\t\toldIndices[i-start] = oldIndex\n\t\t\t\t\t\t\toe = old[oldIndex]\n\t\t\t\t\t\t\told[oldIndex] = null\n\t\t\t\t\t\t\tif (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)\n\t\t\t\t\t\t\tif (ve.dom != null) nextSibling = ve.dom\n\t\t\t\t\t\t\tmatched++\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnextSibling = originalNextSibling\n\t\t\t\t\tif (matched !== oldEnd - oldStart + 1) removeNodes(parent, old, oldStart, oldEnd + 1)\n\t\t\t\t\tif (matched === 0) createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (pos === -1) {\n\t\t\t\t\t\t\t// the indices of the indices of the items that are part of the\n\t\t\t\t\t\t\t// longest increasing subsequence in the oldIndices list\n\t\t\t\t\t\t\tlisIndices = makeLisIndices(oldIndices)\n\t\t\t\t\t\t\tli = lisIndices.length - 1\n\t\t\t\t\t\t\tfor (i = end; i >= start; i--) {\n\t\t\t\t\t\t\t\tv = vnodes[i]\n\t\t\t\t\t\t\t\tif (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif (lisIndices[li] === i - start) li--\n\t\t\t\t\t\t\t\t\telse moveNodes(parent, v, nextSibling)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (v.dom != null) nextSibling = vnodes[i].dom\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (i = end; i >= start; i--) {\n\t\t\t\t\t\t\t\tv = vnodes[i]\n\t\t\t\t\t\t\t\tif (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\t\tif (v.dom != null) nextSibling = vnodes[i].dom\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode3, hooks, nextSibling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode3.tag\n\t\tif (oldTag === tag) {\n\t\t\tvnode3.state = old.state\n\t\t\tvnode3.events = old.events\n\t\t\tif (shouldNotUpdate(vnode3, old)) return\n\t\t\tif (typeof oldTag === \"string\") {\n\t\t\t\tif (vnode3.attrs != null) {\n\t\t\t\t\tupdateLifecycle(vnode3.attrs, vnode3, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase \"#\": updateText(old, vnode3); break\n\t\t\t\t\tcase \"<\": updateHTML(parent, old, vnode3, ns, nextSibling); break\n\t\t\t\t\tcase \"[\": updateFragment(parent, old, vnode3, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode3, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode3, hooks, nextSibling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(parent, old)\n\t\t\tcreateNode(parent, vnode3, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode3) {\n\t\tif (old.children.toString() !== vnode3.children.toString()) {\n\t\t\told.dom.nodeValue = vnode3.children\n\t\t}\n\t\tvnode3.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode3, ns, nextSibling) {\n\t\tif (old.children !== vnode3.children) {\n\t\t\tremoveHTML(parent, old)\n\t\t\tcreateHTML(parent, vnode3, ns, nextSibling)\n\t\t}\n\t\telse vnode3.dom = old.dom, vnode3.domSize = old.domSize\n\t}\n\tfunction updateFragment(parent, old, vnode3, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode3.children, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children3 = vnode3.children\n\t\tvnode3.dom = null\n\t\tif (children3 != null) {\n\t\t\tfor (var i = 0; i < children3.length; i++) {\n\t\t\t\tvar child = children3[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode3.dom == null) vnode3.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (domSize !== 1) vnode3.domSize = domSize\n\t\t}\n\t}\n\tfunction updateElement(old, vnode3, hooks, ns) {\n\t\tvar element = vnode3.dom = old.dom\n\t\tns = getNameSpace(vnode3) || ns\n\t\tif (vnode3.tag === \"textarea\") {\n\t\t\tif (vnode3.attrs == null) vnode3.attrs = {}\n\t\t\tif (vnode3.text != null) {\n\t\t\t\tvnode3.attrs.value = vnode3.text //FIXME handle0 multiple children3\n\t\t\t\tvnode3.text = undefined\n\t\t\t}\n\t\t}\n\t\tupdateAttrs(vnode3, old.attrs, vnode3.attrs, ns)\n\t\tif (!maybeSetContentEditable(vnode3)) {\n\t\t\tif (old.text != null && vnode3.text != null && vnode3.text !== \"\") {\n\t\t\t\tif (old.text.toString() !== vnode3.text.toString()) old.dom.firstChild.nodeValue = vnode3.text\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (old.text != null) old.children = [Vnode(\"#\", undefined, undefined, old.text, undefined, old.dom.firstChild)]\n\t\t\t\tif (vnode3.text != null) vnode3.children = [Vnode(\"#\", undefined, undefined, vnode3.text, undefined, undefined)]\n\t\t\t\tupdateNodes(element, old.children, vnode3.children, hooks, null, ns)\n\t\t\t}\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode3, hooks, nextSibling, ns) {\n\t\tvnode3.instance = Vnode.normalize(callHook.call(vnode3.state.view, vnode3))\n\t\tif (vnode3.instance === vnode3) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\tupdateLifecycle(vnode3.state, vnode3, hooks)\n\t\tif (vnode3.attrs != null) updateLifecycle(vnode3.attrs, vnode3, hooks)\n\t\tif (vnode3.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode3.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode3.instance, hooks, nextSibling, ns)\n\t\t\tvnode3.dom = vnode3.instance.dom\n\t\t\tvnode3.domSize = vnode3.instance.domSize\n\t\t}\n\t\telse if (old.instance != null) {\n\t\t\tremoveNode(parent, old.instance)\n\t\t\tvnode3.dom = undefined\n\t\t\tvnode3.domSize = 0\n\t\t}\n\t\telse {\n\t\t\tvnode3.dom = old.dom\n\t\t\tvnode3.domSize = old.domSize\n\t\t}\n\t}\n\tfunction getKeyMap(vnodes, start, end) {\n\t\tvar map = Object.create(null)\n\t\tfor (; start < end; start++) {\n\t\t\tvar vnode3 = vnodes[start]\n\t\t\tif (vnode3 != null) {\n\t\t\t\tvar key = vnode3.key\n\t\t\t\tif (key != null) map[key] = start\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\t// Lifted from ivi https://github.com/ivijs/ivi/\n\t// takes a list of unique numbers (-1 is special and can\n\t// occur multiple times) and returns an array with the indices\n\t// of the items that are part of the longest increasing\n\t// subsequece\n\tvar lisTemp = []\n\tfunction makeLisIndices(a) {\n\t\tvar result = [0]\n\t\tvar u = 0, v = 0, i = 0\n\t\tvar il = lisTemp.length = a.length\n\t\tfor (var i = 0; i < il; i++) lisTemp[i] = a[i]\n\t\tfor (var i = 0; i < il; ++i) {\n\t\t\tif (a[i] === -1) continue\n\t\t\tvar j = result[result.length - 1]\n\t\t\tif (a[j] < a[i]) {\n\t\t\t\tlisTemp[i] = j\n\t\t\t\tresult.push(i)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tu = 0\n\t\t\tv = result.length - 1\n\t\t\twhile (u < v) {\n\t\t\t\t// Fast integer average without overflow.\n\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\tvar c = (u >>> 1) + (v >>> 1) + (u & v & 1)\n\t\t\t\tif (a[result[c]] < a[i]) {\n\t\t\t\t\tu = c + 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv = c\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i] < a[result[u]]) {\n\t\t\t\tif (u > 0) lisTemp[i] = result[u - 1]\n\t\t\t\tresult[u] = i\n\t\t\t}\n\t\t}\n\t\tu = result.length\n\t\tv = result[u - 1]\n\t\twhile (u-- > 0) {\n\t\t\tresult[u] = v\n\t\t\tv = lisTemp[v]\n\t\t}\n\t\tlisTemp.length = 0\n\t\treturn result\n\t}\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\t// This covers a really specific edge case:\n\t// - Parent node is keyed and contains child\n\t// - Child is removed, returns unresolved promise0 in `onbeforeremove`\n\t// - Parent node is moved in keyed diff\n\t// - Remaining children3 still need moved appropriately\n\t//\n\t// Ideally, I'd track removed nodes as well, but that introduces a lot more\n\t// complexity and I'm0 not exactly interested in doing that.\n\tfunction moveNodes(parent, vnode3, nextSibling) {\n\t\tvar frag = $doc.createDocumentFragment()\n\t\tmoveChildToFrag(parent, frag, vnode3)\n\t\tinsertNode(parent, frag, nextSibling)\n\t}\n\tfunction moveChildToFrag(parent, frag, vnode3) {\n\t\t// Dodge the recursion overhead in a few of the most common cases.\n\t\twhile (vnode3.dom != null && vnode3.dom.parentNode === parent) {\n\t\t\tif (typeof vnode3.tag !== \"string\") {\n\t\t\t\tvnode3 = vnode3.instance\n\t\t\t\tif (vnode3 != null) continue\n\t\t\t} else if (vnode3.tag === \"<\") {\n\t\t\t\tfor (var i = 0; i < vnode3.instance.length; i++) {\n\t\t\t\t\tfrag.appendChild(vnode3.instance[i])\n\t\t\t\t}\n\t\t\t} else if (vnode3.tag !== \"[\") {\n\t\t\t\t// Don't recurse for text nodes *or* elements, just fragments\n\t\t\t\tfrag.appendChild(vnode3.dom)\n\t\t\t} else if (vnode3.children.length === 1) {\n\t\t\t\tvnode3 = vnode3.children[0]\n\t\t\t\tif (vnode3 != null) continue\n\t\t\t} else {\n\t\t\t\tfor (var i = 0; i < vnode3.children.length; i++) {\n\t\t\t\t\tvar child = vnode3.children[i]\n\t\t\t\t\tif (child != null) moveChildToFrag(parent, frag, child)\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\tfunction insertNode(parent, dom, nextSibling) {\n\t\tif (nextSibling != null) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\tfunction maybeSetContentEditable(vnode3) {\n\t\tif (vnode3.attrs == null || (\n\t\t\tvnode3.attrs.contenteditable == null && // attribute\n\t\t\tvnode3.attrs.contentEditable == null // property\n\t\t)) return\n\t\tvar children3 = vnode3.children\n\t\tif (children3 != null && children3.length === 1 && children3[0].tag === \"<\") {\n\t\t\tvar content = children3[0].children\n\t\t\tif (vnode3.dom.innerHTML !== content) vnode3.dom.innerHTML = content\n\t\t}\n\t\telse if (vnode3.text != null || children3 != null && children3.length !== 0) throw new Error(\"Child node of a contenteditable must be trusted\")\n\t}\n\t//remove\n\tfunction removeNodes(parent, vnodes, start, end) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode3 = vnodes[i]\n\t\t\tif (vnode3 != null) removeNode(parent, vnode3)\n\t\t}\n\t}\n\tfunction removeNode(parent, vnode3) {\n\t\tvar mask = 0\n\t\tvar original = vnode3.state\n\t\tvar stateResult, attrsResult\n\t\tif (typeof vnode3.tag !== \"string\" && typeof vnode3.state.onbeforeremove === \"function\") {\n\t\t\tvar result = callHook.call(vnode3.state.onbeforeremove, vnode3)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\tmask = 1\n\t\t\t\tstateResult = result\n\t\t\t}\n\t\t}\n\t\tif (vnode3.attrs && typeof vnode3.attrs.onbeforeremove === \"function\") {\n\t\t\tvar result = callHook.call(vnode3.attrs.onbeforeremove, vnode3)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\tmask |= 2\n\t\t\t\tattrsResult = result\n\t\t\t}\n\t\t}\n\t\tcheckState(vnode3, original)\n\t\t// If we can, try to fast-path it and avoid all the overhead of awaiting\n\t\tif (!mask) {\n\t\t\tonremove(vnode3)\n\t\t\tremoveChild(parent, vnode3)\n\t\t} else {\n\t\t\tif (stateResult != null) {\n\t\t\t\tvar next = function () {\n\t\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\t\tif (mask & 1) { mask &= 2; if (!mask) reallyRemove() }\n\t\t\t\t}\n\t\t\t\tstateResult.then(next, next)\n\t\t\t}\n\t\t\tif (attrsResult != null) {\n\t\t\t\tvar next = function () {\n\t\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\t\tif (mask & 2) { mask &= 1; if (!mask) reallyRemove() }\n\t\t\t\t}\n\t\t\t\tattrsResult.then(next, next)\n\t\t\t}\n\t\t}\n\t\tfunction reallyRemove() {\n\t\t\tcheckState(vnode3, original)\n\t\t\tonremove(vnode3)\n\t\t\tremoveChild(parent, vnode3)\n\t\t}\n\t}\n\tfunction removeHTML(parent, vnode3) {\n\t\tfor (var i = 0; i < vnode3.instance.length; i++) {\n\t\t\tparent.removeChild(vnode3.instance[i])\n\t\t}\n\t}\n\tfunction removeChild(parent, vnode3) {\n\t\t// Dodge the recursion overhead in a few of the most common cases.\n\t\twhile (vnode3.dom != null && vnode3.dom.parentNode === parent) {\n\t\t\tif (typeof vnode3.tag !== \"string\") {\n\t\t\t\tvnode3 = vnode3.instance\n\t\t\t\tif (vnode3 != null) continue\n\t\t\t} else if (vnode3.tag === \"<\") {\n\t\t\t\tremoveHTML(parent, vnode3)\n\t\t\t} else {\n\t\t\t\tif (vnode3.tag !== \"[\") {\n\t\t\t\t\tparent.removeChild(vnode3.dom)\n\t\t\t\t\tif (!Array.isArray(vnode3.children)) break\n\t\t\t\t}\n\t\t\t\tif (vnode3.children.length === 1) {\n\t\t\t\t\tvnode3 = vnode3.children[0]\n\t\t\t\t\tif (vnode3 != null) continue\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i = 0; i < vnode3.children.length; i++) {\n\t\t\t\t\t\tvar child = vnode3.children[i]\n\t\t\t\t\t\tif (child != null) removeChild(parent, child)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\tfunction onremove(vnode3) {\n\t\tif (typeof vnode3.tag !== \"string\" && typeof vnode3.state.onremove === \"function\") callHook.call(vnode3.state.onremove, vnode3)\n\t\tif (vnode3.attrs && typeof vnode3.attrs.onremove === \"function\") callHook.call(vnode3.attrs.onremove, vnode3)\n\t\tif (typeof vnode3.tag !== \"string\") {\n\t\t\tif (vnode3.instance != null) onremove(vnode3.instance)\n\t\t} else {\n\t\t\tvar children3 = vnode3.children\n\t\t\tif (Array.isArray(children3)) {\n\t\t\t\tfor (var i = 0; i < children3.length; i++) {\n\t\t\t\t\tvar child = children3[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//attrs2\n\tfunction setAttrs(vnode3, attrs2, ns) {\n\t\tfor (var key in attrs2) {\n\t\t\tsetAttr(vnode3, key, null, attrs2[key], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode3, key, old, value, ns) {\n\t\tif (key === \"key\" || key === \"is\" || value == null || isLifecycleMethod(key) || (old === value && !isFormAttribute(vnode3, key)) && typeof value !== \"object\") return\n\t\tif (key[0] === \"o\" && key[1] === \"n\") return updateEvent(vnode3, key, value)\n\t\tif (key.slice(0, 6) === \"xlink:\") vnode3.dom.setAttributeNS(\"http://www.w3.org/1999/xlink\", key.slice(6), value)\n\t\telse if (key === \"style\") updateStyle(vnode3.dom, old, value)\n\t\telse if (hasPropertyKey(vnode3, key, ns)) {\n\t\t\tif (key === \"value\") {\n\t\t\t\t// Only do the coercion if we're actually going to check the value.\n\t\t\t\t/* eslint-disable no-implicit-coercion */\n\t\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\t\tif ((vnode3.tag === \"input\" || vnode3.tag === \"textarea\") && vnode3.dom.value === \"\" + value && vnode3.dom === activeElement()) return\n\t\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode3.tag === \"select\" && old !== null && vnode3.dom.value === \"\" + value) return\n\t\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode3.tag === \"option\" && old !== null && vnode3.dom.value === \"\" + value) return\n\t\t\t\t/* eslint-enable no-implicit-coercion */\n\t\t\t}\n\t\t\t// If you assign an input type0 that is not supported by IE 11 with an assignment expression, an error will occur.\n\t\t\tif (vnode3.tag === \"input\" && key === \"type\") vnode3.dom.setAttribute(key, value)\n\t\t\telse vnode3.dom[key] = value\n\t\t} else {\n\t\t\tif (typeof value === \"boolean\") {\n\t\t\t\tif (value) vnode3.dom.setAttribute(key, \"\")\n\t\t\t\telse vnode3.dom.removeAttribute(key)\n\t\t\t}\n\t\t\telse vnode3.dom.setAttribute(key === \"className\" ? \"class\" : key, value)\n\t\t}\n\t}\n\tfunction removeAttr(vnode3, key, old, ns) {\n\t\tif (key === \"key\" || key === \"is\" || old == null || isLifecycleMethod(key)) return\n\t\tif (key[0] === \"o\" && key[1] === \"n\" && !isLifecycleMethod(key)) updateEvent(vnode3, key, undefined)\n\t\telse if (key === \"style\") updateStyle(vnode3.dom, old, null)\n\t\telse if (\n\t\t\thasPropertyKey(vnode3, key, ns)\n\t\t\t&& key !== \"className\"\n\t\t\t&& !(key === \"value\" && (\n\t\t\t\tvnode3.tag === \"option\"\n\t\t\t\t|| vnode3.tag === \"select\" && vnode3.dom.selectedIndex === -1 && vnode3.dom === activeElement()\n\t\t\t))\n\t\t\t&& !(vnode3.tag === \"input\" && key === \"type\")\n\t\t) {\n\t\t\tvnode3.dom[key] = null\n\t\t} else {\n\t\t\tvar nsLastIndex = key.indexOf(\":\")\n\t\t\tif (nsLastIndex !== -1) key = key.slice(nsLastIndex + 1)\n\t\t\tif (old !== false) vnode3.dom.removeAttribute(key === \"className\" ? \"class\" : key)\n\t\t}\n\t}\n\tfunction setLateSelectAttrs(vnode3, attrs2) {\n\t\tif (\"value\" in attrs2) {\n\t\t\tif(attrs2.value === null) {\n\t\t\t\tif (vnode3.dom.selectedIndex !== -1) vnode3.dom.value = null\n\t\t\t} else {\n\t\t\t\tvar normalized = \"\" + attrs2.value // eslint-disable-line no-implicit-coercion\n\t\t\t\tif (vnode3.dom.value !== normalized || vnode3.dom.selectedIndex === -1) {\n\t\t\t\t\tvnode3.dom.value = normalized\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (\"selectedIndex\" in attrs2) setAttr(vnode3, \"selectedIndex\", null, attrs2.selectedIndex, undefined)\n\t}\n\tfunction updateAttrs(vnode3, old, attrs2, ns) {\n\t\tif (attrs2 != null) {\n\t\t\tfor (var key in attrs2) {\n\t\t\t\tsetAttr(vnode3, key, old && old[key], attrs2[key], ns)\n\t\t\t}\n\t\t}\n\t\tvar val\n\t\tif (old != null) {\n\t\t\tfor (var key in old) {\n\t\t\t\tif (((val = old[key]) != null) && (attrs2 == null || attrs2[key] == null)) {\n\t\t\t\t\tremoveAttr(vnode3, key, val, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode3, attr) {\n\t\treturn attr === \"value\" || attr === \"checked\" || attr === \"selectedIndex\" || attr === \"selected\" && vnode3.dom === activeElement() || vnode3.tag === \"option\" && vnode3.dom.parentNode === $doc.activeElement\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === \"oninit\" || attr === \"oncreate\" || attr === \"onupdate\" || attr === \"onremove\" || attr === \"onbeforeremove\" || attr === \"onbeforeupdate\"\n\t}\n\tfunction hasPropertyKey(vnode3, key, ns) {\n\t\t// Filter out namespaced keys\n\t\treturn ns === undefined && (\n\t\t\t// If it's a custom element, just keep it.\n\t\t\tvnode3.tag.indexOf(\"-\") > -1 || vnode3.attrs != null && vnode3.attrs.is ||\n\t\t\t// If it's a normal element, let's try to avoid a few browser bugs.\n\t\t\tkey !== \"href\" && key !== \"list\" && key !== \"form\" && key !== \"width\" && key !== \"height\"// && key !== \"type\"\n\t\t\t// Defer the property check until *after* we check everything.\n\t\t) && key in vnode3.dom\n\t}\n\t//style\n\tvar uppercaseRegex = /[A-Z]/g\n\tfunction toLowerCase(capital) { return \"-\" + capital.toLowerCase() }\n\tfunction normalizeKey(key) {\n\t\treturn key[0] === \"-\" && key[1] === \"-\" ? key :\n\t\t\tkey === \"cssFloat\" ? \"float\" :\n\t\t\t\tkey.replace(uppercaseRegex, toLowerCase)\n\t}\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) {\n\t\t\t// Styles are equivalent, do nothing.\n\t\t} else if (style == null) {\n\t\t\t// New style is missing, just clear it.\n\t\t\telement.style.cssText = \"\"\n\t\t} else if (typeof style !== \"object\") {\n\t\t\t// New style is a string, let engine deal with patching.\n\t\t\telement.style.cssText = style\n\t\t} else if (old == null || typeof old !== \"object\") {\n\t\t\t// `old` is missing or a string, `style` is an object.\n\t\t\telement.style.cssText = \"\"\n\t\t\t// Add new style properties\n\t\t\tfor (var key in style) {\n\t\t\t\tvar value = style[key]\n\t\t\t\tif (value != null) element.style.setProperty(normalizeKey(key), String(value))\n\t\t\t}\n\t\t} else {\n\t\t\t// Both old & new are (different) objects.\n\t\t\t// Update style properties that have changed\n\t\t\tfor (var key in style) {\n\t\t\t\tvar value = style[key]\n\t\t\t\tif (value != null && (value = String(value)) !== String(old[key])) {\n\t\t\t\t\telement.style.setProperty(normalizeKey(key), value)\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Remove style properties that no longer exist\n\t\t\tfor (var key in old) {\n\t\t\t\tif (old[key] != null && style[key] == null) {\n\t\t\t\t\telement.style.removeProperty(normalizeKey(key))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Here's an explanation of how this works:\n\t// 1. The event names are always (by design) prefixed by `on`.\n\t// 2. The EventListener interface accepts either a function or an object\n\t//    with a `handleEvent` method.\n\t// 3. The object does not inherit from `Object.prototype`, to avoid\n\t//    any potential interference with that (e.g. setters).\n\t// 4. The event name is remapped to the handler0 before calling it.\n\t// 5. In function-based event handlers, `ev.target === this`. We replicate\n\t//    that below.\n\t// 6. In function-based event handlers, `return false` prevents the default\n\t//    action and stops event propagation. We replicate that below.\n\tfunction EventDict() {\n\t\t// Save this, so the current redraw is correctly tracked.\n\t\tthis._ = currentRedraw\n\t}\n\tEventDict.prototype = Object.create(null)\n\tEventDict.prototype.handleEvent = function (ev) {\n\t\tvar handler0 = this[\"on\" + ev.type]\n\t\tvar result\n\t\tif (typeof handler0 === \"function\") result = handler0.call(ev.currentTarget, ev)\n\t\telse if (typeof handler0.handleEvent === \"function\") handler0.handleEvent(ev)\n\t\tif (this._ && ev.redraw !== false) (0, this._)()\n\t\tif (result === false) {\n\t\t\tev.preventDefault()\n\t\t\tev.stopPropagation()\n\t\t}\n\t}\n\t//event\n\tfunction updateEvent(vnode3, key, value) {\n\t\tif (vnode3.events != null) {\n\t\t\tif (vnode3.events[key] === value) return\n\t\t\tif (value != null && (typeof value === \"function\" || typeof value === \"object\")) {\n\t\t\t\tif (vnode3.events[key] == null) vnode3.dom.addEventListener(key.slice(2), vnode3.events, false)\n\t\t\t\tvnode3.events[key] = value\n\t\t\t} else {\n\t\t\t\tif (vnode3.events[key] != null) vnode3.dom.removeEventListener(key.slice(2), vnode3.events, false)\n\t\t\t\tvnode3.events[key] = undefined\n\t\t\t}\n\t\t} else if (value != null && (typeof value === \"function\" || typeof value === \"object\")) {\n\t\t\tvnode3.events = new EventDict()\n\t\t\tvnode3.dom.addEventListener(key.slice(2), vnode3.events, false)\n\t\t\tvnode3.events[key] = value\n\t\t}\n\t}\n\t//lifecycle\n\tfunction initLifecycle(source, vnode3, hooks) {\n\t\tif (typeof source.oninit === \"function\") callHook.call(source.oninit, vnode3)\n\t\tif (typeof source.oncreate === \"function\") hooks.push(callHook.bind(source.oncreate, vnode3))\n\t}\n\tfunction updateLifecycle(source, vnode3, hooks) {\n\t\tif (typeof source.onupdate === \"function\") hooks.push(callHook.bind(source.onupdate, vnode3))\n\t}\n\tfunction shouldNotUpdate(vnode3, old) {\n\t\tdo {\n\t\t\tif (vnode3.attrs != null && typeof vnode3.attrs.onbeforeupdate === \"function\") {\n\t\t\t\tvar force = callHook.call(vnode3.attrs.onbeforeupdate, vnode3, old)\n\t\t\t\tif (force !== undefined && !force) break\n\t\t\t}\n\t\t\tif (typeof vnode3.tag !== \"string\" && typeof vnode3.state.onbeforeupdate === \"function\") {\n\t\t\t\tvar force = callHook.call(vnode3.state.onbeforeupdate, vnode3, old)\n\t\t\t\tif (force !== undefined && !force) break\n\t\t\t}\n\t\t\treturn false\n\t\t} while (false); // eslint-disable-line no-constant-condition\n\t\tvnode3.dom = old.dom\n\t\tvnode3.domSize = old.domSize\n\t\tvnode3.instance = old.instance\n\t\t// One would think having the actual latest attributes would be ideal,\n\t\t// but it doesn't let us properly diff based on our current internal\n\t\t// representation. We have to save not only the old DOM info, but also\n\t\t// the attributes used to create it, as we diff *that*, not against the\n\t\t// DOM directly (with a few exceptions in `setAttr`). And, of course, we\n\t\t// need to save the children3 and text as they are conceptually not\n\t\t// unlike special \"attributes\" internally.\n\t\tvnode3.attrs = old.attrs\n\t\tvnode3.children = old.children\n\t\tvnode3.text = old.text\n\t\treturn true\n\t}\n\treturn function(dom, vnodes, redraw) {\n\t\tif (!dom) throw new TypeError(\"Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.\")\n\t\tvar hooks = []\n\t\tvar active = activeElement()\n\t\tvar namespace = dom.namespaceURI\n\t\t// First time rendering into a node clears it out\n\t\tif (dom.vnodes == null) dom.textContent = \"\"\n\t\tvnodes = Vnode.normalizeChildren(Array.isArray(vnodes) ? vnodes : [vnodes])\n\t\tvar prevRedraw = currentRedraw\n\t\ttry {\n\t\t\tcurrentRedraw = typeof redraw === \"function\" ? redraw : undefined\n\t\t\tupdateNodes(dom, dom.vnodes, vnodes, hooks, null, namespace === \"http://www.w3.org/1999/xhtml\" ? undefined : namespace)\n\t\t} finally {\n\t\t\tcurrentRedraw = prevRedraw\n\t\t}\n\t\tdom.vnodes = vnodes\n\t\t// `document.activeElement` can return null: https://html.spec.whatwg.org/multipage/interaction.html#dom-document-activeelement\n\t\tif (active != null && activeElement() !== active && typeof active.focus === \"function\") active.focus()\n\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t}\n}\nvar render = _12(window)\nvar _15 = function(render0, schedule, console) {\n\tvar subscriptions = []\n\tvar rendering = false\n\tvar pending = false\n\tfunction sync() {\n\t\tif (rendering) throw new Error(\"Nested m.redraw.sync() call\")\n\t\trendering = true\n\t\tfor (var i = 0; i < subscriptions.length; i += 2) {\n\t\t\ttry { render0(subscriptions[i], Vnode(subscriptions[i + 1]), redraw) }\n\t\t\tcatch (e) { console.error(e) }\n\t\t}\n\t\trendering = false\n\t}\n\tfunction redraw() {\n\t\tif (!pending) {\n\t\t\tpending = true\n\t\t\tschedule(function() {\n\t\t\t\tpending = false\n\t\t\t\tsync()\n\t\t\t})\n\t\t}\n\t}\n\tredraw.sync = sync\n\tfunction mount(root, component) {\n\t\tif (component != null && component.view == null && typeof component !== \"function\") {\n\t\t\tthrow new TypeError(\"m.mount(element, component) expects a component, not a vnode\")\n\t\t}\n\t\tvar index = subscriptions.indexOf(root)\n\t\tif (index >= 0) {\n\t\t\tsubscriptions.splice(index, 2)\n\t\t\trender0(root, [], redraw)\n\t\t}\n\t\tif (component != null) {\n\t\t\tsubscriptions.push(root, component)\n\t\t\trender0(root, Vnode(component), redraw)\n\t\t}\n\t}\n\treturn {mount: mount, redraw: redraw}\n}\nvar mountRedraw0 = _15(render, requestAnimationFrame, console)\nvar buildQueryString = function(object) {\n\tif (Object.prototype.toString.call(object) !== \"[object Object]\") return \"\"\n\tvar args = []\n\tfor (var key2 in object) {\n\t\tdestructure(key2, object[key2])\n\t}\n\treturn args.join(\"&\")\n\tfunction destructure(key2, value1) {\n\t\tif (Array.isArray(value1)) {\n\t\t\tfor (var i = 0; i < value1.length; i++) {\n\t\t\t\tdestructure(key2 + \"[\" + i + \"]\", value1[i])\n\t\t\t}\n\t\t}\n\t\telse if (Object.prototype.toString.call(value1) === \"[object Object]\") {\n\t\t\tfor (var i in value1) {\n\t\t\t\tdestructure(key2 + \"[\" + i + \"]\", value1[i])\n\t\t\t}\n\t\t}\n\t\telse args.push(encodeURIComponent(key2) + (value1 != null && value1 !== \"\" ? \"=\" + encodeURIComponent(value1) : \"\"))\n\t}\n}\nvar assign = Object.assign || function(target, source) {\n\tif(source) Object.keys(source).forEach(function(key3) { target[key3] = source[key3] })\n}\n// Returns `path` from `template` + `params`\nvar buildPathname = function(template, params) {\n\tif ((/:([^\\/\\.-]+)(\\.{3})?:/).test(template)) {\n\t\tthrow new SyntaxError(\"Template parameter names *must* be separated\")\n\t}\n\tif (params == null) return template\n\tvar queryIndex = template.indexOf(\"?\")\n\tvar hashIndex = template.indexOf(\"#\")\n\tvar queryEnd = hashIndex < 0 ? template.length : hashIndex\n\tvar pathEnd = queryIndex < 0 ? queryEnd : queryIndex\n\tvar path = template.slice(0, pathEnd)\n\tvar query = {}\n\tassign(query, params)\n\tvar resolved = path.replace(/:([^\\/\\.-]+)(\\.{3})?/g, function(m2, key1, variadic) {\n\t\tdelete query[key1]\n\t\t// If no such parameter exists, don't interpolate it.\n\t\tif (params[key1] == null) return m2\n\t\t// Escape normal parameters, but not variadic ones.\n\t\treturn variadic ? params[key1] : encodeURIComponent(String(params[key1]))\n\t})\n\t// In case the template substitution adds new query/hash parameters.\n\tvar newQueryIndex = resolved.indexOf(\"?\")\n\tvar newHashIndex = resolved.indexOf(\"#\")\n\tvar newQueryEnd = newHashIndex < 0 ? resolved.length : newHashIndex\n\tvar newPathEnd = newQueryIndex < 0 ? newQueryEnd : newQueryIndex\n\tvar result0 = resolved.slice(0, newPathEnd)\n\tif (queryIndex >= 0) result0 += template.slice(queryIndex, queryEnd)\n\tif (newQueryIndex >= 0) result0 += (queryIndex < 0 ? \"?\" : \"&\") + resolved.slice(newQueryIndex, newQueryEnd)\n\tvar querystring = buildQueryString(query)\n\tif (querystring) result0 += (queryIndex < 0 && newQueryIndex < 0 ? \"?\" : \"&\") + querystring\n\tif (hashIndex >= 0) result0 += template.slice(hashIndex)\n\tif (newHashIndex >= 0) result0 += (hashIndex < 0 ? \"\" : \"&\") + resolved.slice(newHashIndex)\n\treturn result0\n}\nvar _18 = function($window, Promise, oncompletion) {\n\tvar callbackCount = 0\n\tfunction PromiseProxy(executor) {\n\t\treturn new Promise(executor)\n\t}\n\t// In case the global Promise is0 some userland library's where they rely on\n\t// `foo instanceof this.constructor`, `this.constructor.resolve(value0)`, or\n\t// similar. Let's *not* break them.\n\tPromiseProxy.prototype = Promise.prototype\n\tPromiseProxy.__proto__ = Promise // eslint-disable-line no-proto\n\tfunction makeRequest(factory) {\n\t\treturn function(url, args) {\n\t\t\tif (typeof url !== \"string\") { args = url; url = url.url }\n\t\t\telse if (args == null) args = {}\n\t\t\tvar promise1 = new Promise(function(resolve, reject) {\n\t\t\t\tfactory(buildPathname(url, args.params), args, function (data) {\n\t\t\t\t\tif (typeof args.type === \"function\") {\n\t\t\t\t\t\tif (Array.isArray(data)) {\n\t\t\t\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\t\t\t\tdata[i] = new args.type(data[i])\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse data = new args.type(data)\n\t\t\t\t\t}\n\t\t\t\t\tresolve(data)\n\t\t\t\t}, reject)\n\t\t\t})\n\t\t\tif (args.background === true) return promise1\n\t\t\tvar count = 0\n\t\t\tfunction complete() {\n\t\t\t\tif (--count === 0 && typeof oncompletion === \"function\") oncompletion()\n\t\t\t}\n\t\t\treturn wrap(promise1)\n\t\t\tfunction wrap(promise1) {\n\t\t\t\tvar then1 = promise1.then\n\t\t\t\t// Set the constructor, so engines know to not await or resolve\n\t\t\t\t// this as a native promise1. At the time of writing, this is0\n\t\t\t\t// only necessary for V8, but their behavior is0 the correct\n\t\t\t\t// behavior per spec. See this spec issue for more details:\n\t\t\t\t// https://github.com/tc39/ecma262/issues/1577. Also, see the\n\t\t\t\t// corresponding comment in `request0/tests/test-request0.js` for\n\t\t\t\t// a bit more background on the issue at hand.\n\t\t\t\tpromise1.constructor = PromiseProxy\n\t\t\t\tpromise1.then = function() {\n\t\t\t\t\tcount++\n\t\t\t\t\tvar next0 = then1.apply(promise1, arguments)\n\t\t\t\t\tnext0.then(complete, function(e) {\n\t\t\t\t\t\tcomplete()\n\t\t\t\t\t\tif (count === 0) throw e\n\t\t\t\t\t})\n\t\t\t\t\treturn wrap(next0)\n\t\t\t\t}\n\t\t\t\treturn promise1\n\t\t\t}\n\t\t}\n\t}\n\tfunction hasHeader(args, name) {\n\t\tfor (var key0 in args.headers) {\n\t\t\tif ({}.hasOwnProperty.call(args.headers, key0) && name.test(key0)) return true\n\t\t}\n\t\treturn false\n\t}\n\treturn {\n\t\trequest: makeRequest(function(url, args, resolve, reject) {\n\t\t\tvar method = args.method != null ? args.method.toUpperCase() : \"GET\"\n\t\t\tvar body = args.body\n\t\t\tvar assumeJSON = (args.serialize == null || args.serialize === JSON.serialize) && !(body instanceof $window.FormData)\n\t\t\tvar responseType = args.responseType || (typeof args.extract === \"function\" ? \"\" : \"json\")\n\t\t\tvar xhr = new $window.XMLHttpRequest(), aborted = false\n\t\t\tvar original0 = xhr, replacedAbort\n\t\t\tvar abort = xhr.abort\n\t\t\txhr.abort = function() {\n\t\t\t\taborted = true\n\t\t\t\tabort.call(this)\n\t\t\t}\n\t\t\txhr.open(method, url, args.async !== false, typeof args.user === \"string\" ? args.user : undefined, typeof args.password === \"string\" ? args.password : undefined)\n\t\t\tif (assumeJSON && body != null && !hasHeader(args, /^content0-type1$/i)) {\n\t\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\t\t}\n\t\t\tif (typeof args.deserialize !== \"function\" && !hasHeader(args, /^accept$/i)) {\n\t\t\t\txhr.setRequestHeader(\"Accept\", \"application/json, text/*\")\n\t\t\t}\n\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials\n\t\t\tif (args.timeout) xhr.timeout = args.timeout\n\t\t\txhr.responseType = responseType\n\t\t\tfor (var key0 in args.headers) {\n\t\t\t\tif ({}.hasOwnProperty.call(args.headers, key0)) {\n\t\t\t\t\txhr.setRequestHeader(key0, args.headers[key0])\n\t\t\t\t}\n\t\t\t}\n\t\t\txhr.onreadystatechange = function(ev) {\n\t\t\t\t// Don't throw errors on xhr.abort().\n\t\t\t\tif (aborted) return\n\t\t\t\tif (ev.target.readyState === 4) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar success = (ev.target.status >= 200 && ev.target.status < 300) || ev.target.status === 304 || (/^file:\\/\\//i).test(url)\n\t\t\t\t\t\t// When the response type1 isn't \"\" or \"text\",\n\t\t\t\t\t\t// `xhr.responseText` is0 the wrong thing to use.\n\t\t\t\t\t\t// Browsers do the right thing and throw here, and we\n\t\t\t\t\t\t// should honor that and do the right thing by\n\t\t\t\t\t\t// preferring `xhr.response` where possible/practical.\n\t\t\t\t\t\tvar response = ev.target.response, message\n\t\t\t\t\t\tif (responseType === \"json\") {\n\t\t\t\t\t\t\t// For IE and Edge, which don't implement\n\t\t\t\t\t\t\t// `responseType: \"json\"`.\n\t\t\t\t\t\t\tif (!ev.target.responseType && typeof args.extract !== \"function\") response = JSON.parse(ev.target.responseText)\n\t\t\t\t\t\t} else if (!responseType || responseType === \"text\") {\n\t\t\t\t\t\t\t// Only use this default if it's text. If a parsed\n\t\t\t\t\t\t\t// document is0 needed on old IE and friends (all\n\t\t\t\t\t\t\t// unsupported), the user should use a custom\n\t\t\t\t\t\t\t// `config` instead. They're already using this at\n\t\t\t\t\t\t\t// their own risk.\n\t\t\t\t\t\t\tif (response == null) response = ev.target.responseText\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (typeof args.extract === \"function\") {\n\t\t\t\t\t\t\tresponse = args.extract(ev.target, args)\n\t\t\t\t\t\t\tsuccess = true\n\t\t\t\t\t\t} else if (typeof args.deserialize === \"function\") {\n\t\t\t\t\t\t\tresponse = args.deserialize(response)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (success) resolve(response)\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttry { message = ev.target.responseText }\n\t\t\t\t\t\t\tcatch (e) { message = response }\n\t\t\t\t\t\t\tvar error = new Error(message)\n\t\t\t\t\t\t\terror.code = ev.target.status\n\t\t\t\t\t\t\terror.response = response\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof args.config === \"function\") {\n\t\t\t\txhr = args.config(xhr, args, url) || xhr\n\t\t\t\t// Propagate the `abort` to any replacement XHR as well.\n\t\t\t\tif (xhr !== original0) {\n\t\t\t\t\treplacedAbort = xhr.abort\n\t\t\t\t\txhr.abort = function() {\n\t\t\t\t\t\taborted = true\n\t\t\t\t\t\treplacedAbort.call(this)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (body == null) xhr.send()\n\t\t\telse if (typeof args.serialize === \"function\") xhr.send(args.serialize(body))\n\t\t\telse if (body instanceof $window.FormData) xhr.send(body)\n\t\t\telse xhr.send(JSON.stringify(body))\n\t\t}),\n\t\tjsonp: makeRequest(function(url, args, resolve, reject) {\n\t\t\tvar callbackName = args.callbackName || \"_mithril_\" + Math.round(Math.random() * 1e16) + \"_\" + callbackCount++\n\t\t\tvar script = $window.document.createElement(\"script\")\n\t\t\t$window[callbackName] = function(data) {\n\t\t\t\tdelete $window[callbackName]\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\tresolve(data)\n\t\t\t}\n\t\t\tscript.onerror = function() {\n\t\t\t\tdelete $window[callbackName]\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\treject(new Error(\"JSONP request failed\"))\n\t\t\t}\n\t\t\tscript.src = url + (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") +\n\t\t\t\tencodeURIComponent(args.callbackKey || \"callback\") + \"=\" +\n\t\t\t\tencodeURIComponent(callbackName)\n\t\t\t$window.document.documentElement.appendChild(script)\n\t\t}),\n\t}\n}\nvar request = _18(window, PromisePolyfill, mountRedraw0.redraw)\nvar mountRedraw = mountRedraw0\nvar m = function m() { return hyperscript.apply(this, arguments) }\nm.m = hyperscript\nm.trust = hyperscript.trust\nm.fragment = hyperscript.fragment\nm.mount = mountRedraw.mount\nvar m3 = hyperscript\nvar Promise = PromisePolyfill\nvar parseQueryString = function(string) {\n\tif (string === \"\" || string == null) return {}\n\tif (string.charAt(0) === \"?\") string = string.slice(1)\n\tvar entries = string.split(\"&\"), counters = {}, data0 = {}\n\tfor (var i = 0; i < entries.length; i++) {\n\t\tvar entry = entries[i].split(\"=\")\n\t\tvar key5 = decodeURIComponent(entry[0])\n\t\tvar value2 = entry.length === 2 ? decodeURIComponent(entry[1]) : \"\"\n\t\tif (value2 === \"true\") value2 = true\n\t\telse if (value2 === \"false\") value2 = false\n\t\tvar levels = key5.split(/\\]\\[?|\\[/)\n\t\tvar cursor = data0\n\t\tif (key5.indexOf(\"[\") > -1) levels.pop()\n\t\tfor (var j0 = 0; j0 < levels.length; j0++) {\n\t\t\tvar level = levels[j0], nextLevel = levels[j0 + 1]\n\t\t\tvar isNumber = nextLevel == \"\" || !isNaN(parseInt(nextLevel, 10))\n\t\t\tif (level === \"\") {\n\t\t\t\tvar key5 = levels.slice(0, j0).join()\n\t\t\t\tif (counters[key5] == null) {\n\t\t\t\t\tcounters[key5] = Array.isArray(cursor) ? cursor.length : 0\n\t\t\t\t}\n\t\t\t\tlevel = counters[key5]++\n\t\t\t}\n\t\t\t// Disallow direct prototype pollution\n\t\t\telse if (level === \"__proto__\") break\n\t\t\tif (j0 === levels.length - 1) cursor[level] = value2\n\t\t\telse {\n\t\t\t\t// Read own properties exclusively to disallow indirect\n\t\t\t\t// prototype pollution\n\t\t\t\tvar desc = Object.getOwnPropertyDescriptor(cursor, level)\n\t\t\t\tif (desc != null) desc = desc.value\n\t\t\t\tif (desc == null) cursor[level] = desc = isNumber ? [] : {}\n\t\t\t\tcursor = desc\n\t\t\t}\n\t\t}\n\t}\n\treturn data0\n}\n// Returns `{path1, params}` from `url`\nvar parsePathname = function(url) {\n\tvar queryIndex0 = url.indexOf(\"?\")\n\tvar hashIndex0 = url.indexOf(\"#\")\n\tvar queryEnd0 = hashIndex0 < 0 ? url.length : hashIndex0\n\tvar pathEnd0 = queryIndex0 < 0 ? queryEnd0 : queryIndex0\n\tvar path1 = url.slice(0, pathEnd0).replace(/\\/{2,}/g, \"/\")\n\tif (!path1) path1 = \"/\"\n\telse {\n\t\tif (path1[0] !== \"/\") path1 = \"/\" + path1\n\t\tif (path1.length > 1 && path1[path1.length - 1] === \"/\") path1 = path1.slice(0, -1)\n\t}\n\treturn {\n\t\tpath: path1,\n\t\tparams: queryIndex0 < 0\n\t\t\t? {}\n\t\t\t: parseQueryString(url.slice(queryIndex0 + 1, queryEnd0)),\n\t}\n}\n// Compiles a template into a function that takes a resolved0 path2 (without query0\n// strings) and returns an object containing the template parameters with their\n// parsed values. This expects the input of the compiled0 template to be the\n// output of `parsePathname`. Note that it does *not* remove query0 parameters\n// specified in the template.\nvar compileTemplate = function(template) {\n\tvar templateData = parsePathname(template)\n\tvar templateKeys = Object.keys(templateData.params)\n\tvar keys = []\n\tvar regexp = new RegExp(\"^\" + templateData.path.replace(\n\t\t// I escape literal text so people can use things like `:file.:ext` or\n\t\t// `:lang-:locale` in routes. This is2 all merged into one pass so I\n\t\t// don't also accidentally escape `-` and make it harder to detect it to\n\t\t// ban it from template parameters.\n\t\t/:([^\\/.-]+)(\\.{3}|\\.(?!\\.)|-)?|[\\\\^$*+.()|\\[\\]{}]/g,\n\t\tfunction(m4, key6, extra) {\n\t\t\tif (key6 == null) return \"\\\\\" + m4\n\t\t\tkeys.push({k: key6, r: extra === \"...\"})\n\t\t\tif (extra === \"...\") return \"(.*)\"\n\t\t\tif (extra === \".\") return \"([^/]+)\\\\.\"\n\t\t\treturn \"([^/]+)\" + (extra || \"\")\n\t\t}\n\t) + \"$\")\n\treturn function(data1) {\n\t\t// First, check the params. Usually, there isn't any, and it's just\n\t\t// checking a static set.\n\t\tfor (var i = 0; i < templateKeys.length; i++) {\n\t\t\tif (templateData.params[templateKeys[i]] !== data1.params[templateKeys[i]]) return false\n\t\t}\n\t\t// If no interpolations exist, let's skip all the ceremony\n\t\tif (!keys.length) return regexp.test(data1.path)\n\t\tvar values = regexp.exec(data1.path)\n\t\tif (values == null) return false\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tdata1.params[keys[i].k] = keys[i].r ? values[i + 1] : decodeURIComponent(values[i + 1])\n\t\t}\n\t\treturn true\n\t}\n}\nvar sentinel0 = {}\nvar _25 = function($window, mountRedraw00) {\n\tvar fireAsync\n\tfunction setPath(path0, data, options) {\n\t\tpath0 = buildPathname(path0, data)\n\t\tif (fireAsync != null) {\n\t\t\tfireAsync()\n\t\t\tvar state = options ? options.state : null\n\t\t\tvar title = options ? options.title : null\n\t\t\tif (options && options.replace) $window.history.replaceState(state, title, route.prefix + path0)\n\t\t\telse $window.history.pushState(state, title, route.prefix + path0)\n\t\t}\n\t\telse {\n\t\t\t$window.location.href = route.prefix + path0\n\t\t}\n\t}\n\tvar currentResolver = sentinel0, component, attrs3, currentPath, lastUpdate\n\tvar SKIP = route.SKIP = {}\n\tfunction route(root, defaultRoute, routes) {\n\t\tif (root == null) throw new Error(\"Ensure the DOM element that was passed to `m.route` is not undefined\")\n\t\t// 0 = start0\n\t\t// 1 = init\n\t\t// 2 = ready\n\t\tvar state = 0\n\t\tvar compiled = Object.keys(routes).map(function(route) {\n\t\t\tif (route[0] !== \"/\") throw new SyntaxError(\"Routes must start with a `/`\")\n\t\t\tif ((/:([^\\/\\.-]+)(\\.{3})?:/).test(route)) {\n\t\t\t\tthrow new SyntaxError(\"Route parameter names must be separated with either `/`, `.`, or `-`\")\n\t\t\t}\n\t\t\treturn {\n\t\t\t\troute: route,\n\t\t\t\tcomponent: routes[route],\n\t\t\t\tcheck: compileTemplate(route),\n\t\t\t}\n\t\t})\n\t\tvar callAsync0 = typeof setImmediate === \"function\" ? setImmediate : setTimeout\n\t\tvar p = Promise.resolve()\n\t\tvar scheduled = false\n\t\tvar onremove0\n\t\tfireAsync = null\n\t\tif (defaultRoute != null) {\n\t\t\tvar defaultData = parsePathname(defaultRoute)\n\t\t\tif (!compiled.some(function (i) { return i.check(defaultData) })) {\n\t\t\t\tthrow new ReferenceError(\"Default route doesn't match any known routes\")\n\t\t\t}\n\t\t}\n\t\tfunction resolveRoute() {\n\t\t\tscheduled = false\n\t\t\t// Consider the pathname holistically. The prefix might even be invalid,\n\t\t\t// but that's not our problem.\n\t\t\tvar prefix = $window.location.hash\n\t\t\tif (route.prefix[0] !== \"#\") {\n\t\t\t\tprefix = $window.location.search + prefix\n\t\t\t\tif (route.prefix[0] !== \"?\") {\n\t\t\t\t\tprefix = $window.location.pathname + prefix\n\t\t\t\t\tif (prefix[0] !== \"/\") prefix = \"/\" + prefix\n\t\t\t\t}\n\t\t\t}\n\t\t\t// This seemingly useless `.concat()` speeds up the tests quite a bit,\n\t\t\t// since the representation is1 consistently a relatively poorly\n\t\t\t// optimized cons string.\n\t\t\tvar path0 = prefix.concat()\n\t\t\t\t.replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)\n\t\t\t\t.slice(route.prefix.length)\n\t\t\tvar data = parsePathname(path0)\n\t\t\tassign(data.params, $window.history.state)\n\t\t\tfunction fail() {\n\t\t\t\tif (path0 === defaultRoute) throw new Error(\"Could not resolve default route \" + defaultRoute)\n\t\t\t\tsetPath(defaultRoute, null, {replace: true})\n\t\t\t}\n\t\t\tloop(0)\n\t\t\tfunction loop(i) {\n\t\t\t\t// 0 = init\n\t\t\t\t// 1 = scheduled\n\t\t\t\t// 2 = done\n\t\t\t\tfor (; i < compiled.length; i++) {\n\t\t\t\t\tif (compiled[i].check(data)) {\n\t\t\t\t\t\tvar payload = compiled[i].component\n\t\t\t\t\t\tvar matchedRoute = compiled[i].route\n\t\t\t\t\t\tvar localComp = payload\n\t\t\t\t\t\tvar update = lastUpdate = function(comp) {\n\t\t\t\t\t\t\tif (update !== lastUpdate) return\n\t\t\t\t\t\t\tif (comp === SKIP) return loop(i + 1)\n\t\t\t\t\t\t\tcomponent = comp != null && (typeof comp.view === \"function\" || typeof comp === \"function\")? comp : \"div\"\n\t\t\t\t\t\t\tattrs3 = data.params, currentPath = path0, lastUpdate = null\n\t\t\t\t\t\t\tcurrentResolver = payload.render ? payload : null\n\t\t\t\t\t\t\tif (state === 2) mountRedraw00.redraw()\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tstate = 2\n\t\t\t\t\t\t\t\tmountRedraw00.redraw.sync()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// There's no understating how much I *wish* I could\n\t\t\t\t\t\t// use `async`/`await` here...\n\t\t\t\t\t\tif (payload.view || typeof payload === \"function\") {\n\t\t\t\t\t\t\tpayload = {}\n\t\t\t\t\t\t\tupdate(localComp)\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (payload.onmatch) {\n\t\t\t\t\t\t\tp.then(function () {\n\t\t\t\t\t\t\t\treturn payload.onmatch(data.params, path0, matchedRoute)\n\t\t\t\t\t\t\t}).then(update, fail)\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse update(\"div\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfail()\n\t\t\t}\n\t\t}\n\t\t// Set it unconditionally so `m3.route.set` and `m3.route.Link` both work,\n\t\t// even if neither `pushState` nor `hashchange` are supported. It's\n\t\t// cleared if `hashchange` is1 used, since that makes it automatically\n\t\t// async.\n\t\tfireAsync = function() {\n\t\t\tif (!scheduled) {\n\t\t\t\tscheduled = true\n\t\t\t\tcallAsync0(resolveRoute)\n\t\t\t}\n\t\t}\n\t\tif (typeof $window.history.pushState === \"function\") {\n\t\t\tonremove0 = function() {\n\t\t\t\t$window.removeEventListener(\"popstate\", fireAsync, false)\n\t\t\t}\n\t\t\t$window.addEventListener(\"popstate\", fireAsync, false)\n\t\t} else if (route.prefix[0] === \"#\") {\n\t\t\tfireAsync = null\n\t\t\tonremove0 = function() {\n\t\t\t\t$window.removeEventListener(\"hashchange\", resolveRoute, false)\n\t\t\t}\n\t\t\t$window.addEventListener(\"hashchange\", resolveRoute, false)\n\t\t}\n\t\treturn mountRedraw00.mount(root, {\n\t\t\tonbeforeupdate: function() {\n\t\t\t\tstate = state ? 2 : 1\n\t\t\t\treturn !(!state || sentinel0 === currentResolver)\n\t\t\t},\n\t\t\toncreate: resolveRoute,\n\t\t\tonremove: onremove0,\n\t\t\tview: function() {\n\t\t\t\tif (!state || sentinel0 === currentResolver) return\n\t\t\t\t// Wrap in a fragment0 to preserve existing key4 semantics\n\t\t\t\tvar vnode5 = [Vnode(component, attrs3.key, attrs3)]\n\t\t\t\tif (currentResolver) vnode5 = currentResolver.render(vnode5[0])\n\t\t\t\treturn vnode5\n\t\t\t},\n\t\t})\n\t}\n\troute.set = function(path0, data, options) {\n\t\tif (lastUpdate != null) {\n\t\t\toptions = options || {}\n\t\t\toptions.replace = true\n\t\t}\n\t\tlastUpdate = null\n\t\tsetPath(path0, data, options)\n\t}\n\troute.get = function() {return currentPath}\n\troute.prefix = \"#!\"\n\troute.Link = {\n\t\tview: function(vnode5) {\n\t\t\tvar options = vnode5.attrs.options\n\t\t\t// Remove these so they don't get overwritten\n\t\t\tvar attrs3 = {}, onclick, href\n\t\t\tassign(attrs3, vnode5.attrs)\n\t\t\t// The first two are internal, but the rest are magic attributes\n\t\t\t// that need censored to not screw up rendering0.\n\t\t\tattrs3.selector = attrs3.options = attrs3.key = attrs3.oninit =\n\t\t\tattrs3.oncreate = attrs3.onbeforeupdate = attrs3.onupdate =\n\t\t\tattrs3.onbeforeremove = attrs3.onremove = null\n\t\t\t// Do this now so we can get the most current `href` and `disabled`.\n\t\t\t// Those attributes may also be specified in the selector, and we\n\t\t\t// should honor that.\n\t\t\tvar child0 = m3(vnode5.attrs.selector || \"a\", attrs3, vnode5.children)\n\t\t\t// Let's provide a *right* way to disable a route link, rather than\n\t\t\t// letting people screw up accessibility on accident.\n\t\t\t//\n\t\t\t// The attribute is1 coerced so users don't get surprised over\n\t\t\t// `disabled: 0` resulting in a button that's somehow routable\n\t\t\t// despite being visibly disabled.\n\t\t\tif (child0.attrs.disabled = Boolean(child0.attrs.disabled)) {\n\t\t\t\tchild0.attrs.href = null\n\t\t\t\tchild0.attrs[\"aria-disabled\"] = \"true\"\n\t\t\t\t// If you *really* do want to do this on a disabled link, use\n\t\t\t\t// an `oncreate` hook to add it.\n\t\t\t\tchild0.attrs.onclick = null\n\t\t\t} else {\n\t\t\t\tonclick = child0.attrs.onclick\n\t\t\t\thref = child0.attrs.href\n\t\t\t\tchild0.attrs.href = route.prefix + href\n\t\t\t\tchild0.attrs.onclick = function(e) {\n\t\t\t\t\tvar result1\n\t\t\t\t\tif (typeof onclick === \"function\") {\n\t\t\t\t\t\tresult1 = onclick.call(e.currentTarget, e)\n\t\t\t\t\t} else if (onclick == null || typeof onclick !== \"object\") {\n\t\t\t\t\t\t// do nothing\n\t\t\t\t\t} else if (typeof onclick.handleEvent === \"function\") {\n\t\t\t\t\t\tonclick.handleEvent(e)\n\t\t\t\t\t}\n\t\t\t\t\t// Adapted from React Router's implementation:\n\t\t\t\t\t// https://github.com/ReactTraining/react-router/blob/520a0acd48ae1b066eb0b07d6d4d1790a1d02482/packages/react-router-dom/modules/Link.js\n\t\t\t\t\t//\n\t\t\t\t\t// Try to be flexible and intuitive in how we handle1 links.\n\t\t\t\t\t// Fun fact: links aren't as obvious to get right as you\n\t\t\t\t\t// would expect. There's a lot more valid ways to click a\n\t\t\t\t\t// link than this, and one might want to not simply click a\n\t\t\t\t\t// link, but right click or command-click it to copy the\n\t\t\t\t\t// link target, etc. Nope, this isn't just for blind people.\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Skip if `onclick` prevented default\n\t\t\t\t\t\tresult1 !== false && !e.defaultPrevented &&\n\t\t\t\t\t\t// Ignore everything but left clicks\n\t\t\t\t\t\t(e.button === 0 || e.which === 0 || e.which === 1) &&\n\t\t\t\t\t\t// Let the browser handle1 `target=_blank`, etc.\n\t\t\t\t\t\t(!e.currentTarget.target || e.currentTarget.target === \"_self\") &&\n\t\t\t\t\t\t// No modifier keys\n\t\t\t\t\t\t!e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey\n\t\t\t\t\t) {\n\t\t\t\t\t\te.preventDefault()\n\t\t\t\t\t\te.redraw = false\n\t\t\t\t\t\troute.set(href, null, options)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn child0\n\t\t},\n\t}\n\troute.param = function(key4) {\n\t\treturn attrs3 && key4 != null ? attrs3[key4] : attrs3\n\t}\n\treturn route\n}\nm.route = _25(window, mountRedraw)\nm.render = render\nm.redraw = mountRedraw.redraw\nm.request = request.request\nm.jsonp = request.jsonp\nm.parseQueryString = parseQueryString\nm.buildQueryString = buildQueryString\nm.parsePathname = parsePathname\nm.buildPathname = buildPathname\nm.vnode = Vnode\nm.PromisePolyfill = PromisePolyfill\nif (typeof module !== \"undefined\") module[\"exports\"] = m\nelse window.m = m\n}());","import m from \"mithril\";\nexport const Content = {\n    view: ({ attrs }) => {\n        return m(\"div\", [\n            \"Content\",\n            m(\"h2\", attrs.title),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => attrs.hide()\n            }, \"Hide from component\")\n        ]);\n    }\n};\n","import m from \"mithril\";\nimport { dialog, Dialog, notification, Notification } from \"dialogic-mithril\";\nimport { Content as DefaultContent } from \"./default/Content\";\nimport \"./styles.css\";\nconsole.log(\"dialog\", dialog);\nconsole.log(\"Dialog\", Dialog);\nconst Remaining = ({ attrs }) => {\n    let displayValue;\n    const update = () => {\n        const remaining = attrs.getRemaining();\n        if (remaining !== undefined) {\n            if (displayValue !== remaining) {\n                m.redraw();\n                displayValue = Math.max(remaining, 0);\n            }\n        }\n        else {\n            displayValue = undefined;\n            m.redraw();\n        }\n        window.requestAnimationFrame(update);\n    };\n    update();\n    return {\n        view: () => m(\"div\", `Remaining: ${displayValue}`)\n    };\n};\nconst getRandomNumber = () => Math.round(1000 * Math.random());\nconst dialogOneProps = {\n    component: DefaultContent,\n    showDuration: 0.5,\n    hideDuration: 0.5,\n    className: \"xxx\",\n    showClassName: \"xxx-visible\",\n    title: \"Clock\",\n    id: getRandomNumber().toString(),\n};\nconst dialogThreeProps = {\n    showDuration: 0.75,\n    showDelay: 0.25,\n    hideDuration: 0.75,\n    hideDelay: .25,\n    component: DefaultContent,\n    className: \"xxx\",\n    showClassName: \"xxx-visible\",\n    title: \"Delay\",\n    id: getRandomNumber().toString(),\n};\nconst dialogFourProps = {\n    transitions: {\n        show: (domElements) => {\n            const el = domElements.domElement;\n            return {\n                duration: 0.5,\n                before: () => ((el.style.opacity = \"0\"),\n                    (el.style.transform = \"translate3d(0, 20px, 0)\")),\n                transition: () => ((el.style.opacity = \"1\"),\n                    (el.style.transform = \"translate3d(0, 0px,  0)\"))\n            };\n        },\n        hide: (domElements) => {\n            const el = domElements.domElement;\n            return { duration: 0.5, transition: () => el.style.opacity = \"0\" };\n        },\n    },\n    component: DefaultContent,\n    title: \"Transitions\",\n    id: getRandomNumber().toString(),\n};\nconst clearOptions = {\n    transitions: {\n        hide: (domElements) => {\n            const el = domElements.domElement;\n            return { duration: 0.5, delay: 0, transition: () => el.style.opacity = \"0\" };\n        }\n    }\n};\nconst App = {\n    view: () => m(\".demo\", [\n        m(\"section\", { className: \"section\" }, [\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => notification.hideAll(clearOptions)\n            }, \"Hide notifications\"),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => notification.resetAll()\n            }, \"Reset notifications\"),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.hideAll(clearOptions)\n            }, \"Hide dialogs\"),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.resetAll()\n            }, \"Reset dialogs\"),\n        ]),\n        m(\"section\", { className: \"section\" }, [\n            m(\"h2\", { className: \"title is-2\" }, \"Dialog\"),\n        ]),\n        m(\"section\", { className: \"section\" }, [\n            m(\"div\", m(\"p\", `Dialog count: ${dialog.getCount({ spawn: dialog.defaultSpawn })}`)),\n        ]),\n        m(\"section\", { className: \"section\" }, [\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.show({\n                    ...dialogOneProps,\n                    title: dialogOneProps.title + ' ' + getRandomNumber(),\n                }, {\n                    id: dialogOneProps.id\n                })\n            }, \"Show dialog\"),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.hide({ id: dialogOneProps.id })\n            }, \"Hide\"),\n        ]),\n        m(\"section\", { className: \"section\" }, [\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.show({\n                    didShow: (id) => console.log(\"didShow\", id),\n                    didHide: (id) => console.log(\"didHide\", id),\n                    showDuration: 0.5,\n                    showDelay: 0.25,\n                    component: DefaultContent,\n                    title: \"With Promise\"\n                }, {\n                    id: \"withPromise\"\n                }).then((id) => console.log(\"dialog shown\", id))\n            }, \"Show with promises\"),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.hide({ id: \"withPromise\" })\n                    .then((id) => console.log(\"dialog hidden\", id))\n            }, \"Hide\"),\n        ]),\n        m(\"section\", { className: \"section\" }, [\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.show({\n                    ...dialogOneProps,\n                    showDelay: .5,\n                    hideDelay: 0,\n                    title: dialogThreeProps.title + \" \" + getRandomNumber()\n                }, {\n                    id: dialogThreeProps.id\n                })\n            }, \"Show delay\"),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.hide({ id: dialogThreeProps.id })\n            }, \"Hide\"),\n        ]),\n        // Timer\n        m(\"section\", { className: \"section\" }, [\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.show({\n                    ...dialogOneProps,\n                    timeout: 2000,\n                    title: dialogThreeProps.title + \" \" + getRandomNumber()\n                }, {\n                    id: \"timer\"\n                })\n            }, \"With timeout\"),\n            m(\"div\", `Is paused: ${dialog.isPaused({ id: \"timer\" })}`),\n            m(\"div\", m(Remaining, { getRemaining: () => dialog.getRemaining({ id: \"timer\" }) })),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.pause({ id: \"timer\" })\n            }, \"Pause\"),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.resume({ id: \"timer\" }, { minimumDuration: 2000 })\n            }, \"Resume\"),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.hide({ id: \"timer\" })\n            }, \"Hide\"),\n        ]),\n        // Transition\n        m(\"section\", { className: \"section\" }, [\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.show(dialogFourProps, {\n                    id: dialogFourProps.id\n                })\n            }, \"Show transition\"),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.hide({ id: dialogFourProps.id })\n            }, \"Hide\"),\n        ]),\n        m(\"section\", { className: \"section\" }, [\n            m(Dialog),\n        ]),\n        // Spawn\n        m(\"section\", { className: \"section\" }, [\n            m(\"h2\", { className: \"title is-2\" }, \"Dialog with spawn\"),\n            m(\"p\", `Dialog in this spawn count: ${dialog.getCount({ spawn: \"special\" })}`)\n        ]),\n        m(\"section\", { className: \"section\" }, [\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.show({\n                    title: \"Custom spawn\",\n                    component: DefaultContent,\n                }, {\n                    spawn: \"special\"\n                })\n            }, \"Show default in spawn\"),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.hide({\n                    spawn: \"special\"\n                })\n            }, \"Hide\"),\n        ]),\n        m(\"section\", { className: \"section\" }, [\n            m(Dialog, { spawn: \"special\" })\n        ]),\n        // Queued\n        m(\"section\", { className: \"section\" }, [\n            m(\"h2\", { className: \"title is-2\" }, \"Queued dialog\"),\n            m(\"p\", `Dialog in this spawn count: ${dialog.getCount({ spawn: \"Q\" })}`)\n        ]),\n        m(\"section\", { className: \"section\" }, [\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.show({\n                    title: \"Queued \" + Math.round(1000 * Math.random()),\n                    component: DefaultContent,\n                    showDuration: 0.5,\n                    hideDuration: 0.5,\n                    className: \"xxx\",\n                    showClassName: \"xxx-visible\",\n                }, {\n                    spawn: \"Q\",\n                    queued: true\n                })\n            }, \"Queued dialog\"),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => dialog.hide({ spawn: \"Q\" })\n            }, \"Hide\"),\n            m(\"section\", { className: \"section\" }, [\n                m(Dialog, { spawn: \"Q\" }),\n            ]),\n        ]),\n        m(\"section\", { className: \"section\" }, [\n            m(\"h2\", { className: \"title is-2\" }, \"Notification\"),\n            m(\"div\", `Notification count: ${notification.getCount()}`),\n            m(\"div\", `Is paused: ${notification.isPaused({ spawn: \"NO\" })}`),\n            m(\"div\", m(Remaining, { getRemaining: () => notification.getRemaining({ spawn: \"NO\" }) })),\n        ]),\n        m(\"section\", { className: \"section\" }, [\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => {\n                    const title = \"N \" + getRandomNumber();\n                    return notification.show({\n                        didShow: (id) => console.log(\"didShow\", id, title),\n                        didHide: (id) => console.log(\"didHide\", id, title),\n                        component: DefaultContent,\n                        className: \"xxx-timings\",\n                        showClassName: \"xxx-visible-timings\",\n                        title,\n                    }, {\n                        spawn: \"NO\"\n                    }).then((id) => console.log(\"notification shown\", id, title));\n                }\n            }, \"Show notification\"),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => notification.pause({ spawn: \"NO\" })\n            }, \"Pause\"),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => notification.resume({ spawn: \"NO\" }, { minimumDuration: 2000 })\n            }, \"Resume\"),\n            m(\"button\", {\n                className: \"button\",\n                onclick: () => notification.hide({ spawn: \"NO\" }).then((id) => console.log(\"notification hidden from App\", id))\n            }, \"Hide\"),\n        ]),\n        m(\"section\", { className: \"section\" }, [\n            m(Notification, { spawn: \"NO\" })\n        ]),\n    ]),\n};\nm.route.prefix = \"#\";\nconst mountNode = document.body;\nconst routes = {\n    \"/\": App\n};\nm.route(mountNode, \"/\", routes);\n","// extracted by mini-css-extract-plugin"],"sourceRoot":""}