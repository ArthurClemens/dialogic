{"version":3,"file":"dialogic.cjs","sources":["../src/state/store.ts","../src/state/timer.ts","../src/utils.ts","../src/transition.ts","../src/dialogic.ts","../src/dialogical.ts","../src/dialog.ts","../src/notification.ts","../src/remaining.ts"],"sourcesContent":["import Stream from 'mithril-stream-standalone';\n\nimport { Dialogic } from '../index';\n\ntype PatchFn = (state: Dialogic.State) => Dialogic.State;\n\nconst findItem = <T = unknown>(id: string, items: Dialogic.Item<T>[]) =>\n  items.find(item => item.id === id);\n\nconst itemIndex = <T = unknown>(id: string, items: Dialogic.Item<T>[]) => {\n  const item = findItem<T>(id, items);\n  return item ? items.indexOf(item) : -1;\n};\n\nconst removeItem = <T = unknown>(id: string, items: Dialogic.Item<T>[]) => {\n  const index = itemIndex<T>(id, items);\n  if (index !== -1) {\n    items.splice(index, 1);\n  }\n  return items;\n};\n\nexport const createId = (\n  identityOptions: Dialogic.IdentityOptions,\n  ns: string,\n) => [ns, identityOptions.id, identityOptions.spawn].filter(Boolean).join('-');\n\nconst store = {\n  initialState: {\n    store: {},\n  },\n\n  actions: (update: Stream<PatchFn>) => ({\n    /**\n     * Add an item to the end of the list.\n     */\n    add: <T extends unknown = unknown>(ns: string, item: Dialogic.Item<T>) => {\n      update((state: Dialogic.State) => {\n        const items = state.store[ns] || [];\n        state.store[ns] = [...items, item as Dialogic.Item<unknown>];\n        if (item.timer) {\n          // When the timer state updates, refresh the store so that UI can pick up the change\n          item.timer.states.map(() => store.actions(update).refresh());\n        }\n        return state;\n      });\n    },\n\n    /**\n     * Removes the first item with a match on `id`.\n     */\n    remove: (ns: string, id: string) => {\n      update((state: Dialogic.State) => {\n        const items = state.store[ns] || [];\n        const remaining = removeItem(id, items);\n        state.store[ns] = remaining;\n        return state;\n      });\n    },\n\n    /**\n     * Replaces the first item with a match on `id` with a newItem.\n     */\n    replace: <T = unknown>(\n      ns: string,\n      id: string,\n      newItem: Dialogic.Item<T>,\n    ) => {\n      update((state: Dialogic.State) => {\n        const items = state.store[ns] || [];\n        if (items) {\n          const index = itemIndex(id, items);\n          if (index !== -1) {\n            items[index] = newItem as Dialogic.Item<unknown>;\n            state.store[ns] = [...items] as Dialogic.Item<unknown>[];\n          }\n        }\n        return state;\n      });\n    },\n\n    /**\n     * Removes all items within a namespace.\n     */\n    removeAll: (ns: string) => {\n      update((state: Dialogic.State) => {\n        state.store[ns] = [];\n        return state;\n      });\n    },\n\n    /**\n     * Replaces all items within a namespace.\n     */\n    store: <T = unknown>(ns: string, newItems: Dialogic.Item<T>[]) => {\n      update((state: Dialogic.State) => {\n        state.store[ns] = [...(newItems as Dialogic.Item[])];\n        return state;\n      });\n    },\n\n    refresh: () => {\n      update((state: Dialogic.State) => ({\n        ...state,\n      }));\n    },\n  }),\n\n  selectors: (states: Stream<Dialogic.State>) => {\n    const fns = {\n      getStore: () => {\n        const state = states();\n        return state.store;\n      },\n\n      find: <T = unknown>(\n        ns: string,\n        identityOptions: Dialogic.IdentityOptions,\n      ) => {\n        const state = states();\n        const items = state.store[ns] || [];\n        const id = createId(identityOptions, ns);\n        const item = items.find(fitem => fitem.id === id) as Dialogic.Item<T>;\n        return item ? { just: item } : { nothing: undefined };\n      },\n\n      getAll: <T = unknown>(\n        ns: string,\n        identityOptions?: Dialogic.IdentityOptions,\n      ) => {\n        const state = states();\n        const items = (state.store[ns] || []) as Dialogic.Item<T>[];\n        const spawn =\n          identityOptions !== undefined ? identityOptions.spawn : undefined;\n        const id =\n          identityOptions !== undefined ? identityOptions.id : undefined;\n        const itemsBySpawn =\n          spawn !== undefined\n            ? items.filter(fitem => fitem.identityOptions.spawn === spawn)\n            : items;\n        const itemsById =\n          id !== undefined\n            ? itemsBySpawn.filter(item => item.identityOptions.id === id)\n            : itemsBySpawn;\n        return itemsById;\n      },\n\n      getCount: (ns: string, identityOptions?: Dialogic.IdentityOptions) =>\n        fns.getAll(ns, identityOptions).length,\n    };\n\n    return fns;\n  },\n};\n\nconst update: Stream<PatchFn> = Stream<PatchFn>();\n\nexport const states: Dialogic.States = Stream.scan(\n  (state: Dialogic.State, patch: PatchFn) => patch(state),\n  {\n    ...store.initialState,\n  },\n  update,\n);\n\nexport const actions = {\n  ...store.actions(update),\n};\n\nexport const selectors = {\n  ...store.selectors(states),\n};\n\n// states.map(state =>\n//   console.log(JSON.stringify(state, null, 2))\n// );\n","/* eslint-disable no-param-reassign */\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport Stream from 'mithril-stream-standalone';\n\ntype TimerCallback = () => unknown;\ntype TOnFinishFn = () => void;\n\ntype TimerState = {\n  timerId?: number;\n  startTime?: number;\n  remaining: number | undefined;\n  isPaused: boolean;\n  callback: TimerCallback;\n  timeoutFn: () => void;\n  promise?: Promise<unknown>;\n  onDone: TOnFinishFn;\n  onAbort: TOnFinishFn;\n};\n\ntype PatchFn = (state: TimerState) => TimerState;\n\nconst initialState: TimerState = {\n  callback: () => {},\n  isPaused: false,\n  onAbort: () => {},\n  onDone: () => {},\n  promise: undefined,\n  remaining: undefined,\n  startTime: undefined,\n  timeoutFn: () => {},\n  timerId: undefined,\n};\n\nconst appendStartTimer = (\n  state: TimerState,\n  callback: TimerCallback,\n  duration: number,\n  updateState: () => unknown,\n) => {\n  const timeoutFn = () => {\n    callback();\n    state.onDone();\n    updateState();\n  };\n  return {\n    timeoutFn,\n    promise: new Promise<void>(resolve => {\n      state.onDone = () => resolve();\n      state.onAbort = () => resolve();\n    }),\n    ...(state.isPaused\n      ? {}\n      : {\n          startTime: new Date().getTime(),\n          timerId: window.setTimeout(timeoutFn, duration),\n          remaining: duration,\n        }),\n  };\n};\n\nconst appendStopTimeout = (state: TimerState) => {\n  window.clearTimeout(state.timerId);\n  return {\n    timerId: initialState.timerId,\n  };\n};\n\nconst appendStopTimer = (state: TimerState) => ({\n  ...appendStopTimeout(state),\n});\n\nconst appendPauseTimer = (state: TimerState) => ({\n  ...appendStopTimeout(state),\n  isPaused: true,\n  remaining: getRemaining(state),\n});\n\nconst appendResumeTimer = (state: TimerState, minimumDuration?: number) => {\n  window.clearTimeout(state.timerId);\n  const remaining = minimumDuration\n    ? Math.max(state.remaining || 0, minimumDuration)\n    : state.remaining;\n  return {\n    startTime: new Date().getTime(),\n    isPaused: false,\n    remaining,\n    timerId: window.setTimeout(state.timeoutFn, remaining),\n  };\n};\n\nconst getRemaining = (state: TimerState) =>\n  state.remaining === 0 || state.remaining === undefined\n    ? state.remaining\n    : state.remaining - (new Date().getTime() - (state.startTime || 0));\n\nexport const TimerStore = () => {\n  const timer = {\n    initialState,\n    actions: (update: Stream<PatchFn>) => ({\n      /**\n       * Starts the timer\n       * @param {callback} Function Callback function that is called after completion.\n       * @param {duration} Number Timer duration in milliseconds.\n       */\n      start: (callback: TimerCallback, duration: number) => {\n        update((state: TimerState) => ({\n          ...state,\n          ...appendStopTimeout(state),\n          ...appendStartTimer(state, callback, duration, () =>\n            timer.actions(update).done(),\n          ),\n          ...(state.isPaused && appendPauseTimer(state)),\n        }));\n      },\n\n      /**\n       * Stops the timer.\n       */\n      stop: () => {\n        update((state: TimerState) => ({\n          ...state,\n          ...appendStopTimer(state),\n          ...initialState,\n        }));\n      },\n\n      /**\n       * Pauses a running timer.\n       */\n      pause: () => {\n        update((state: TimerState) => ({\n          ...state,\n          ...(!state.isPaused && appendPauseTimer(state)),\n        }));\n      },\n\n      /**\n       * Resumes a paused timer.\n       * @param {minimumDuration} Number Sets the minimum duration.\n       */\n      resume: (minimumDuration?: number) => {\n        update((state: TimerState) => ({\n          ...state,\n          ...(state.isPaused && appendResumeTimer(state, minimumDuration)),\n        }));\n      },\n\n      /**\n       * Aborts and clears a timer.\n       */\n      abort: () => {\n        update((state: TimerState) => {\n          state.onAbort();\n          return {\n            ...state,\n            ...appendStopTimeout(state),\n          };\n        });\n      },\n\n      /**\n       * Updates the current state. Used to get the state for selectors.getRemaining.\n       */\n      refresh: () => {\n        update((state: TimerState) => ({\n          ...state,\n        }));\n      },\n\n      /**\n       * Brings the timer to its initial state.\n       * Used internally.\n       */\n      done: () => {\n        update(() => initialState);\n      },\n    }),\n\n    selectors: (states: Stream<TimerState>) => ({\n      /**\n       * Returns the paused state.\n       */\n      isPaused: () => {\n        const state = states();\n        return state.isPaused;\n      },\n\n      /**\n       * Returns the remaining duration in milliseconds.\n       */\n      getRemaining: () => {\n        const state = states();\n        return state.isPaused ? state.remaining : getRemaining(state);\n      },\n\n      /**\n       * The promise that is handled when the timer is done or canceled.\n       */\n      getResultPromise: () => {\n        const state = states();\n        return state.promise;\n      },\n    }),\n  };\n\n  const update: Stream<PatchFn> = Stream<PatchFn>();\n\n  const states = Stream.scan(\n    (state: TimerState, patch: PatchFn) => patch(state),\n    {\n      ...timer.initialState,\n    },\n    update,\n  );\n\n  const actions = {\n    ...timer.actions(update),\n  };\n\n  const selectors = {\n    ...timer.selectors(states),\n  };\n\n  // states.map(state =>\n  //   console.log(JSON.stringify(state, null, 2))\n  // );\n\n  return {\n    states,\n    actions,\n    selectors,\n  };\n};\n\nexport type Timer = ReturnType<typeof TimerStore>;\n","export const isClient = typeof document !== 'undefined';\nexport const isServer = !isClient;\n\nexport const getStyleValue = ({\n  domElement,\n  prop,\n}: {\n  domElement: HTMLElement;\n  prop: string;\n}) => {\n  const { defaultView } = document;\n  if (defaultView) {\n    const style = defaultView.getComputedStyle(domElement);\n    if (style) {\n      return style.getPropertyValue(prop);\n    }\n  }\n  return undefined;\n};\n","import { getStyleValue } from './utils';\n\nexport const MODE = {\n  SHOW: 'show',\n  HIDE: 'hide',\n};\n\nexport type TransitionStylesFn = (domElement: HTMLElement) => TransitionStyles;\n\nexport type TransitionStyles = {\n  default?: Partial<CSSStyleDeclaration>;\n  showStart?: Partial<CSSStyleDeclaration>;\n  showEnd?: Partial<CSSStyleDeclaration>;\n  hideStart?: Partial<CSSStyleDeclaration>;\n  hideEnd?: Partial<CSSStyleDeclaration>;\n};\n\ntype TransitionProps = {\n  domElement?: HTMLElement;\n  className?: string;\n  styles?: TransitionStyles | TransitionStylesFn;\n  __transitionTimeoutId__?: number;\n};\n\ntype TransitionClassNames = {\n  [key: string]: string[];\n  showStart: string[];\n  showEnd: string[];\n  hideStart: string[];\n  hideEnd: string[];\n};\n\ntype TransitionStep = 'showStart' | 'showEnd' | 'hideStart' | 'hideEnd';\ntype TransitionStyleState = 'default' | TransitionStep;\n\ntype KeyValue = { [key: string]: string };\n\nconst removeTransitionClassNames = (\n  domElement: HTMLElement,\n  transitionClassNames: TransitionClassNames,\n) =>\n  domElement.classList.remove(\n    ...transitionClassNames.showStart,\n    ...transitionClassNames.showEnd,\n    ...transitionClassNames.hideStart,\n    ...transitionClassNames.hideEnd,\n  );\n\nconst applyTransitionStyles = (\n  domElement: HTMLElement,\n  step: TransitionStyleState,\n  styles: TransitionStyles,\n) => {\n  const transitionStyle = styles[step] as CSSStyleDeclaration;\n  if (transitionStyle) {\n    Object.keys(transitionStyle).forEach((key: string) => {\n      // Workaround for error \"getPropertyValue is not a function\"\n      const value = (transitionStyle as unknown as KeyValue)[key];\n      // eslint-disable-next-line no-param-reassign\n      (domElement.style as unknown as KeyValue)[key] = value;\n    });\n  }\n};\n\nconst applyNoDurationTransitionStyle = (domElement: HTMLElement) => {\n  // eslint-disable-next-line no-param-reassign\n  domElement.style.transitionDuration = '0ms';\n};\n\nconst getTransitionStyles = (\n  domElement: HTMLElement,\n  styles: TransitionStyles | TransitionStylesFn,\n) => (typeof styles === 'function' ? styles(domElement) : styles) || {};\n\nconst createClassList = (className: string, step: string) =>\n  className.split(/ /).map((n: string) => `${n}-${step}`);\n\nconst applyStylesForState = (\n  domElement: HTMLElement,\n  props: TransitionProps,\n  step: TransitionStep,\n  isEnterStep?: boolean,\n) => {\n  if (props.styles) {\n    const styles = getTransitionStyles(domElement, props.styles);\n    applyTransitionStyles(domElement, 'default', styles);\n    if (isEnterStep) {\n      applyNoDurationTransitionStyle(domElement);\n    }\n    applyTransitionStyles(domElement, step, styles);\n  }\n\n  if (props.className) {\n    const transitionClassNames: TransitionClassNames = {\n      showStart: createClassList(props.className, 'show-start'),\n      showEnd: createClassList(props.className, 'show-end'),\n      hideStart: createClassList(props.className, 'hide-start'),\n      hideEnd: createClassList(props.className, 'hide-end'),\n    };\n    removeTransitionClassNames(domElement, transitionClassNames);\n    if (transitionClassNames) {\n      domElement.classList.add(...transitionClassNames[step]);\n    }\n  }\n\n  // reflow\n  // eslint-disable-next-line no-unused-expressions\n  domElement.scrollTop;\n};\n\nconst styleDurationToMs = (durationStr: string) => {\n  const parsed =\n    parseFloat(durationStr) * (durationStr.indexOf('ms') === -1 ? 1000 : 1);\n  return Number.isNaN(parsed) ? 0 : parsed;\n};\n\nconst getDuration = (domElement: HTMLElement) => {\n  const durationStyleValue = getStyleValue({\n    domElement,\n    prop: 'transition-duration',\n  });\n  const durationValue =\n    durationStyleValue !== undefined\n      ? styleDurationToMs(durationStyleValue)\n      : 0;\n  const delayStyleValue = getStyleValue({\n    domElement,\n    prop: 'transition-delay',\n  });\n  const delayValue =\n    delayStyleValue !== undefined ? styleDurationToMs(delayStyleValue) : 0;\n  return durationValue + delayValue;\n};\n\ntype Step = {\n  nextStep?: TransitionStep;\n};\n\ntype Steps = {\n  showStart: Step;\n  showEnd: Step;\n  hideStart: Step;\n  hideEnd: Step;\n};\n\nconst steps: Steps = {\n  showStart: {\n    nextStep: 'showEnd',\n  },\n  showEnd: {\n    nextStep: undefined,\n  },\n  hideStart: {\n    nextStep: 'hideEnd',\n  },\n  hideEnd: {\n    nextStep: undefined,\n  },\n};\n\nexport const transition = (props: TransitionProps, mode?: string) => {\n  const { domElement } = props;\n  if (!domElement) {\n    return Promise.resolve('no domElement');\n  }\n  clearTimeout(props.__transitionTimeoutId__);\n\n  let currentStep: TransitionStep =\n    mode === MODE.SHOW ? 'showStart' : 'hideStart';\n\n  return new Promise(resolve => {\n    applyStylesForState(\n      domElement,\n      props,\n      currentStep,\n      currentStep === 'showStart',\n    );\n\n    setTimeout(() => {\n      const { nextStep } = steps[currentStep];\n      if (nextStep) {\n        currentStep = nextStep;\n        applyStylesForState(domElement, props, currentStep);\n        // addEventListener sometimes hangs this function because it never finishes\n        // Using setTimeout instead of addEventListener gives more consistent results\n        const duration = getDuration(domElement);\n        // eslint-disable-next-line no-param-reassign\n        props.__transitionTimeoutId__ = window.setTimeout(resolve, duration);\n      }\n    }, 0);\n  });\n};\n","/* eslint-disable no-plusplus */\nimport { Dialogic } from './index';\nimport { actions, createId, selectors } from './state/store';\nimport { Timer, TimerStore } from './state/timer';\nimport { MODE, transition } from './transition';\n\nexport { actions, selectors, states } from './state/store';\n\nconst localState = {\n  uid: 0,\n};\n\nconst getUid = () => {\n  if (localState.uid === Number.MAX_VALUE) {\n    localState.uid = 0;\n  } else {\n    localState.uid += 1;\n  }\n  return localState.uid;\n};\n\nenum TransitionStates {\n  Default,\n  Displaying,\n  Hiding,\n}\n\nconst getMaybeItem =\n  <T = unknown>(ns: string) =>\n  (defaultDialogicOptions: Dialogic.DefaultDialogicOptions) =>\n  (identityOptions?: Dialogic.IdentityOptions) =>\n    selectors.find<T>(\n      ns,\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      getMergedIdentityOptions(defaultDialogicOptions, identityOptions),\n    );\n\nconst filterBySpawn =\n  <T = unknown>(identityOptions: Dialogic.IdentityOptions) =>\n  (items: Dialogic.Item<T>[]) =>\n    identityOptions.spawn !== undefined\n      ? items.filter(\n          item => item.identityOptions.spawn === identityOptions.spawn,\n        )\n      : items;\n\nconst filterById =\n  <T = unknown>(identityOptions: Dialogic.IdentityOptions) =>\n  (items: Dialogic.Item<T>[]) =>\n    identityOptions.id !== undefined\n      ? items.filter(item => item.identityOptions.id === identityOptions.id)\n      : items;\n\n/**\n * Gets a list of all non-queued items.\n * From the queued items only the first item is listed.\n * */\nconst filterFirstInQueue = <T = unknown>(nsItems: Dialogic.Item<T>[]) => {\n  let queuedCount = 0;\n  return nsItems\n    .map(item => ({\n      item,\n      queueCount: item.dialogicOptions.queued ? queuedCount++ : 0,\n    }))\n    .filter(({ queueCount }) => queueCount === 0)\n    .map(({ item }) => item);\n};\n\nexport const filterCandidates = (\n  ns: string,\n  items: Dialogic.NamespaceStore,\n  identityOptions: Dialogic.IdentityOptions,\n): Dialogic.Item[] => {\n  const nsItems = (items[ns] || []) as Dialogic.Item[];\n  if (nsItems.length === 0) {\n    return [];\n  }\n  const filteredBySpawn = filterBySpawn(identityOptions)(nsItems);\n  return filterFirstInQueue(filteredBySpawn);\n};\n\ntype TGetPassThroughOptions = <T = unknown>(options: Dialogic.Options<T>) => T;\n\nconst getPassThroughOptions: TGetPassThroughOptions = options => {\n  const copy = {\n    ...options,\n  };\n  delete copy.dialogic;\n  return copy;\n};\n\nconst getMergedIdentityOptions = (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  identityOptions: Dialogic.IdentityOptions = {},\n) =>\n  ({\n    id: identityOptions.id || defaultDialogicOptions.id,\n    spawn: identityOptions.spawn || defaultDialogicOptions.spawn,\n  } as Dialogic.IdentityOptions);\n\nconst handleOptions = <T = unknown>(\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  options?: Dialogic.Options<T>,\n) => {\n  const identityOptions = {\n    id: options?.dialogic ? options.dialogic.id : undefined,\n    spawn: options?.dialogic ? options.dialogic.spawn : undefined,\n  };\n  const mergedIdentityOptions = getMergedIdentityOptions(\n    defaultDialogicOptions || ({} as Dialogic.DefaultDialogicOptions),\n    identityOptions,\n  );\n\n  const dialogicOptions: Dialogic.DialogicOptions<T> = {\n    ...defaultDialogicOptions,\n    ...options?.dialogic,\n    __transitionTimeoutId__: 0,\n  };\n\n  const passThroughOptions = options\n    ? getPassThroughOptions(options)\n    : ({} as Dialogic.Options<T>);\n\n  return {\n    identityOptions: mergedIdentityOptions,\n    dialogicOptions,\n    passThroughOptions,\n  };\n};\n\nconst createInstance =\n  (ns: string) =>\n  (defaultDialogicOptions: Dialogic.DefaultDialogicOptions) =>\n  <T = unknown>(options?: Dialogic.Options<T>) => {\n    const { identityOptions, dialogicOptions, passThroughOptions } =\n      handleOptions(defaultDialogicOptions, options);\n\n    // eslint-disable-next-line consistent-return\n    return new Promise<Dialogic.Item<T>>(resolve => {\n      const callbacks: Dialogic.Callbacks<T> = {\n        willShow: (item: Dialogic.Item<T>) => {\n          if (dialogicOptions.willShow) {\n            dialogicOptions.willShow(item);\n          }\n          return resolve(item);\n        },\n        willHide: (item: Dialogic.Item<T>) => {\n          if (dialogicOptions.willHide) {\n            dialogicOptions.willHide(item);\n          }\n          return resolve(item);\n        },\n        didShow: (item: Dialogic.Item<T>) => {\n          if (dialogicOptions.didShow) {\n            dialogicOptions.didShow(item);\n          }\n          return resolve(item);\n        },\n        didHide: (item: Dialogic.Item<T>) => {\n          if (dialogicOptions.didHide) {\n            dialogicOptions.didHide(item);\n          }\n          return resolve(item);\n        },\n      };\n\n      const item: Dialogic.Item<T> = {\n        ns,\n        identityOptions,\n        dialogicOptions,\n        callbacks,\n        passThroughOptions,\n        id: createId(identityOptions, ns),\n        timer: dialogicOptions.timeout ? TimerStore() : undefined, // when timeout is undefined or 0\n        key: getUid().toString(), // Uniquely identify each item for keyed display\n        transitionState: TransitionStates.Default,\n      };\n\n      const maybeExistingItem: Dialogic.MaybeItem<T> = selectors.find<T>(\n        ns,\n        identityOptions,\n      );\n\n      const existingItem = maybeExistingItem.just;\n\n      if (existingItem && dialogicOptions.toggle) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        hide(ns)(defaultDialogicOptions)<T>(options);\n        resolve(existingItem);\n        return;\n      }\n\n      if (existingItem && !dialogicOptions.queued) {\n        const replacingItem = {\n          ...item,\n          key: existingItem.key,\n          transitionState: existingItem.transitionState,\n          dialogicOptions: existingItem.dialogicOptions, // Preserve dialogicOptions\n        };\n        actions.replace(ns, existingItem.id, replacingItem as Dialogic.Item<T>);\n      } else {\n        actions.add<T>(ns, item);\n        // This will instantiate and draw the instance\n        // The instance will call `showDialog` in `onMount`\n      }\n\n      resolve(item);\n    });\n  };\n\nexport const show = createInstance;\n\nexport const hide =\n  (ns: string) =>\n  (defaultDialogicOptions: Dialogic.DefaultDialogicOptions) =>\n  <T = unknown>(options?: Dialogic.Options<T>) => {\n    const { identityOptions, dialogicOptions, passThroughOptions } =\n      handleOptions(defaultDialogicOptions, options);\n    const maybeExistingItem: Dialogic.MaybeItem<T> = selectors.find<T>(\n      ns,\n      identityOptions,\n    );\n    const existingItem = maybeExistingItem.just;\n    if (existingItem) {\n      const item: Dialogic.Item<T> = {\n        ...existingItem,\n        dialogicOptions: {\n          ...existingItem.dialogicOptions,\n          ...dialogicOptions,\n        },\n        passThroughOptions: {\n          ...existingItem.passThroughOptions,\n          passThroughOptions,\n        },\n      };\n      actions.replace<T>(ns, existingItem.id, item);\n      if (item.transitionState !== TransitionStates.Hiding) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return hideItem<T>(item);\n      }\n      return Promise.resolve(item);\n    }\n    return Promise.resolve({\n      ns,\n      id: identityOptions.id,\n    } as Dialogic.Item<T>);\n  };\n\nexport const pause =\n  (ns: string) =>\n  (\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  ) =>\n  <T = unknown>(identityOptions?: Dialogic.IdentityOptions) => {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const validItems = getValidItems<T>(ns, identityOptions).filter(\n      item => !!item.timer,\n    );\n    validItems.forEach((item: Dialogic.Item<T>) => {\n      if (item.timer) {\n        item.timer.actions.pause();\n      }\n    });\n    return Promise.all(validItems);\n  };\n\nexport const resume =\n  (ns: string) =>\n  (\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  ) =>\n  <T = unknown>(commandOptions?: Dialogic.CommandOptions) => {\n    const options = commandOptions || {};\n    const identityOptions = {\n      id: options.id,\n      spawn: options.spawn,\n    };\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const validItems = getValidItems<T>(ns, identityOptions).filter(\n      item => !!item.timer,\n    );\n    validItems.forEach((item: Dialogic.Item<T>) => {\n      if (item.timer) {\n        item.timer.actions.resume(options.minimumDuration);\n      }\n    });\n    return Promise.all(validItems);\n  };\n\nconst getTimerSelectors = <T = unknown>(\n  ns: string,\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  identityOptions?: Dialogic.IdentityOptions,\n) => {\n  const maybeItem: Dialogic.MaybeItem<T> = getMaybeItem<T>(ns)(\n    defaultDialogicOptions,\n  )(identityOptions);\n  return maybeItem?.just?.timer?.selectors;\n};\n\nexport const isPaused =\n  (ns: string) =>\n  (defaultDialogicOptions: Dialogic.DefaultDialogicOptions) =>\n  (identityOptions?: Dialogic.IdentityOptions) =>\n    getTimerSelectors(\n      ns,\n      defaultDialogicOptions,\n      identityOptions,\n    )?.isPaused() || false;\n\nexport const getRemaining =\n  (ns: string) =>\n  (defaultDialogicOptions: Dialogic.DefaultDialogicOptions) =>\n  (identityOptions?: Dialogic.IdentityOptions) =>\n    getTimerSelectors(\n      ns,\n      defaultDialogicOptions,\n      identityOptions,\n    )?.getRemaining() || undefined;\n\nexport const exists =\n  (ns: string) =>\n  (\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  ) =>\n  (identityOptions?: Dialogic.IdentityOptions) =>\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    !!getValidItems(ns, identityOptions).length;\n\nconst getValidItems = <T = unknown>(\n  ns: string,\n  identityOptions?: Dialogic.IdentityOptions,\n) => {\n  const allItems = selectors.getAll<T>(ns);\n  let validItems: Dialogic.Item<T>[];\n  if (identityOptions) {\n    const filteredBySpawn = filterBySpawn<T>(identityOptions)(allItems);\n    validItems = filterById<T>(identityOptions)(filteredBySpawn);\n  } else {\n    validItems = allItems;\n  }\n  return validItems;\n};\n\nexport const resetAll =\n  (ns: string) =>\n  (\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  ) =>\n  (identityOptions?: Dialogic.IdentityOptions) => {\n    const validItems = getValidItems(ns, identityOptions);\n    const items: Dialogic.Item[] = [];\n\n    validItems.forEach((item: Dialogic.Item) => {\n      if (item.timer) {\n        item.timer.actions.abort();\n      }\n      items.push(item);\n    });\n\n    if (identityOptions) {\n      items.forEach((item: Dialogic.Item) => {\n        actions.remove(ns, item.id);\n      });\n    } else {\n      actions.removeAll(ns);\n    }\n\n    return Promise.resolve(items);\n  };\n\nconst getOverridingTransitionOptions = <T = unknown>(\n  item: Dialogic.Item<T>,\n  dialogicOptions: Dialogic.DialogicOptions<T>,\n) => ({\n  ...item,\n  dialogicOptions: {\n    ...item.dialogicOptions,\n    ...dialogicOptions,\n  },\n});\n\n/**\n * Triggers a `hideItem` for each item in the store.\n * Queued items: will trigger `hideItem` only for the first item, then reset the store.\n * Optional `dialogicOptions` may be passed with specific transition options. This comes in handy when all items should hide in the same way.\n */\nexport const hideAll =\n  (ns: string) =>\n  (\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  ) =>\n  <T = unknown>(dialogicOptions?: Dialogic.DialogicOptions<T>) => {\n    const options = dialogicOptions || {};\n    const identityOptions: Dialogic.IdentityOptions = {\n      id: options.id,\n      spawn: options.spawn,\n    };\n    const validItems = getValidItems<T>(ns, identityOptions);\n    const regularItems = validItems.filter(\n      (item: Dialogic.Item<T>) =>\n        !options.queued && !item.dialogicOptions.queued,\n    );\n    const queuedItems = validItems.filter(\n      (item: Dialogic.Item<T>) => options.queued || item.dialogicOptions.queued,\n    );\n\n    const items = [];\n\n    regularItems.forEach((item: Dialogic.Item<T>) =>\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      items.push(hideItem(getOverridingTransitionOptions<T>(item, options))),\n    );\n\n    if (queuedItems.length > 0) {\n      const [current] = queuedItems;\n      // Make sure that any remaining items don't suddenly appear\n      actions.store(ns, [current]);\n      // Transition the current item\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      items.push(hideItem(getOverridingTransitionOptions<T>(current, options)));\n    }\n\n    return Promise.all(items);\n  };\n\nexport const getCount =\n  (ns: string) => (identityOptions?: Dialogic.IdentityOptions) =>\n    selectors.getCount(ns, identityOptions);\n\nconst transitionItem = <T = unknown>(item: Dialogic.Item<T>, mode: string) =>\n  transition(item.dialogicOptions, mode);\n\nconst getResultPromise =\n  <T = unknown>() =>\n  (ns: string) =>\n  (defaultDialogicOptions: Dialogic.DefaultDialogicOptions) =>\n  (identityOptions?: Dialogic.IdentityOptions) => {\n    const maybeItem: Dialogic.MaybeItem<T> = getMaybeItem<T>(ns)(\n      defaultDialogicOptions,\n    )(identityOptions);\n    if (maybeItem.just) {\n      if (maybeItem.just && maybeItem.just.timer) {\n        return maybeItem.just.timer.selectors.getResultPromise();\n      }\n      return undefined;\n    }\n    return undefined;\n  };\n\nconst deferredHideItem = async <T = unknown>(\n  item: Dialogic.Item<T>,\n  timer: Timer,\n  timeout: number,\n) => {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  timer.actions.start(() => hideItem(item), timeout);\n  return getResultPromise<T>();\n};\n\nexport const showItem: Dialogic.InitiateItemTransitionFn = async <T = unknown>(\n  item: Dialogic.Item<T>,\n) => {\n  if (item.callbacks.willShow) {\n    item.callbacks.willShow(item);\n  }\n  if (item.transitionState !== TransitionStates.Displaying) {\n    // eslint-disable-next-line no-param-reassign\n    item.transitionState = TransitionStates.Displaying;\n    await transitionItem(item, MODE.SHOW);\n  }\n  if (item.callbacks.didShow) {\n    item.callbacks.didShow(item);\n  }\n  if (item.dialogicOptions.timeout && item.timer) {\n    await deferredHideItem(item, item.timer, item.dialogicOptions.timeout);\n  }\n  return Promise.resolve(item);\n};\n\n/**\n * Hides an item. Any timer will be stopped. Any callbacks will be called.\n * @returns A Promise with (a copy of) the data of the removed item.\n */\nexport const hideItem = async <T = unknown>(\n  item: Dialogic.Item<T>,\n): Promise<Dialogic.Item<T>> => {\n  // eslint-disable-next-line no-param-reassign\n  item.transitionState = TransitionStates.Hiding;\n  // Stop any running timer\n  if (item.timer) {\n    item.timer.actions.stop();\n  }\n  if (item.callbacks.willHide) {\n    item.callbacks.willHide(item);\n  }\n  await transitionItem(item, MODE.HIDE);\n  if (item.callbacks.didHide) {\n    item.callbacks.didHide(item);\n  }\n  const copy = {\n    ...item,\n  };\n  actions.remove(item.ns, item.id);\n  return Promise.resolve(copy);\n};\n\nexport const setDomElement = <T = unknown>(\n  domElement: HTMLElement,\n  item: Dialogic.Item<T>,\n) => {\n  // eslint-disable-next-line no-param-reassign\n  item.dialogicOptions.domElement = domElement;\n};\n","import {\n  exists,\n  getCount,\n  getRemaining,\n  hide,\n  hideAll,\n  isPaused,\n  pause,\n  resetAll,\n  resume,\n  show,\n} from './dialogic';\nimport { Dialogic } from './index';\n\nexport const dialogical = ({\n  ns,\n  queued,\n  timeout,\n}: {\n  ns: string;\n  queued?: boolean;\n  timeout?: number;\n}) => {\n  const defaultId = `default_${ns}`;\n  const defaultSpawn = `default_${ns}`;\n  const defaultDialogicOptions: Dialogic.DefaultDialogicOptions = {\n    id: defaultId,\n    spawn: defaultSpawn,\n    ...(queued && { queued }),\n    ...(timeout !== undefined && { timeout }),\n  };\n\n  return {\n    // Identification\n    ns,\n    defaultId,\n    defaultSpawn,\n    // Configuration\n    defaultDialogicOptions,\n    // Commands\n    show: show(ns)(defaultDialogicOptions),\n    hide: hide(ns)(defaultDialogicOptions),\n    hideAll: hideAll(ns)(defaultDialogicOptions),\n    resetAll: resetAll(ns)(defaultDialogicOptions),\n    // Timer commands\n    pause: pause(ns)(defaultDialogicOptions),\n    resume: resume(ns)(defaultDialogicOptions),\n    // State\n    exists: exists(ns)(defaultDialogicOptions),\n    getCount: getCount(ns),\n    // Timer state\n    isPaused: isPaused(ns)(defaultDialogicOptions),\n    getRemaining: getRemaining(ns)(defaultDialogicOptions),\n  };\n};\n","import { dialogical } from './dialogical';\n\nexport const dialog = dialogical({ ns: 'dialog' });\n","import { dialogical } from './dialogical';\n\nexport const notification = dialogical({\n  ns: 'notification',\n  queued: true,\n  timeout: 3000,\n});\n","/**\n * Utility script that uses an animation frame to pass the current remaining value\n * (which is utilized when setting `timeout`).\n */\n\nimport { DialogicInstance } from './types';\n\ntype RemainingProps = {\n  /**\n   * Dialogic instance: notification, dialog, or custom.\n   */\n  instance: DialogicInstance;\n\n  id?: string;\n  spawn?: string;\n\n  /**\n   * Set to true to return seconds instead of milliseconds.\n   */\n  roundToSeconds?: boolean;\n\n  /**\n   * Returns the remaining time as milliseconds. Returns `undefined` when the timer is not running (before and after the timer runs).\n   */\n  callback: (displayValue: number | undefined) => unknown;\n};\n\nexport const remaining = (props: RemainingProps) => {\n  let displayValue: number | undefined;\n  let reqId: number;\n  let isCanceled: boolean = false;\n  const identity = {\n    id: props.id,\n    spawn: props.spawn,\n  };\n\n  const update = () => {\n    const remainingValue = props.instance.getRemaining(identity);\n    if (displayValue !== remainingValue) {\n      displayValue =\n        remainingValue === undefined\n          ? remainingValue\n          : props.roundToSeconds\n          ? Math.round(Math.max(remainingValue, 0) / 1000)\n          : Math.max(remainingValue, 0);\n    }\n    props.callback(displayValue);\n    if (!props.instance.exists(identity)) {\n      window.cancelAnimationFrame(reqId);\n      isCanceled = true;\n    } else if (!isCanceled) {\n      reqId = window.requestAnimationFrame(update);\n    }\n  };\n  reqId = window.requestAnimationFrame(update);\n};\n"],"names":["update","remaining","states","getRemaining","actions","selectors","item"],"mappings":";;;AAMA,MAAM,WAAW,CAAc,IAAY,UACzC,MAAM,KAAK,CAAA,SAAQ,KAAK,OAAO,EAAE;AAEnC,MAAM,YAAY,CAAc,IAAY,UAA8B;AAClE,QAAA,OAAO,SAAY,IAAI,KAAK;AAClC,SAAO,OAAO,MAAM,QAAQ,IAAI,IAAI;AACtC;AAEA,MAAM,aAAa,CAAc,IAAY,UAA8B;AACnE,QAAA,QAAQ,UAAa,IAAI,KAAK;AACpC,MAAI,UAAU,IAAI;AACV,UAAA,OAAO,OAAO,CAAC;AAAA,EACvB;AACO,SAAA;AACT;AAEO,MAAM,WAAW,CACtB,iBACA,OACG,CAAC,IAAI,gBAAgB,IAAI,gBAAgB,KAAK,EAAE,OAAO,OAAO,EAAE,KAAK,GAAG;AAE7E,MAAM,QAAQ;AAAA,EACZ,cAAc;AAAA,IACZ,OAAO,CAAC;AAAA,EACV;AAAA,EAEA,SAAS,CAACA,aAA6B;AAAA;AAAA;AAAA;AAAA,IAIrC,KAAK,CAA8B,IAAY,SAA2B;AACxEA,cAAO,CAAC,UAA0B;AAChC,cAAM,QAAQ,MAAM,MAAM,EAAE,KAAK,CAAA;AACjC,cAAM,MAAM,EAAE,IAAI,CAAC,GAAG,OAAO,IAA8B;AAC3D,YAAI,KAAK,OAAO;AAET,eAAA,MAAM,OAAO,IAAI,MAAM,MAAM,QAAQA,OAAM,EAAE,QAAA,CAAS;AAAA,QAC7D;AACO,eAAA;AAAA,MAAA,CACR;AAAA,IACH;AAAA;AAAA;AAAA;AAAA,IAKA,QAAQ,CAAC,IAAY,OAAe;AAClCA,cAAO,CAAC,UAA0B;AAChC,cAAM,QAAQ,MAAM,MAAM,EAAE,KAAK,CAAA;AAC3B,cAAAC,aAAY,WAAW,IAAI,KAAK;AAChC,cAAA,MAAM,EAAE,IAAIA;AACX,eAAA;AAAA,MAAA,CACR;AAAA,IACH;AAAA;AAAA;AAAA;AAAA,IAKA,SAAS,CACP,IACA,IACA,YACG;AACHD,cAAO,CAAC,UAA0B;AAChC,cAAM,QAAQ,MAAM,MAAM,EAAE,KAAK,CAAA;AACjC,YAAI,OAAO;AACH,gBAAA,QAAQ,UAAU,IAAI,KAAK;AACjC,cAAI,UAAU,IAAI;AAChB,kBAAM,KAAK,IAAI;AACf,kBAAM,MAAM,EAAE,IAAI,CAAC,GAAG,KAAK;AAAA,UAC7B;AAAA,QACF;AACO,eAAA;AAAA,MAAA,CACR;AAAA,IACH;AAAA;AAAA;AAAA;AAAA,IAKA,WAAW,CAAC,OAAe;AACzBA,cAAO,CAAC,UAA0B;AAC1B,cAAA,MAAM,EAAE,IAAI;AACX,eAAA;AAAA,MAAA,CACR;AAAA,IACH;AAAA;AAAA;AAAA;AAAA,IAKA,OAAO,CAAc,IAAY,aAAiC;AAChEA,cAAO,CAAC,UAA0B;AAChC,cAAM,MAAM,EAAE,IAAI,CAAC,GAAI,QAA4B;AAC5C,eAAA;AAAA,MAAA,CACR;AAAA,IACH;AAAA,IAEA,SAAS,MAAM;AACbA,cAAO,CAAC,WAA2B;AAAA,QACjC,GAAG;AAAA,MACH,EAAA;AAAA,IACJ;AAAA,EAAA;AAAA,EAGF,WAAW,CAACE,YAAmC;AAC7C,UAAM,MAAM;AAAA,MACV,UAAU,MAAM;AACd,cAAM,QAAQA;AACd,eAAO,MAAM;AAAA,MACf;AAAA,MAEA,MAAM,CACJ,IACA,oBACG;AACH,cAAM,QAAQA;AACd,cAAM,QAAQ,MAAM,MAAM,EAAE,KAAK,CAAA;AAC3B,cAAA,KAAK,SAAS,iBAAiB,EAAE;AACvC,cAAM,OAAO,MAAM,KAAK,CAAS,UAAA,MAAM,OAAO,EAAE;AAChD,eAAO,OAAO,EAAE,MAAM,KAAS,IAAA,EAAE,SAAS;MAC5C;AAAA,MAEA,QAAQ,CACN,IACA,oBACG;AACH,cAAM,QAAQA;AACd,cAAM,QAAS,MAAM,MAAM,EAAE,KAAK,CAAA;AAClC,cAAM,QACJ,oBAAoB,SAAY,gBAAgB,QAAQ;AAC1D,cAAM,KACJ,oBAAoB,SAAY,gBAAgB,KAAK;AACjD,cAAA,eACJ,UAAU,SACN,MAAM,OAAO,WAAS,MAAM,gBAAgB,UAAU,KAAK,IAC3D;AACA,cAAA,YACJ,OAAO,SACH,aAAa,OAAO,UAAQ,KAAK,gBAAgB,OAAO,EAAE,IAC1D;AACC,eAAA;AAAA,MACT;AAAA,MAEA,UAAU,CAAC,IAAY,oBACrB,IAAI,OAAO,IAAI,eAAe,EAAE;AAAA,IAAA;AAG7B,WAAA;AAAA,EACT;AACF;AAEA,MAAM,SAA0B,OAAgB;AAEzC,MAAM,SAA0B,OAAO;AAAA,EAC5C,CAAC,OAAuB,UAAmB,MAAM,KAAK;AAAA,EACtD;AAAA,IACE,GAAG,MAAM;AAAA,EACX;AAAA,EACA;AACF;AAEO,MAAM,UAAU;AAAA,EACrB,GAAG,MAAM,QAAQ,MAAM;AACzB;AAEO,MAAM,YAAY;AAAA,EACvB,GAAG,MAAM,UAAU,MAAM;AAC3B;ACtJA,MAAM,eAA2B;AAAA,EAC/B,UAAU,MAAM;AAAA,EAAC;AAAA,EACjB,UAAU;AAAA,EACV,SAAS,MAAM;AAAA,EAAC;AAAA,EAChB,QAAQ,MAAM;AAAA,EAAC;AAAA,EACf,SAAS;AAAA,EACT,WAAW;AAAA,EACX,WAAW;AAAA,EACX,WAAW,MAAM;AAAA,EAAC;AAAA,EAClB,SAAS;AACX;AAEA,MAAM,mBAAmB,CACvB,OACA,UACA,UACA,gBACG;AACH,QAAM,YAAY,MAAM;AACb;AACT,UAAM,OAAO;AACD;EAAA;AAEP,SAAA;AAAA,IACL;AAAA,IACA,SAAS,IAAI,QAAc,CAAW,YAAA;AAC9B,YAAA,SAAS,MAAM;AACf,YAAA,UAAU,MAAM;IAAQ,CAC/B;AAAA,IACD,GAAI,MAAM,WACN,KACA;AAAA,MACE,WAAW,IAAI,KAAK,EAAE,QAAQ;AAAA,MAC9B,SAAS,OAAO,WAAW,WAAW,QAAQ;AAAA,MAC9C,WAAW;AAAA,IACb;AAAA,EAAA;AAER;AAEA,MAAM,oBAAoB,CAAC,UAAsB;AACxC,SAAA,aAAa,MAAM,OAAO;AAC1B,SAAA;AAAA,IACL,SAAS,aAAa;AAAA,EAAA;AAE1B;AAEA,MAAM,kBAAkB,CAAC,WAAuB;AAAA,EAC9C,GAAG,kBAAkB,KAAK;AAC5B;AAEA,MAAM,mBAAmB,CAAC,WAAuB;AAAA,EAC/C,GAAG,kBAAkB,KAAK;AAAA,EAC1B,UAAU;AAAA,EACV,WAAWC,eAAa,KAAK;AAC/B;AAEA,MAAM,oBAAoB,CAAC,OAAmB,oBAA6B;AAClE,SAAA,aAAa,MAAM,OAAO;AAC3B,QAAAF,aAAY,kBACd,KAAK,IAAI,MAAM,aAAa,GAAG,eAAe,IAC9C,MAAM;AACH,SAAA;AAAA,IACL,WAAW,IAAI,KAAK,EAAE,QAAQ;AAAA,IAC9B,UAAU;AAAA,IACV,WAAAA;AAAA,IACA,SAAS,OAAO,WAAW,MAAM,WAAWA,UAAS;AAAA,EAAA;AAEzD;AAEA,MAAME,iBAAe,CAAC,UACpB,MAAM,cAAc,KAAK,MAAM,cAAc,SACzC,MAAM,YACN,MAAM,aAAa,IAAI,OAAO,QAAQ,KAAK,MAAM,aAAa;AAE7D,MAAM,aAAa,MAAM;AAC9B,QAAM,QAAQ;AAAA,IACZ;AAAA,IACA,SAAS,CAACH,cAA6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMrC,OAAO,CAAC,UAAyB,aAAqB;AACpDA,QAAAA,SAAO,CAAC,WAAuB;AAAA,UAC7B,GAAG;AAAA,UACH,GAAG,kBAAkB,KAAK;AAAA,UAC1B,GAAG;AAAA,YAAiB;AAAA,YAAO;AAAA,YAAU;AAAA,YAAU,MAC7C,MAAM,QAAQA,QAAM,EAAE,KAAK;AAAA,UAC7B;AAAA,UACA,GAAI,MAAM,YAAY,iBAAiB,KAAK;AAAA,QAC5C,EAAA;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA,MAKA,MAAM,MAAM;AACVA,QAAAA,SAAO,CAAC,WAAuB;AAAA,UAC7B,GAAG;AAAA,UACH,GAAG,gBAAgB,KAAK;AAAA,UACxB,GAAG;AAAA,QACH,EAAA;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA,MAKA,OAAO,MAAM;AACXA,QAAAA,SAAO,CAAC,WAAuB;AAAA,UAC7B,GAAG;AAAA,UACH,GAAI,CAAC,MAAM,YAAY,iBAAiB,KAAK;AAAA,QAC7C,EAAA;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,QAAQ,CAAC,oBAA6B;AACpCA,QAAAA,SAAO,CAAC,WAAuB;AAAA,UAC7B,GAAG;AAAA,UACH,GAAI,MAAM,YAAY,kBAAkB,OAAO,eAAe;AAAA,QAC9D,EAAA;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA,MAKA,OAAO,MAAM;AACXA,QAAAA,SAAO,CAAC,UAAsB;AAC5B,gBAAM,QAAQ;AACP,iBAAA;AAAA,YACL,GAAG;AAAA,YACH,GAAG,kBAAkB,KAAK;AAAA,UAAA;AAAA,QAC5B,CACD;AAAA,MACH;AAAA;AAAA;AAAA;AAAA,MAKA,SAAS,MAAM;AACbA,QAAAA,SAAO,CAAC,WAAuB;AAAA,UAC7B,GAAG;AAAA,QACH,EAAA;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,MAAM,MAAM;AACVA,QAAAA,SAAO,MAAM,YAAY;AAAA,MAC3B;AAAA,IAAA;AAAA,IAGF,WAAW,CAACE,cAAgC;AAAA;AAAA;AAAA;AAAA,MAI1C,UAAU,MAAM;AACd,cAAM,QAAQA;AACd,eAAO,MAAM;AAAA,MACf;AAAA;AAAA;AAAA;AAAA,MAKA,cAAc,MAAM;AAClB,cAAM,QAAQA;AACd,eAAO,MAAM,WAAW,MAAM,YAAYC,eAAa,KAAK;AAAA,MAC9D;AAAA;AAAA;AAAA;AAAA,MAKA,kBAAkB,MAAM;AACtB,cAAM,QAAQD;AACd,eAAO,MAAM;AAAA,MACf;AAAA,IAAA;AAAA,EACF;AAGF,QAAMF,UAA0B;AAEhC,QAAME,UAAS,OAAO;AAAA,IACpB,CAAC,OAAmB,UAAmB,MAAM,KAAK;AAAA,IAClD;AAAA,MACE,GAAG,MAAM;AAAA,IACX;AAAA,IACAF;AAAA,EAAA;AAGF,QAAMI,WAAU;AAAA,IACd,GAAG,MAAM,QAAQJ,OAAM;AAAA,EAAA;AAGzB,QAAMK,aAAY;AAAA,IAChB,GAAG,MAAM,UAAUH,OAAM;AAAA,EAAA;AAOpB,SAAA;AAAA,IACL,QAAAA;AAAA,IACA,SAAAE;AAAA,IACA,WAAAC;AAAA,EAAA;AAEJ;ACrOO,MAAM,gBAAgB,CAAC;AAAA,EAC5B;AAAA,EACA;AACF,MAGM;AACE,QAAA,EAAE,YAAgB,IAAA;AACxB,MAAI,aAAa;AACT,UAAA,QAAQ,YAAY,iBAAiB,UAAU;AACrD,QAAI,OAAO;AACF,aAAA,MAAM,iBAAiB,IAAI;AAAA,IACpC;AAAA,EACF;AACO,SAAA;AACT;AChBO,MAAM,OAAO;AAAA,EAClB,MAAM;AAAA,EACN,MAAM;AACR;AAgCA,MAAM,6BAA6B,CACjC,YACA,yBAEA,WAAW,UAAU;AAAA,EACnB,GAAG,qBAAqB;AAAA,EACxB,GAAG,qBAAqB;AAAA,EACxB,GAAG,qBAAqB;AAAA,EACxB,GAAG,qBAAqB;AAC1B;AAEF,MAAM,wBAAwB,CAC5B,YACA,MACA,WACG;AACG,QAAA,kBAAkB,OAAO,IAAI;AACnC,MAAI,iBAAiB;AACnB,WAAO,KAAK,eAAe,EAAE,QAAQ,CAAC,QAAgB;AAE9C,YAAA,QAAS,gBAAwC,GAAG;AAEzD,iBAAW,MAA8B,GAAG,IAAI;AAAA,IAAA,CAClD;AAAA,EACH;AACF;AAEA,MAAM,iCAAiC,CAAC,eAA4B;AAElE,aAAW,MAAM,qBAAqB;AACxC;AAEA,MAAM,sBAAsB,CAC1B,YACA,YACI,OAAO,WAAW,aAAa,OAAO,UAAU,IAAI,WAAW,CAAA;AAErE,MAAM,kBAAkB,CAAC,WAAmB,SAC1C,UAAU,MAAM,GAAG,EAAE,IAAI,CAAC,MAAc,GAAG,KAAK,MAAM;AAExD,MAAM,sBAAsB,CAC1B,YACA,OACA,MACA,gBACG;AACH,MAAI,MAAM,QAAQ;AAChB,UAAM,SAAS,oBAAoB,YAAY,MAAM,MAAM;AACrC,0BAAA,YAAY,WAAW,MAAM;AACnD,QAAI,aAAa;AACf,qCAA+B,UAAU;AAAA,IAC3C;AACsB,0BAAA,YAAY,MAAM,MAAM;AAAA,EAChD;AAEA,MAAI,MAAM,WAAW;AACnB,UAAM,uBAA6C;AAAA,MACjD,WAAW,gBAAgB,MAAM,WAAW,YAAY;AAAA,MACxD,SAAS,gBAAgB,MAAM,WAAW,UAAU;AAAA,MACpD,WAAW,gBAAgB,MAAM,WAAW,YAAY;AAAA,MACxD,SAAS,gBAAgB,MAAM,WAAW,UAAU;AAAA,IAAA;AAEtD,+BAA2B,YAAY,oBAAoB;AAC3D,QAAI,sBAAsB;AACxB,iBAAW,UAAU,IAAI,GAAG,qBAAqB,IAAI,CAAC;AAAA,IACxD;AAAA,EACF;AAIW,aAAA;AACb;AAEA,MAAM,oBAAoB,CAAC,gBAAwB;AAC3C,QAAA,SACJ,WAAW,WAAW,KAAK,YAAY,QAAQ,IAAI,MAAM,KAAK,MAAO;AACvE,SAAO,OAAO,MAAM,MAAM,IAAI,IAAI;AACpC;AAEA,MAAM,cAAc,CAAC,eAA4B;AAC/C,QAAM,qBAAqB,cAAc;AAAA,IACvC;AAAA,IACA,MAAM;AAAA,EAAA,CACP;AACD,QAAM,gBACJ,uBAAuB,SACnB,kBAAkB,kBAAkB,IACpC;AACN,QAAM,kBAAkB,cAAc;AAAA,IACpC;AAAA,IACA,MAAM;AAAA,EAAA,CACP;AACD,QAAM,aACJ,oBAAoB,SAAY,kBAAkB,eAAe,IAAI;AACvE,SAAO,gBAAgB;AACzB;AAaA,MAAM,QAAe;AAAA,EACnB,WAAW;AAAA,IACT,UAAU;AAAA,EACZ;AAAA,EACA,SAAS;AAAA,IACP,UAAU;AAAA,EACZ;AAAA,EACA,WAAW;AAAA,IACT,UAAU;AAAA,EACZ;AAAA,EACA,SAAS;AAAA,IACP,UAAU;AAAA,EACZ;AACF;AAEa,MAAA,aAAa,CAAC,OAAwB,SAAkB;AAC7D,QAAA,EAAE,WAAe,IAAA;AACvB,MAAI,CAAC,YAAY;AACR,WAAA,QAAQ,QAAQ,eAAe;AAAA,EACxC;AACA,eAAa,MAAM,uBAAuB;AAE1C,MAAI,cACF,SAAS,KAAK,OAAO,cAAc;AAE9B,SAAA,IAAI,QAAQ,CAAW,YAAA;AAC5B;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA,gBAAgB;AAAA,IAAA;AAGlB,eAAW,MAAM;AACf,YAAM,EAAE,SAAA,IAAa,MAAM,WAAW;AACtC,UAAI,UAAU;AACE,sBAAA;AACM,4BAAA,YAAY,OAAO,WAAW;AAG5C,cAAA,WAAW,YAAY,UAAU;AAEvC,cAAM,0BAA0B,OAAO,WAAW,SAAS,QAAQ;AAAA,MACrE;AAAA,OACC,CAAC;AAAA,EAAA,CACL;AACH;ACvLA,MAAM,aAAa;AAAA,EACjB,KAAK;AACP;AAEA,MAAM,SAAS,MAAM;AACf,MAAA,WAAW,QAAQ,OAAO,WAAW;AACvC,eAAW,MAAM;AAAA,EAAA,OACZ;AACL,eAAW,OAAO;AAAA,EACpB;AACA,SAAO,WAAW;AACpB;AAQA,MAAM,eACJ,CAAc,OACd,CAAC,2BACD,CAAC,oBACC,UAAU;AAAA,EACR;AAAA;AAAA,EAEA,yBAAyB,wBAAwB,eAAe;AAClE;AAEJ,MAAM,gBACJ,CAAc,oBACd,CAAC,UACC,gBAAgB,UAAU,SACtB,MAAM;AAAA,EACJ,CAAQ,SAAA,KAAK,gBAAgB,UAAU,gBAAgB;AACzD,IACA;AAER,MAAM,aACJ,CAAc,oBACd,CAAC,UACC,gBAAgB,OAAO,SACnB,MAAM,OAAO,UAAQ,KAAK,gBAAgB,OAAO,gBAAgB,EAAE,IACnE;AAMR,MAAM,qBAAqB,CAAc,YAAgC;AACvE,MAAI,cAAc;AACX,SAAA,QACJ,IAAI,CAAS,UAAA;AAAA,IACZ;AAAA,IACA,YAAY,KAAK,gBAAgB,SAAS,gBAAgB;AAAA,EAC1D,EAAA,EACD,OAAO,CAAC,EAAE,WAAW,MAAM,eAAe,CAAC,EAC3C,IAAI,CAAC,EAAE,WAAW,IAAI;AAC3B;AAEO,MAAM,mBAAmB,CAC9B,IACA,OACA,oBACoB;AACpB,QAAM,UAAW,MAAM,EAAE,KAAK,CAAA;AAC1B,MAAA,QAAQ,WAAW,GAAG;AACxB,WAAO;EACT;AACA,QAAM,kBAAkB,cAAc,eAAe,EAAE,OAAO;AAC9D,SAAO,mBAAmB,eAAe;AAC3C;AAIA,MAAM,wBAAgD,CAAW,YAAA;AAC/D,QAAM,OAAO;AAAA,IACX,GAAG;AAAA,EAAA;AAEL,SAAO,KAAK;AACL,SAAA;AACT;AAEA,MAAM,2BAA2B,CAC/B,wBACA,kBAA4C,QAE3C;AAAA,EACC,IAAI,gBAAgB,MAAM,uBAAuB;AAAA,EACjD,OAAO,gBAAgB,SAAS,uBAAuB;AACzD;AAEF,MAAM,gBAAgB,CACpB,wBACA,YACG;AACH,QAAM,kBAAkB;AAAA,IACtB,KAAI,mCAAS,YAAW,QAAQ,SAAS,KAAK;AAAA,IAC9C,QAAO,mCAAS,YAAW,QAAQ,SAAS,QAAQ;AAAA,EAAA;AAEtD,QAAM,wBAAwB;AAAA,IAC5B,0BAA2B,CAAC;AAAA,IAC5B;AAAA,EAAA;AAGF,QAAM,kBAA+C;AAAA,IACnD,GAAG;AAAA,IACH,GAAG,mCAAS;AAAA,IACZ,yBAAyB;AAAA,EAAA;AAG3B,QAAM,qBAAqB,UACvB,sBAAsB,OAAO,IAC5B,CAAA;AAEE,SAAA;AAAA,IACL,iBAAiB;AAAA,IACjB;AAAA,IACA;AAAA,EAAA;AAEJ;AAEA,MAAM,iBACJ,CAAC,OACD,CAAC,2BACD,CAAc,YAAkC;AAC9C,QAAM,EAAE,iBAAiB,iBAAiB,mBACxC,IAAA,cAAc,wBAAwB,OAAO;AAGxC,SAAA,IAAI,QAA0B,CAAW,YAAA;AAC9C,UAAM,YAAmC;AAAA,MACvC,UAAU,CAACC,UAA2B;AACpC,YAAI,gBAAgB,UAAU;AAC5B,0BAAgB,SAASA,KAAI;AAAA,QAC/B;AACA,eAAO,QAAQA,KAAI;AAAA,MACrB;AAAA,MACA,UAAU,CAACA,UAA2B;AACpC,YAAI,gBAAgB,UAAU;AAC5B,0BAAgB,SAASA,KAAI;AAAA,QAC/B;AACA,eAAO,QAAQA,KAAI;AAAA,MACrB;AAAA,MACA,SAAS,CAACA,UAA2B;AACnC,YAAI,gBAAgB,SAAS;AAC3B,0BAAgB,QAAQA,KAAI;AAAA,QAC9B;AACA,eAAO,QAAQA,KAAI;AAAA,MACrB;AAAA,MACA,SAAS,CAACA,UAA2B;AACnC,YAAI,gBAAgB,SAAS;AAC3B,0BAAgB,QAAQA,KAAI;AAAA,QAC9B;AACA,eAAO,QAAQA,KAAI;AAAA,MACrB;AAAA,IAAA;AAGF,UAAM,OAAyB;AAAA,MAC7B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,IAAI,SAAS,iBAAiB,EAAE;AAAA,MAChC,OAAO,gBAAgB,UAAU,WAAA,IAAe;AAAA;AAAA,MAChD,KAAK,OAAO,EAAE,SAAS;AAAA;AAAA,MACvB,iBAAiB;AAAA;AAAA,IAAA;AAGnB,UAAM,oBAA2C,UAAU;AAAA,MACzD;AAAA,MACA;AAAA,IAAA;AAGF,UAAM,eAAe,kBAAkB;AAEnC,QAAA,gBAAgB,gBAAgB,QAAQ;AAE1C,WAAK,EAAE,EAAE,sBAAsB,EAAK,OAAO;AAC3C,cAAQ,YAAY;AACpB;AAAA,IACF;AAEI,QAAA,gBAAgB,CAAC,gBAAgB,QAAQ;AAC3C,YAAM,gBAAgB;AAAA,QACpB,GAAG;AAAA,QACH,KAAK,aAAa;AAAA,QAClB,iBAAiB,aAAa;AAAA,QAC9B,iBAAiB,aAAa;AAAA;AAAA,MAAA;AAEhC,cAAQ,QAAQ,IAAI,aAAa,IAAI,aAAiC;AAAA,IAAA,OACjE;AACG,cAAA,IAAO,IAAI,IAAI;AAAA,IAGzB;AAEA,YAAQ,IAAI;AAAA,EAAA,CACb;AACH;AAEK,MAAM,OAAO;AAEb,MAAM,OACX,CAAC,OACD,CAAC,2BACD,CAAc,YAAkC;AAC9C,QAAM,EAAE,iBAAiB,iBAAiB,mBACxC,IAAA,cAAc,wBAAwB,OAAO;AAC/C,QAAM,oBAA2C,UAAU;AAAA,IACzD;AAAA,IACA;AAAA,EAAA;AAEF,QAAM,eAAe,kBAAkB;AACvC,MAAI,cAAc;AAChB,UAAM,OAAyB;AAAA,MAC7B,GAAG;AAAA,MACH,iBAAiB;AAAA,QACf,GAAG,aAAa;AAAA,QAChB,GAAG;AAAA,MACL;AAAA,MACA,oBAAoB;AAAA,QAClB,GAAG,aAAa;AAAA,QAChB;AAAA,MACF;AAAA,IAAA;AAEF,YAAQ,QAAW,IAAI,aAAa,IAAI,IAAI;AACxC,QAAA,KAAK,oBAAoB,GAAyB;AAEpD,aAAO,SAAY,IAAI;AAAA,IACzB;AACO,WAAA,QAAQ,QAAQ,IAAI;AAAA,EAC7B;AACA,SAAO,QAAQ,QAAQ;AAAA,IACrB;AAAA,IACA,IAAI,gBAAgB;AAAA,EAAA,CACD;AACvB;AAEK,MAAM,QACX,CAAC,OACD,CAEE,4BAEF,CAAc,oBAA+C;AAE3D,QAAM,aAAa,cAAiB,IAAI,eAAe,EAAE;AAAA,IACvD,CAAA,SAAQ,CAAC,CAAC,KAAK;AAAA,EAAA;AAEN,aAAA,QAAQ,CAAC,SAA2B;AAC7C,QAAI,KAAK,OAAO;AACT,WAAA,MAAM,QAAQ;IACrB;AAAA,EAAA,CACD;AACM,SAAA,QAAQ,IAAI,UAAU;AAC/B;AAEK,MAAM,SACX,CAAC,OACD,CAEE,4BAEF,CAAc,mBAA6C;AACnD,QAAA,UAAU,kBAAkB;AAClC,QAAM,kBAAkB;AAAA,IACtB,IAAI,QAAQ;AAAA,IACZ,OAAO,QAAQ;AAAA,EAAA;AAGjB,QAAM,aAAa,cAAiB,IAAI,eAAe,EAAE;AAAA,IACvD,CAAA,SAAQ,CAAC,CAAC,KAAK;AAAA,EAAA;AAEN,aAAA,QAAQ,CAAC,SAA2B;AAC7C,QAAI,KAAK,OAAO;AACd,WAAK,MAAM,QAAQ,OAAO,QAAQ,eAAe;AAAA,IACnD;AAAA,EAAA,CACD;AACM,SAAA,QAAQ,IAAI,UAAU;AAC/B;AAEF,MAAM,oBAAoB,CACxB,IACA,wBACA,oBACG;;AACG,QAAA,YAAmC,aAAgB,EAAE;AAAA,IACzD;AAAA,IACA,eAAe;AACV,UAAA,kDAAW,SAAX,mBAAiB,UAAjB,mBAAwB;AACjC;AAEO,MAAM,WACX,CAAC,OACD,CAAC,2BACD,CAAC,oBACC;;AAAA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAJA,mBAIG,eAAc;AAAA;AAEd,MAAM,eACX,CAAC,OACD,CAAC,2BACD,CAAC,oBACC;;AAAA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAJA,mBAIG,mBAAkB;AAAA;AAElB,MAAM,SACX,CAAC,OACD,CAEE,4BAEF,CAAC;AAAA;AAAA,EAEC,CAAC,CAAC,cAAc,IAAI,eAAe,EAAE;AAAA;AAEzC,MAAM,gBAAgB,CACpB,IACA,oBACG;AACG,QAAA,WAAW,UAAU,OAAU,EAAE;AACnC,MAAA;AACJ,MAAI,iBAAiB;AACnB,UAAM,kBAAkB,cAAiB,eAAe,EAAE,QAAQ;AACrD,iBAAA,WAAc,eAAe,EAAE,eAAe;AAAA,EAAA,OACtD;AACQ,iBAAA;AAAA,EACf;AACO,SAAA;AACT;AAEO,MAAM,WACX,CAAC,OACD,CAEE,4BAEF,CAAC,oBAA+C;AACxC,QAAA,aAAa,cAAc,IAAI,eAAe;AACpD,QAAM,QAAyB,CAAA;AAEpB,aAAA,QAAQ,CAAC,SAAwB;AAC1C,QAAI,KAAK,OAAO;AACT,WAAA,MAAM,QAAQ;IACrB;AACA,UAAM,KAAK,IAAI;AAAA,EAAA,CAChB;AAED,MAAI,iBAAiB;AACb,UAAA,QAAQ,CAAC,SAAwB;AAC7B,cAAA,OAAO,IAAI,KAAK,EAAE;AAAA,IAAA,CAC3B;AAAA,EAAA,OACI;AACL,YAAQ,UAAU,EAAE;AAAA,EACtB;AAEO,SAAA,QAAQ,QAAQ,KAAK;AAC9B;AAEF,MAAM,iCAAiC,CACrC,MACA,qBACI;AAAA,EACJ,GAAG;AAAA,EACH,iBAAiB;AAAA,IACf,GAAG,KAAK;AAAA,IACR,GAAG;AAAA,EACL;AACF;AAOO,MAAM,UACX,CAAC,OACD,CAEE,4BAEF,CAAc,oBAAkD;AACxD,QAAA,UAAU,mBAAmB;AACnC,QAAM,kBAA4C;AAAA,IAChD,IAAI,QAAQ;AAAA,IACZ,OAAO,QAAQ;AAAA,EAAA;AAEX,QAAA,aAAa,cAAiB,IAAI,eAAe;AACvD,QAAM,eAAe,WAAW;AAAA,IAC9B,CAAC,SACC,CAAC,QAAQ,UAAU,CAAC,KAAK,gBAAgB;AAAA,EAAA;AAE7C,QAAM,cAAc,WAAW;AAAA,IAC7B,CAAC,SAA2B,QAAQ,UAAU,KAAK,gBAAgB;AAAA,EAAA;AAGrE,QAAM,QAAQ,CAAA;AAED,eAAA;AAAA,IAAQ,CAAC;AAAA;AAAA,MAEpB,MAAM,KAAK,SAAS,+BAAkC,MAAM,OAAO,CAAC,CAAC;AAAA;AAAA,EAAA;AAGnE,MAAA,YAAY,SAAS,GAAG;AACpB,UAAA,CAAC,OAAO,IAAI;AAElB,YAAQ,MAAM,IAAI,CAAC,OAAO,CAAC;AAG3B,UAAM,KAAK,SAAS,+BAAkC,SAAS,OAAO,CAAC,CAAC;AAAA,EAC1E;AAEO,SAAA,QAAQ,IAAI,KAAK;AAC1B;AAEW,MAAA,WACX,CAAC,OAAe,CAAC,oBACf,UAAU,SAAS,IAAI,eAAe;AAE1C,MAAM,iBAAiB,CAAc,MAAwB,SAC3D,WAAW,KAAK,iBAAiB,IAAI;AAEvC,MAAM,mBACJ,MACA,CAAC,OACD,CAAC,2BACD,CAAC,oBAA+C;AACxC,QAAA,YAAmC,aAAgB,EAAE;AAAA,IACzD;AAAA,IACA,eAAe;AACjB,MAAI,UAAU,MAAM;AAClB,QAAI,UAAU,QAAQ,UAAU,KAAK,OAAO;AAC1C,aAAO,UAAU,KAAK,MAAM,UAAU,iBAAiB;AAAA,IACzD;AACO,WAAA;AAAA,EACT;AACO,SAAA;AACT;AAEF,MAAM,mBAAmB,OACvB,MACA,OACA,YACG;AAEH,QAAM,QAAQ,MAAM,MAAM,SAAS,IAAI,GAAG,OAAO;AACjD,SAAO,iBAAoB;AAC7B;AAEa,MAAA,WAA8C,OACzD,SACG;AACC,MAAA,KAAK,UAAU,UAAU;AACtB,SAAA,UAAU,SAAS,IAAI;AAAA,EAC9B;AACI,MAAA,KAAK,oBAAoB,GAA6B;AAExD,SAAK,kBAAkB;AACjB,UAAA,eAAe,MAAM,KAAK,IAAI;AAAA,EACtC;AACI,MAAA,KAAK,UAAU,SAAS;AACrB,SAAA,UAAU,QAAQ,IAAI;AAAA,EAC7B;AACA,MAAI,KAAK,gBAAgB,WAAW,KAAK,OAAO;AAC9C,UAAM,iBAAiB,MAAM,KAAK,OAAO,KAAK,gBAAgB,OAAO;AAAA,EACvE;AACO,SAAA,QAAQ,QAAQ,IAAI;AAC7B;AAMa,MAAA,WAAW,OACtB,SAC8B;AAE9B,OAAK,kBAAkB;AAEvB,MAAI,KAAK,OAAO;AACT,SAAA,MAAM,QAAQ;EACrB;AACI,MAAA,KAAK,UAAU,UAAU;AACtB,SAAA,UAAU,SAAS,IAAI;AAAA,EAC9B;AACM,QAAA,eAAe,MAAM,KAAK,IAAI;AAChC,MAAA,KAAK,UAAU,SAAS;AACrB,SAAA,UAAU,QAAQ,IAAI;AAAA,EAC7B;AACA,QAAM,OAAO;AAAA,IACX,GAAG;AAAA,EAAA;AAEL,UAAQ,OAAO,KAAK,IAAI,KAAK,EAAE;AACxB,SAAA,QAAQ,QAAQ,IAAI;AAC7B;AAEa,MAAA,gBAAgB,CAC3B,YACA,SACG;AAEH,OAAK,gBAAgB,aAAa;AACpC;ACxfO,MAAM,aAAa,CAAC;AAAA,EACzB;AAAA,EACA;AAAA,EACA;AACF,MAIM;AACJ,QAAM,YAAY,WAAW;AAC7B,QAAM,eAAe,WAAW;AAChC,QAAM,yBAA0D;AAAA,IAC9D,IAAI;AAAA,IACJ,OAAO;AAAA,IACP,GAAI,UAAU,EAAE,OAAO;AAAA,IACvB,GAAI,YAAY,UAAa,EAAE,QAAQ;AAAA,EAAA;AAGlC,SAAA;AAAA;AAAA,IAEL;AAAA,IACA;AAAA,IACA;AAAA;AAAA,IAEA;AAAA;AAAA,IAEA,MAAM,KAAK,EAAE,EAAE,sBAAsB;AAAA,IACrC,MAAM,KAAK,EAAE,EAAE,sBAAsB;AAAA,IACrC,SAAS,QAAQ,EAAE,EAAE,sBAAsB;AAAA,IAC3C,UAAU,SAAS,EAAE,EAAE,sBAAsB;AAAA;AAAA,IAE7C,OAAO,MAAM,EAAE,EAAE,sBAAsB;AAAA,IACvC,QAAQ,OAAO,EAAE,EAAE,sBAAsB;AAAA;AAAA,IAEzC,QAAQ,OAAO,EAAE,EAAE,sBAAsB;AAAA,IACzC,UAAU,SAAS,EAAE;AAAA;AAAA,IAErB,UAAU,SAAS,EAAE,EAAE,sBAAsB;AAAA,IAC7C,cAAc,aAAa,EAAE,EAAE,sBAAsB;AAAA,EAAA;AAEzD;ACpDO,MAAM,SAAS,WAAW,EAAE,IAAI,SAAU,CAAA;ACA1C,MAAM,eAAe,WAAW;AAAA,EACrC,IAAI;AAAA,EACJ,QAAQ;AAAA,EACR,SAAS;AACX,CAAC;ACqBY,MAAA,YAAY,CAAC,UAA0B;AAC9C,MAAA;AACA,MAAA;AACJ,MAAI,aAAsB;AAC1B,QAAM,WAAW;AAAA,IACf,IAAI,MAAM;AAAA,IACV,OAAO,MAAM;AAAA,EAAA;AAGf,QAAMN,UAAS,MAAM;AACnB,UAAM,iBAAiB,MAAM,SAAS,aAAa,QAAQ;AAC3D,QAAI,iBAAiB,gBAAgB;AACnC,qBACE,mBAAmB,SACf,iBACA,MAAM,iBACN,KAAK,MAAM,KAAK,IAAI,gBAAgB,CAAC,IAAI,GAAI,IAC7C,KAAK,IAAI,gBAAgB,CAAC;AAAA,IAClC;AACA,UAAM,SAAS,YAAY;AAC3B,QAAI,CAAC,MAAM,SAAS,OAAO,QAAQ,GAAG;AACpC,aAAO,qBAAqB,KAAK;AACpB,mBAAA;AAAA,IAAA,WACJ,CAAC,YAAY;AACd,cAAA,OAAO,sBAAsBA,OAAM;AAAA,IAC7C;AAAA,EAAA;AAEM,UAAA,OAAO,sBAAsBA,OAAM;AAC7C;;;;;;;;;;;;;;;;;;;;;;;;;;"}