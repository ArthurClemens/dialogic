{"version":3,"file":"dialogic.umd.js","sources":["../src/state/store.ts","../src/state/timer.ts","../src/utils.ts","../src/transition.ts","../src/dialogic.ts","../src/dialogical.ts","../src/dialog.ts","../src/notification.ts","../src/remaining.ts"],"sourcesContent":["import Stream from 'mithril-stream-standalone';\n\nimport { Dialogic } from '../index';\n\ntype PatchFn = (state: Dialogic.State) => Dialogic.State;\n\nconst findItem = <T = unknown>(id: string, items: Dialogic.Item<T>[]) =>\n  items.find(item => item.id === id);\n\nconst itemIndex = <T = unknown>(id: string, items: Dialogic.Item<T>[]) => {\n  const item = findItem<T>(id, items);\n  return item ? items.indexOf(item) : -1;\n};\n\nconst removeItem = <T = unknown>(id: string, items: Dialogic.Item<T>[]) => {\n  const index = itemIndex<T>(id, items);\n  if (index !== -1) {\n    items.splice(index, 1);\n  }\n  return items;\n};\n\nexport const createId = (\n  identityOptions: Dialogic.IdentityOptions,\n  ns: string,\n) => [ns, identityOptions.id, identityOptions.spawn].filter(Boolean).join('-');\n\nconst store = {\n  initialState: {\n    store: {},\n  },\n\n  actions: (update: Stream<PatchFn>) => ({\n    /**\n     * Add an item to the end of the list.\n     */\n    add: <T extends unknown = unknown>(ns: string, item: Dialogic.Item<T>) => {\n      update((state: Dialogic.State) => {\n        const items = state.store[ns] || [];\n        state.store[ns] = [...items, item as Dialogic.Item<unknown>];\n        if (item.timer) {\n          // When the timer state updates, refresh the store so that UI can pick up the change\n          item.timer.states.map(() => store.actions(update).refresh());\n        }\n        return state;\n      });\n    },\n\n    /**\n     * Removes the first item with a match on `id`.\n     */\n    remove: (ns: string, id: string) => {\n      update((state: Dialogic.State) => {\n        const items = state.store[ns] || [];\n        const remaining = removeItem(id, items);\n        state.store[ns] = remaining;\n        return state;\n      });\n    },\n\n    /**\n     * Replaces the first item with a match on `id` with a newItem.\n     */\n    replace: <T = unknown>(\n      ns: string,\n      id: string,\n      newItem: Dialogic.Item<T>,\n    ) => {\n      update((state: Dialogic.State) => {\n        const items = state.store[ns] || [];\n        if (items) {\n          const index = itemIndex(id, items);\n          if (index !== -1) {\n            items[index] = newItem as Dialogic.Item<unknown>;\n            state.store[ns] = [...items] as Dialogic.Item<unknown>[];\n          }\n        }\n        return state;\n      });\n    },\n\n    /**\n     * Removes all items within a namespace.\n     */\n    removeAll: (ns: string) => {\n      update((state: Dialogic.State) => {\n        state.store[ns] = [];\n        return state;\n      });\n    },\n\n    /**\n     * Replaces all items within a namespace.\n     */\n    store: <T = unknown>(ns: string, newItems: Dialogic.Item<T>[]) => {\n      update((state: Dialogic.State) => {\n        state.store[ns] = [...(newItems as Dialogic.Item[])];\n        return state;\n      });\n    },\n\n    refresh: () => {\n      update((state: Dialogic.State) => ({\n        ...state,\n      }));\n    },\n  }),\n\n  selectors: (states: Stream<Dialogic.State>) => {\n    const fns = {\n      getStore: () => {\n        const state = states();\n        return state.store;\n      },\n\n      find: <T = unknown>(\n        ns: string,\n        identityOptions: Dialogic.IdentityOptions,\n      ) => {\n        const state = states();\n        const items = state.store[ns] || [];\n        const id = createId(identityOptions, ns);\n        const item = items.find(fitem => fitem.id === id) as Dialogic.Item<T>;\n        return item ? { just: item } : { nothing: undefined };\n      },\n\n      getAll: <T = unknown>(\n        ns: string,\n        identityOptions?: Dialogic.IdentityOptions,\n      ) => {\n        const state = states();\n        const items = (state.store[ns] || []) as Dialogic.Item<T>[];\n        const spawn =\n          identityOptions !== undefined ? identityOptions.spawn : undefined;\n        const id =\n          identityOptions !== undefined ? identityOptions.id : undefined;\n        const itemsBySpawn =\n          spawn !== undefined\n            ? items.filter(fitem => fitem.identityOptions.spawn === spawn)\n            : items;\n        const itemsById =\n          id !== undefined\n            ? itemsBySpawn.filter(item => item.identityOptions.id === id)\n            : itemsBySpawn;\n        return itemsById;\n      },\n\n      getCount: (ns: string, identityOptions?: Dialogic.IdentityOptions) =>\n        fns.getAll(ns, identityOptions).length,\n    };\n\n    return fns;\n  },\n};\n\nconst update: Stream<PatchFn> = Stream<PatchFn>();\n\nexport const states: Dialogic.States = Stream.scan(\n  (state: Dialogic.State, patch: PatchFn) => patch(state),\n  {\n    ...store.initialState,\n  },\n  update,\n);\n\nexport const actions = {\n  ...store.actions(update),\n};\n\nexport const selectors = {\n  ...store.selectors(states),\n};\n\n// states.map(state =>\n//   console.log(JSON.stringify(state, null, 2))\n// );\n","/* eslint-disable no-param-reassign */\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport Stream from 'mithril-stream-standalone';\n\ntype TimerCallback = () => unknown;\ntype TOnFinishFn = () => void;\n\ntype TimerState = {\n  timerId?: number;\n  startTime?: number;\n  remaining: number | undefined;\n  isPaused: boolean;\n  callback: TimerCallback;\n  timeoutFn: () => void;\n  promise?: Promise<unknown>;\n  onDone: TOnFinishFn;\n  onAbort: TOnFinishFn;\n};\n\ntype PatchFn = (state: TimerState) => TimerState;\n\nconst initialState: TimerState = {\n  callback: () => {},\n  isPaused: false,\n  onAbort: () => {},\n  onDone: () => {},\n  promise: undefined,\n  remaining: undefined,\n  startTime: undefined,\n  timeoutFn: () => {},\n  timerId: undefined,\n};\n\nconst appendStartTimer = (\n  state: TimerState,\n  callback: TimerCallback,\n  duration: number,\n  updateState: () => unknown,\n) => {\n  const timeoutFn = () => {\n    callback();\n    state.onDone();\n    updateState();\n  };\n  return {\n    timeoutFn,\n    promise: new Promise<void>(resolve => {\n      state.onDone = () => resolve();\n      state.onAbort = () => resolve();\n    }),\n    ...(state.isPaused\n      ? {}\n      : {\n          startTime: new Date().getTime(),\n          timerId: window.setTimeout(timeoutFn, duration),\n          remaining: duration,\n        }),\n  };\n};\n\nconst appendStopTimeout = (state: TimerState) => {\n  window.clearTimeout(state.timerId);\n  return {\n    timerId: initialState.timerId,\n  };\n};\n\nconst appendStopTimer = (state: TimerState) => ({\n  ...appendStopTimeout(state),\n});\n\nconst appendPauseTimer = (state: TimerState) => ({\n  ...appendStopTimeout(state),\n  isPaused: true,\n  remaining: getRemaining(state),\n});\n\nconst appendResumeTimer = (state: TimerState, minimumDuration?: number) => {\n  window.clearTimeout(state.timerId);\n  const remaining = minimumDuration\n    ? Math.max(state.remaining || 0, minimumDuration)\n    : state.remaining;\n  return {\n    startTime: new Date().getTime(),\n    isPaused: false,\n    remaining,\n    timerId: window.setTimeout(state.timeoutFn, remaining),\n  };\n};\n\nconst getRemaining = (state: TimerState) =>\n  state.remaining === 0 || state.remaining === undefined\n    ? state.remaining\n    : state.remaining - (new Date().getTime() - (state.startTime || 0));\n\nexport const TimerStore = () => {\n  const timer = {\n    initialState,\n    actions: (update: Stream<PatchFn>) => ({\n      /**\n       * Starts the timer\n       * @param {callback} Function Callback function that is called after completion.\n       * @param {duration} Number Timer duration in milliseconds.\n       */\n      start: (callback: TimerCallback, duration: number) => {\n        update((state: TimerState) => ({\n          ...state,\n          ...appendStopTimeout(state),\n          ...appendStartTimer(state, callback, duration, () =>\n            timer.actions(update).done(),\n          ),\n          ...(state.isPaused && appendPauseTimer(state)),\n        }));\n      },\n\n      /**\n       * Stops the timer.\n       */\n      stop: () => {\n        update((state: TimerState) => ({\n          ...state,\n          ...appendStopTimer(state),\n          ...initialState,\n        }));\n      },\n\n      /**\n       * Pauses a running timer.\n       */\n      pause: () => {\n        update((state: TimerState) => ({\n          ...state,\n          ...(!state.isPaused && appendPauseTimer(state)),\n        }));\n      },\n\n      /**\n       * Resumes a paused timer.\n       * @param {minimumDuration} Number Sets the minimum duration.\n       */\n      resume: (minimumDuration?: number) => {\n        update((state: TimerState) => ({\n          ...state,\n          ...(state.isPaused && appendResumeTimer(state, minimumDuration)),\n        }));\n      },\n\n      /**\n       * Aborts and clears a timer.\n       */\n      abort: () => {\n        update((state: TimerState) => {\n          state.onAbort();\n          return {\n            ...state,\n            ...appendStopTimeout(state),\n          };\n        });\n      },\n\n      /**\n       * Updates the current state. Used to get the state for selectors.getRemaining.\n       */\n      refresh: () => {\n        update((state: TimerState) => ({\n          ...state,\n        }));\n      },\n\n      /**\n       * Brings the timer to its initial state.\n       * Used internally.\n       */\n      done: () => {\n        update(() => initialState);\n      },\n    }),\n\n    selectors: (states: Stream<TimerState>) => ({\n      /**\n       * Returns the paused state.\n       */\n      isPaused: () => {\n        const state = states();\n        return state.isPaused;\n      },\n\n      /**\n       * Returns the remaining duration in milliseconds.\n       */\n      getRemaining: () => {\n        const state = states();\n        return state.isPaused ? state.remaining : getRemaining(state);\n      },\n\n      /**\n       * The promise that is handled when the timer is done or canceled.\n       */\n      getResultPromise: () => {\n        const state = states();\n        return state.promise;\n      },\n    }),\n  };\n\n  const update: Stream<PatchFn> = Stream<PatchFn>();\n\n  const states = Stream.scan(\n    (state: TimerState, patch: PatchFn) => patch(state),\n    {\n      ...timer.initialState,\n    },\n    update,\n  );\n\n  const actions = {\n    ...timer.actions(update),\n  };\n\n  const selectors = {\n    ...timer.selectors(states),\n  };\n\n  // states.map(state =>\n  //   console.log(JSON.stringify(state, null, 2))\n  // );\n\n  return {\n    states,\n    actions,\n    selectors,\n  };\n};\n\nexport type Timer = ReturnType<typeof TimerStore>;\n","export const isClient = typeof document !== 'undefined';\nexport const isServer = !isClient;\n\nexport const getStyleValue = ({\n  domElement,\n  prop,\n}: {\n  domElement: HTMLElement;\n  prop: string;\n}) => {\n  const { defaultView } = document;\n  if (defaultView) {\n    const style = defaultView.getComputedStyle(domElement);\n    if (style) {\n      return style.getPropertyValue(prop);\n    }\n  }\n  return undefined;\n};\n","import { getStyleValue } from './utils';\n\nexport const MODE = {\n  SHOW: 'show',\n  HIDE: 'hide',\n};\n\nexport type TransitionStylesFn = (domElement: HTMLElement) => TransitionStyles;\n\nexport type TransitionStyles = {\n  default?: Partial<CSSStyleDeclaration>;\n  showStart?: Partial<CSSStyleDeclaration>;\n  showEnd?: Partial<CSSStyleDeclaration>;\n  hideStart?: Partial<CSSStyleDeclaration>;\n  hideEnd?: Partial<CSSStyleDeclaration>;\n};\n\ntype TransitionProps = {\n  domElement?: HTMLElement;\n  className?: string;\n  styles?: TransitionStyles | TransitionStylesFn;\n  __transitionTimeoutId__?: number;\n};\n\ntype TransitionClassNames = {\n  [key: string]: string[];\n  showStart: string[];\n  showEnd: string[];\n  hideStart: string[];\n  hideEnd: string[];\n};\n\ntype TransitionStep = 'showStart' | 'showEnd' | 'hideStart' | 'hideEnd';\ntype TransitionStyleState = 'default' | TransitionStep;\n\ntype KeyValue = { [key: string]: string };\n\nconst removeTransitionClassNames = (\n  domElement: HTMLElement,\n  transitionClassNames: TransitionClassNames,\n) =>\n  domElement.classList.remove(\n    ...transitionClassNames.showStart,\n    ...transitionClassNames.showEnd,\n    ...transitionClassNames.hideStart,\n    ...transitionClassNames.hideEnd,\n  );\n\nconst applyTransitionStyles = (\n  domElement: HTMLElement,\n  step: TransitionStyleState,\n  styles: TransitionStyles,\n) => {\n  const transitionStyle = styles[step] as CSSStyleDeclaration;\n  if (transitionStyle) {\n    Object.keys(transitionStyle).forEach((key: string) => {\n      // Workaround for error \"getPropertyValue is not a function\"\n      const value = (transitionStyle as unknown as KeyValue)[key];\n      // eslint-disable-next-line no-param-reassign\n      (domElement.style as unknown as KeyValue)[key] = value;\n    });\n  }\n};\n\nconst applyNoDurationTransitionStyle = (domElement: HTMLElement) => {\n  // eslint-disable-next-line no-param-reassign\n  domElement.style.transitionDuration = '0ms';\n};\n\nconst getTransitionStyles = (\n  domElement: HTMLElement,\n  styles: TransitionStyles | TransitionStylesFn,\n) => (typeof styles === 'function' ? styles(domElement) : styles) || {};\n\nconst createClassList = (className: string, step: string) =>\n  className.split(/ /).map((n: string) => `${n}-${step}`);\n\nconst applyStylesForState = (\n  domElement: HTMLElement,\n  props: TransitionProps,\n  step: TransitionStep,\n  isEnterStep?: boolean,\n) => {\n  if (props.styles) {\n    const styles = getTransitionStyles(domElement, props.styles);\n    applyTransitionStyles(domElement, 'default', styles);\n    if (isEnterStep) {\n      applyNoDurationTransitionStyle(domElement);\n    }\n    applyTransitionStyles(domElement, step, styles);\n  }\n\n  if (props.className) {\n    const transitionClassNames: TransitionClassNames = {\n      showStart: createClassList(props.className, 'show-start'),\n      showEnd: createClassList(props.className, 'show-end'),\n      hideStart: createClassList(props.className, 'hide-start'),\n      hideEnd: createClassList(props.className, 'hide-end'),\n    };\n    removeTransitionClassNames(domElement, transitionClassNames);\n    if (transitionClassNames) {\n      domElement.classList.add(...transitionClassNames[step]);\n    }\n  }\n\n  // reflow\n  // eslint-disable-next-line no-unused-expressions\n  domElement.scrollTop;\n};\n\nconst styleDurationToMs = (durationStr: string) => {\n  const parsed =\n    parseFloat(durationStr) * (durationStr.indexOf('ms') === -1 ? 1000 : 1);\n  return Number.isNaN(parsed) ? 0 : parsed;\n};\n\nconst getDuration = (domElement: HTMLElement) => {\n  const durationStyleValue = getStyleValue({\n    domElement,\n    prop: 'transition-duration',\n  });\n  const durationValue =\n    durationStyleValue !== undefined\n      ? styleDurationToMs(durationStyleValue)\n      : 0;\n  const delayStyleValue = getStyleValue({\n    domElement,\n    prop: 'transition-delay',\n  });\n  const delayValue =\n    delayStyleValue !== undefined ? styleDurationToMs(delayStyleValue) : 0;\n  return durationValue + delayValue;\n};\n\ntype Step = {\n  nextStep?: TransitionStep;\n};\n\ntype Steps = {\n  showStart: Step;\n  showEnd: Step;\n  hideStart: Step;\n  hideEnd: Step;\n};\n\nconst steps: Steps = {\n  showStart: {\n    nextStep: 'showEnd',\n  },\n  showEnd: {\n    nextStep: undefined,\n  },\n  hideStart: {\n    nextStep: 'hideEnd',\n  },\n  hideEnd: {\n    nextStep: undefined,\n  },\n};\n\nexport const transition = (props: TransitionProps, mode?: string) => {\n  const { domElement } = props;\n  if (!domElement) {\n    return Promise.resolve('no domElement');\n  }\n  clearTimeout(props.__transitionTimeoutId__);\n\n  let currentStep: TransitionStep =\n    mode === MODE.SHOW ? 'showStart' : 'hideStart';\n\n  return new Promise(resolve => {\n    applyStylesForState(\n      domElement,\n      props,\n      currentStep,\n      currentStep === 'showStart',\n    );\n\n    setTimeout(() => {\n      const { nextStep } = steps[currentStep];\n      if (nextStep) {\n        currentStep = nextStep;\n        applyStylesForState(domElement, props, currentStep);\n        // addEventListener sometimes hangs this function because it never finishes\n        // Using setTimeout instead of addEventListener gives more consistent results\n        const duration = getDuration(domElement);\n        // eslint-disable-next-line no-param-reassign\n        props.__transitionTimeoutId__ = window.setTimeout(resolve, duration);\n      }\n    }, 0);\n  });\n};\n","/* eslint-disable no-plusplus */\nimport { Dialogic } from './index';\nimport { actions, createId, selectors } from './state/store';\nimport { Timer, TimerStore } from './state/timer';\nimport { MODE, transition } from './transition';\n\nexport { actions, selectors, states } from './state/store';\n\nconst localState = {\n  uid: 0,\n};\n\nconst getUid = () => {\n  if (localState.uid === Number.MAX_VALUE) {\n    localState.uid = 0;\n  } else {\n    localState.uid += 1;\n  }\n  return localState.uid;\n};\n\nenum TransitionStates {\n  Default,\n  Displaying,\n  Hiding,\n}\n\nconst getMaybeItem =\n  <T = unknown>(ns: string) =>\n  (defaultDialogicOptions: Dialogic.DefaultDialogicOptions) =>\n  (identityOptions?: Dialogic.IdentityOptions) =>\n    selectors.find<T>(\n      ns,\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      getMergedIdentityOptions(defaultDialogicOptions, identityOptions),\n    );\n\nconst filterBySpawn =\n  <T = unknown>(identityOptions: Dialogic.IdentityOptions) =>\n  (items: Dialogic.Item<T>[]) =>\n    identityOptions.spawn !== undefined\n      ? items.filter(\n          item => item.identityOptions.spawn === identityOptions.spawn,\n        )\n      : items;\n\nconst filterById =\n  <T = unknown>(identityOptions: Dialogic.IdentityOptions) =>\n  (items: Dialogic.Item<T>[]) =>\n    identityOptions.id !== undefined\n      ? items.filter(item => item.identityOptions.id === identityOptions.id)\n      : items;\n\n/**\n * Gets a list of all non-queued items.\n * From the queued items only the first item is listed.\n * */\nconst filterFirstInQueue = <T = unknown>(nsItems: Dialogic.Item<T>[]) => {\n  let queuedCount = 0;\n  return nsItems\n    .map(item => ({\n      item,\n      queueCount: item.dialogicOptions.queued ? queuedCount++ : 0,\n    }))\n    .filter(({ queueCount }) => queueCount === 0)\n    .map(({ item }) => item);\n};\n\nexport const filterCandidates = (\n  ns: string,\n  items: Dialogic.NamespaceStore,\n  identityOptions: Dialogic.IdentityOptions,\n): Dialogic.Item[] => {\n  const nsItems = (items[ns] || []) as Dialogic.Item[];\n  if (nsItems.length === 0) {\n    return [];\n  }\n  const filteredBySpawn = filterBySpawn(identityOptions)(nsItems);\n  return filterFirstInQueue(filteredBySpawn);\n};\n\ntype TGetPassThroughOptions = <T = unknown>(options: Dialogic.Options<T>) => T;\n\nconst getPassThroughOptions: TGetPassThroughOptions = options => {\n  const copy = {\n    ...options,\n  };\n  delete copy.dialogic;\n  return copy;\n};\n\nconst getMergedIdentityOptions = (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  identityOptions: Dialogic.IdentityOptions = {},\n) =>\n  ({\n    id: identityOptions.id || defaultDialogicOptions.id,\n    spawn: identityOptions.spawn || defaultDialogicOptions.spawn,\n  } as Dialogic.IdentityOptions);\n\nconst handleOptions = <T = unknown>(\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  options?: Dialogic.Options<T>,\n) => {\n  const identityOptions = {\n    id: options?.dialogic ? options.dialogic.id : undefined,\n    spawn: options?.dialogic ? options.dialogic.spawn : undefined,\n  };\n  const mergedIdentityOptions = getMergedIdentityOptions(\n    defaultDialogicOptions || ({} as Dialogic.DefaultDialogicOptions),\n    identityOptions,\n  );\n\n  const dialogicOptions: Dialogic.DialogicOptions<T> = {\n    ...defaultDialogicOptions,\n    ...options?.dialogic,\n    __transitionTimeoutId__: 0,\n  };\n\n  const passThroughOptions = options\n    ? getPassThroughOptions(options)\n    : ({} as Dialogic.Options<T>);\n\n  return {\n    identityOptions: mergedIdentityOptions,\n    dialogicOptions,\n    passThroughOptions,\n  };\n};\n\nconst createInstance =\n  (ns: string) =>\n  (defaultDialogicOptions: Dialogic.DefaultDialogicOptions) =>\n  <T = unknown>(options?: Dialogic.Options<T>) => {\n    const { identityOptions, dialogicOptions, passThroughOptions } =\n      handleOptions(defaultDialogicOptions, options);\n\n    // eslint-disable-next-line consistent-return\n    return new Promise<Dialogic.Item<T>>(resolve => {\n      const callbacks: Dialogic.Callbacks<T> = {\n        willShow: (item: Dialogic.Item<T>) => {\n          if (dialogicOptions.willShow) {\n            dialogicOptions.willShow(item);\n          }\n          return resolve(item);\n        },\n        willHide: (item: Dialogic.Item<T>) => {\n          if (dialogicOptions.willHide) {\n            dialogicOptions.willHide(item);\n          }\n          return resolve(item);\n        },\n        didShow: (item: Dialogic.Item<T>) => {\n          if (dialogicOptions.didShow) {\n            dialogicOptions.didShow(item);\n          }\n          return resolve(item);\n        },\n        didHide: (item: Dialogic.Item<T>) => {\n          if (dialogicOptions.didHide) {\n            dialogicOptions.didHide(item);\n          }\n          return resolve(item);\n        },\n      };\n\n      const item: Dialogic.Item<T> = {\n        ns,\n        identityOptions,\n        dialogicOptions,\n        callbacks,\n        passThroughOptions,\n        id: createId(identityOptions, ns),\n        timer: dialogicOptions.timeout ? TimerStore() : undefined, // when timeout is undefined or 0\n        key: getUid().toString(), // Uniquely identify each item for keyed display\n        transitionState: TransitionStates.Default,\n      };\n\n      const maybeExistingItem: Dialogic.MaybeItem<T> = selectors.find<T>(\n        ns,\n        identityOptions,\n      );\n\n      const existingItem = maybeExistingItem.just;\n\n      if (existingItem && dialogicOptions.toggle) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        hide(ns)(defaultDialogicOptions)<T>(options);\n        resolve(existingItem);\n        return;\n      }\n\n      if (existingItem && !dialogicOptions.queued) {\n        const replacingItem = {\n          ...item,\n          key: existingItem.key,\n          transitionState: existingItem.transitionState,\n          dialogicOptions: existingItem.dialogicOptions, // Preserve dialogicOptions\n        };\n        actions.replace(ns, existingItem.id, replacingItem as Dialogic.Item<T>);\n      } else {\n        actions.add<T>(ns, item);\n        // This will instantiate and draw the instance\n        // The instance will call `showDialog` in `onMount`\n      }\n\n      resolve(item);\n    });\n  };\n\nexport const show = createInstance;\n\nexport const hide =\n  (ns: string) =>\n  (defaultDialogicOptions: Dialogic.DefaultDialogicOptions) =>\n  <T = unknown>(options?: Dialogic.Options<T>) => {\n    const { identityOptions, dialogicOptions, passThroughOptions } =\n      handleOptions(defaultDialogicOptions, options);\n    const maybeExistingItem: Dialogic.MaybeItem<T> = selectors.find<T>(\n      ns,\n      identityOptions,\n    );\n    const existingItem = maybeExistingItem.just;\n    if (existingItem) {\n      const item: Dialogic.Item<T> = {\n        ...existingItem,\n        dialogicOptions: {\n          ...existingItem.dialogicOptions,\n          ...dialogicOptions,\n        },\n        passThroughOptions: {\n          ...existingItem.passThroughOptions,\n          passThroughOptions,\n        },\n      };\n      actions.replace<T>(ns, existingItem.id, item);\n      if (item.transitionState !== TransitionStates.Hiding) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return hideItem<T>(item);\n      }\n      return Promise.resolve(item);\n    }\n    return Promise.resolve({\n      ns,\n      id: identityOptions.id,\n    } as Dialogic.Item<T>);\n  };\n\nexport const pause =\n  (ns: string) =>\n  (\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  ) =>\n  <T = unknown>(identityOptions?: Dialogic.IdentityOptions) => {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const validItems = getValidItems<T>(ns, identityOptions).filter(\n      item => !!item.timer,\n    );\n    validItems.forEach((item: Dialogic.Item<T>) => {\n      if (item.timer) {\n        item.timer.actions.pause();\n      }\n    });\n    return Promise.all(validItems);\n  };\n\nexport const resume =\n  (ns: string) =>\n  (\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  ) =>\n  <T = unknown>(commandOptions?: Dialogic.CommandOptions) => {\n    const options = commandOptions || {};\n    const identityOptions = {\n      id: options.id,\n      spawn: options.spawn,\n    };\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const validItems = getValidItems<T>(ns, identityOptions).filter(\n      item => !!item.timer,\n    );\n    validItems.forEach((item: Dialogic.Item<T>) => {\n      if (item.timer) {\n        item.timer.actions.resume(options.minimumDuration);\n      }\n    });\n    return Promise.all(validItems);\n  };\n\nconst getTimerSelectors = <T = unknown>(\n  ns: string,\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  identityOptions?: Dialogic.IdentityOptions,\n) => {\n  const maybeItem: Dialogic.MaybeItem<T> = getMaybeItem<T>(ns)(\n    defaultDialogicOptions,\n  )(identityOptions);\n  return maybeItem?.just?.timer?.selectors;\n};\n\nexport const isPaused =\n  (ns: string) =>\n  (defaultDialogicOptions: Dialogic.DefaultDialogicOptions) =>\n  (identityOptions?: Dialogic.IdentityOptions) =>\n    getTimerSelectors(\n      ns,\n      defaultDialogicOptions,\n      identityOptions,\n    )?.isPaused() || false;\n\nexport const getRemaining =\n  (ns: string) =>\n  (defaultDialogicOptions: Dialogic.DefaultDialogicOptions) =>\n  (identityOptions?: Dialogic.IdentityOptions) =>\n    getTimerSelectors(\n      ns,\n      defaultDialogicOptions,\n      identityOptions,\n    )?.getRemaining() || undefined;\n\nexport const exists =\n  (ns: string) =>\n  (\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  ) =>\n  (identityOptions?: Dialogic.IdentityOptions) =>\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    !!getValidItems(ns, identityOptions).length;\n\nconst getValidItems = <T = unknown>(\n  ns: string,\n  identityOptions?: Dialogic.IdentityOptions,\n) => {\n  const allItems = selectors.getAll<T>(ns);\n  let validItems: Dialogic.Item<T>[];\n  if (identityOptions) {\n    const filteredBySpawn = filterBySpawn<T>(identityOptions)(allItems);\n    validItems = filterById<T>(identityOptions)(filteredBySpawn);\n  } else {\n    validItems = allItems;\n  }\n  return validItems;\n};\n\nexport const resetAll =\n  (ns: string) =>\n  (\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  ) =>\n  (identityOptions?: Dialogic.IdentityOptions) => {\n    const validItems = getValidItems(ns, identityOptions);\n    const items: Dialogic.Item[] = [];\n\n    validItems.forEach((item: Dialogic.Item) => {\n      if (item.timer) {\n        item.timer.actions.abort();\n      }\n      items.push(item);\n    });\n\n    if (identityOptions) {\n      items.forEach((item: Dialogic.Item) => {\n        actions.remove(ns, item.id);\n      });\n    } else {\n      actions.removeAll(ns);\n    }\n\n    return Promise.resolve(items);\n  };\n\nconst getOverridingTransitionOptions = <T = unknown>(\n  item: Dialogic.Item<T>,\n  dialogicOptions: Dialogic.DialogicOptions<T>,\n) => ({\n  ...item,\n  dialogicOptions: {\n    ...item.dialogicOptions,\n    ...dialogicOptions,\n  },\n});\n\n/**\n * Triggers a `hideItem` for each item in the store.\n * Queued items: will trigger `hideItem` only for the first item, then reset the store.\n * Optional `dialogicOptions` may be passed with specific transition options. This comes in handy when all items should hide in the same way.\n */\nexport const hideAll =\n  (ns: string) =>\n  (\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  ) =>\n  <T = unknown>(dialogicOptions?: Dialogic.DialogicOptions<T>) => {\n    const options = dialogicOptions || {};\n    const identityOptions: Dialogic.IdentityOptions = {\n      id: options.id,\n      spawn: options.spawn,\n    };\n    const validItems = getValidItems<T>(ns, identityOptions);\n    const regularItems = validItems.filter(\n      (item: Dialogic.Item<T>) =>\n        !options.queued && !item.dialogicOptions.queued,\n    );\n    const queuedItems = validItems.filter(\n      (item: Dialogic.Item<T>) => options.queued || item.dialogicOptions.queued,\n    );\n\n    const items = [];\n\n    regularItems.forEach((item: Dialogic.Item<T>) =>\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      items.push(hideItem(getOverridingTransitionOptions<T>(item, options))),\n    );\n\n    if (queuedItems.length > 0) {\n      const [current] = queuedItems;\n      // Make sure that any remaining items don't suddenly appear\n      actions.store(ns, [current]);\n      // Transition the current item\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      items.push(hideItem(getOverridingTransitionOptions<T>(current, options)));\n    }\n\n    return Promise.all(items);\n  };\n\nexport const getCount =\n  (ns: string) => (identityOptions?: Dialogic.IdentityOptions) =>\n    selectors.getCount(ns, identityOptions);\n\nconst transitionItem = <T = unknown>(item: Dialogic.Item<T>, mode: string) =>\n  transition(item.dialogicOptions, mode);\n\nconst getResultPromise =\n  <T = unknown>() =>\n  (ns: string) =>\n  (defaultDialogicOptions: Dialogic.DefaultDialogicOptions) =>\n  (identityOptions?: Dialogic.IdentityOptions) => {\n    const maybeItem: Dialogic.MaybeItem<T> = getMaybeItem<T>(ns)(\n      defaultDialogicOptions,\n    )(identityOptions);\n    if (maybeItem.just) {\n      if (maybeItem.just && maybeItem.just.timer) {\n        return maybeItem.just.timer.selectors.getResultPromise();\n      }\n      return undefined;\n    }\n    return undefined;\n  };\n\nconst deferredHideItem = async <T = unknown>(\n  item: Dialogic.Item<T>,\n  timer: Timer,\n  timeout: number,\n) => {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  timer.actions.start(() => hideItem(item), timeout);\n  return getResultPromise<T>();\n};\n\nexport const showItem: Dialogic.InitiateItemTransitionFn = async <T = unknown>(\n  item: Dialogic.Item<T>,\n) => {\n  if (item.callbacks.willShow) {\n    item.callbacks.willShow(item);\n  }\n  if (item.transitionState !== TransitionStates.Displaying) {\n    // eslint-disable-next-line no-param-reassign\n    item.transitionState = TransitionStates.Displaying;\n    await transitionItem(item, MODE.SHOW);\n  }\n  if (item.callbacks.didShow) {\n    item.callbacks.didShow(item);\n  }\n  if (item.dialogicOptions.timeout && item.timer) {\n    await deferredHideItem(item, item.timer, item.dialogicOptions.timeout);\n  }\n  return Promise.resolve(item);\n};\n\n/**\n * Hides an item. Any timer will be stopped. Any callbacks will be called.\n * @returns A Promise with (a copy of) the data of the removed item.\n */\nexport const hideItem = async <T = unknown>(\n  item: Dialogic.Item<T>,\n): Promise<Dialogic.Item<T>> => {\n  // eslint-disable-next-line no-param-reassign\n  item.transitionState = TransitionStates.Hiding;\n  // Stop any running timer\n  if (item.timer) {\n    item.timer.actions.stop();\n  }\n  if (item.callbacks.willHide) {\n    item.callbacks.willHide(item);\n  }\n  await transitionItem(item, MODE.HIDE);\n  if (item.callbacks.didHide) {\n    item.callbacks.didHide(item);\n  }\n  const copy = {\n    ...item,\n  };\n  actions.remove(item.ns, item.id);\n  return Promise.resolve(copy);\n};\n\nexport const setDomElement = <T = unknown>(\n  domElement: HTMLElement,\n  item: Dialogic.Item<T>,\n) => {\n  // eslint-disable-next-line no-param-reassign\n  item.dialogicOptions.domElement = domElement;\n};\n","import {\n  exists,\n  getCount,\n  getRemaining,\n  hide,\n  hideAll,\n  isPaused,\n  pause,\n  resetAll,\n  resume,\n  show,\n} from './dialogic';\nimport { Dialogic } from './index';\n\nexport const dialogical = ({\n  ns,\n  queued,\n  timeout,\n}: {\n  ns: string;\n  queued?: boolean;\n  timeout?: number;\n}) => {\n  const defaultId = `default_${ns}`;\n  const defaultSpawn = `default_${ns}`;\n  const defaultDialogicOptions: Dialogic.DefaultDialogicOptions = {\n    id: defaultId,\n    spawn: defaultSpawn,\n    ...(queued && { queued }),\n    ...(timeout !== undefined && { timeout }),\n  };\n\n  return {\n    // Identification\n    ns,\n    defaultId,\n    defaultSpawn,\n    // Configuration\n    defaultDialogicOptions,\n    // Commands\n    show: show(ns)(defaultDialogicOptions),\n    hide: hide(ns)(defaultDialogicOptions),\n    hideAll: hideAll(ns)(defaultDialogicOptions),\n    resetAll: resetAll(ns)(defaultDialogicOptions),\n    // Timer commands\n    pause: pause(ns)(defaultDialogicOptions),\n    resume: resume(ns)(defaultDialogicOptions),\n    // State\n    exists: exists(ns)(defaultDialogicOptions),\n    getCount: getCount(ns),\n    // Timer state\n    isPaused: isPaused(ns)(defaultDialogicOptions),\n    getRemaining: getRemaining(ns)(defaultDialogicOptions),\n  };\n};\n","import { dialogical } from './dialogical';\n\nexport const dialog = dialogical({ ns: 'dialog' });\n","import { dialogical } from './dialogical';\n\nexport const notification = dialogical({\n  ns: 'notification',\n  queued: true,\n  timeout: 3000,\n});\n","/**\n * Utility script that uses an animation frame to pass the current remaining value\n * (which is utilized when setting `timeout`).\n */\n\nimport { DialogicInstance } from './types';\n\ntype RemainingProps = {\n  /**\n   * Dialogic instance: notification, dialog, or custom.\n   */\n  instance: DialogicInstance;\n\n  id?: string;\n  spawn?: string;\n\n  /**\n   * Set to true to return seconds instead of milliseconds.\n   */\n  roundToSeconds?: boolean;\n\n  /**\n   * Returns the remaining time as milliseconds. Returns `undefined` when the timer is not running (before and after the timer runs).\n   */\n  callback: (displayValue: number | undefined) => unknown;\n};\n\nexport const remaining = (props: RemainingProps) => {\n  let displayValue: number | undefined;\n  let reqId: number;\n  let isCanceled: boolean = false;\n  const identity = {\n    id: props.id,\n    spawn: props.spawn,\n  };\n\n  const update = () => {\n    const remainingValue = props.instance.getRemaining(identity);\n    if (displayValue !== remainingValue) {\n      displayValue =\n        remainingValue === undefined\n          ? remainingValue\n          : props.roundToSeconds\n          ? Math.round(Math.max(remainingValue, 0) / 1000)\n          : Math.max(remainingValue, 0);\n    }\n    props.callback(displayValue);\n    if (!props.instance.exists(identity)) {\n      window.cancelAnimationFrame(reqId);\n      isCanceled = true;\n    } else if (!isCanceled) {\n      reqId = window.requestAnimationFrame(update);\n    }\n  };\n  reqId = window.requestAnimationFrame(update);\n};\n"],"names":["update","remaining","states","getRemaining","actions","selectors","item"],"mappings":"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"}