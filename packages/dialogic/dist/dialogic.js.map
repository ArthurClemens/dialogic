{"version":3,"file":"dialogic.js","sources":["../../../node_modules/tslib/tslib.es6.js","../src/state/store.ts","../src/state/timer.ts","../src/utils.ts","../src/transition.ts","../src/dialogic.ts","../src/dialogical.ts","../src/dialog.ts","../src/notification.ts","../src/remaining.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/* eslint-disable no-param-reassign */\nimport Stream from 'mithril/stream';\n\nimport { Dialogic } from '../index';\n\ntype PatchFn = (state: Dialogic.State) => Dialogic.State;\n\nconst findItem = <T = unknown>(id: string, items: Dialogic.Item<T>[]) =>\n  items.find(item => item.id === id);\n\nconst itemIndex = <T = unknown>(id: string, items: Dialogic.Item<T>[]) => {\n  const item = findItem<T>(id, items);\n  return item ? items.indexOf(item) : -1;\n};\n\nconst removeItem = <T = unknown>(id: string, items: Dialogic.Item<T>[]) => {\n  const index = itemIndex<T>(id, items);\n  if (index !== -1) {\n    items.splice(index, 1);\n  }\n  return items;\n};\n\nexport const createId = (\n  identityOptions: Dialogic.IdentityOptions,\n  ns: string,\n) => [ns, identityOptions.id, identityOptions.spawn].filter(Boolean).join('-');\n\nconst store = {\n  initialState: {\n    store: {},\n  },\n\n  actions: (update: Stream<PatchFn>) => ({\n    /**\n     * Add an item to the end of the list.\n     */\n    add: <T extends unknown = unknown>(ns: string, item: Dialogic.Item<T>) => {\n      update((state: Dialogic.State) => {\n        const items = state.store[ns] || [];\n        state.store[ns] = [...items, item as Dialogic.Item<unknown>];\n        if (item.timer) {\n          // When the timer state updates, refresh the store so that UI can pick up the change\n          item.timer.states.map(() => store.actions(update).refresh());\n        }\n        return state;\n      });\n    },\n\n    /**\n     * Removes the first item with a match on `id`.\n     */\n    remove: (ns: string, id: string) => {\n      update((state: Dialogic.State) => {\n        const items = state.store[ns] || [];\n        const remaining = removeItem(id, items);\n        state.store[ns] = remaining;\n        return state;\n      });\n    },\n\n    /**\n     * Replaces the first item with a match on `id` with a newItem.\n     */\n    replace: <T = unknown>(\n      ns: string,\n      id: string,\n      newItem: Dialogic.Item<T>,\n    ) => {\n      update((state: Dialogic.State) => {\n        const items = state.store[ns] || [];\n        if (items) {\n          const index = itemIndex(id, items);\n          if (index !== -1) {\n            items[index] = newItem as Dialogic.Item<unknown>;\n            state.store[ns] = [...items] as Dialogic.Item<unknown>[];\n          }\n        }\n        return state;\n      });\n    },\n\n    /**\n     * Removes all items within a namespace.\n     */\n    removeAll: (ns: string) => {\n      update((state: Dialogic.State) => {\n        state.store[ns] = [];\n        return state;\n      });\n    },\n\n    /**\n     * Replaces all items within a namespace.\n     */\n    store: <T = unknown>(ns: string, newItems: Dialogic.Item<T>[]) => {\n      update((state: Dialogic.State) => {\n        state.store[ns] = [...(newItems as Dialogic.Item[])];\n        return state;\n      });\n    },\n\n    refresh: () => {\n      update((state: Dialogic.State) => ({\n        ...state,\n      }));\n    },\n  }),\n\n  selectors: (states: Stream<Dialogic.State>) => {\n    const fns = {\n      getStore: () => {\n        const state = states();\n        return state.store;\n      },\n\n      find: <T = unknown>(\n        ns: string,\n        identityOptions: Dialogic.IdentityOptions,\n      ) => {\n        const state = states();\n        const items = state.store[ns] || [];\n        const id = createId(identityOptions, ns);\n        const item = items.find(fitem => fitem.id === id) as Dialogic.Item<T>;\n        return item ? { just: item } : { nothing: undefined };\n      },\n\n      getAll: <T = unknown>(\n        ns: string,\n        identityOptions?: Dialogic.IdentityOptions,\n      ) => {\n        const state = states();\n        const items = (state.store[ns] || []) as Dialogic.Item<T>[];\n        const spawn =\n          identityOptions !== undefined ? identityOptions.spawn : undefined;\n        const id =\n          identityOptions !== undefined ? identityOptions.id : undefined;\n        const itemsBySpawn =\n          spawn !== undefined\n            ? items.filter(fitem => fitem.identityOptions.spawn === spawn)\n            : items;\n        const itemsById =\n          id !== undefined\n            ? itemsBySpawn.filter(item => item.identityOptions.id === id)\n            : itemsBySpawn;\n        return itemsById;\n      },\n\n      getCount: (ns: string, identityOptions?: Dialogic.IdentityOptions) =>\n        fns.getAll(ns, identityOptions).length,\n    };\n\n    return fns;\n  },\n};\n\nconst update: Stream<PatchFn> = Stream<PatchFn>();\n\nexport const states: Dialogic.States = Stream.scan(\n  (state: Dialogic.State, patch: PatchFn) => patch(state),\n  {\n    ...store.initialState,\n  },\n  update,\n);\n\nexport const actions = {\n  ...store.actions(update),\n};\n\nexport const selectors = {\n  ...store.selectors(states),\n};\n\n// states.map(state =>\n//   console.log(JSON.stringify(state, null, 2))\n// );\n","/* eslint-disable no-param-reassign */\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport Stream from 'mithril/stream';\n\ntype TimerCallback = () => unknown;\ntype TOnFinishFn = () => void;\n\ntype TimerState = {\n  timerId?: number;\n  startTime?: number;\n  remaining: number | undefined;\n  isPaused: boolean;\n  callback: TimerCallback;\n  timeoutFn: () => void;\n  promise?: Promise<unknown>;\n  onDone: TOnFinishFn;\n  onAbort: TOnFinishFn;\n};\n\ntype PatchFn = (state: TimerState) => TimerState;\n\nconst initialState: TimerState = {\n  callback: () => {},\n  isPaused: false,\n  onAbort: () => {},\n  onDone: () => {},\n  promise: undefined,\n  remaining: undefined,\n  startTime: undefined,\n  timeoutFn: () => {},\n  timerId: undefined,\n};\n\nconst appendStartTimer = (\n  state: TimerState,\n  callback: TimerCallback,\n  duration: number,\n  updateState: () => unknown,\n) => {\n  const timeoutFn = () => {\n    callback();\n    state.onDone();\n    updateState();\n  };\n  return {\n    timeoutFn,\n    promise: new Promise<void>(resolve => {\n      state.onDone = () => resolve();\n      state.onAbort = () => resolve();\n    }),\n    ...(state.isPaused\n      ? {}\n      : {\n          startTime: new Date().getTime(),\n          timerId: window.setTimeout(timeoutFn, duration),\n          remaining: duration,\n        }),\n  };\n};\n\nconst appendStopTimeout = (state: TimerState) => {\n  window.clearTimeout(state.timerId);\n  return {\n    timerId: initialState.timerId,\n  };\n};\n\nconst appendStopTimer = (state: TimerState) => ({\n  ...appendStopTimeout(state),\n});\n\nconst appendPauseTimer = (state: TimerState) => ({\n  ...appendStopTimeout(state),\n  isPaused: true,\n  remaining: getRemaining(state),\n});\n\nconst appendResumeTimer = (state: TimerState, minimumDuration?: number) => {\n  window.clearTimeout(state.timerId);\n  const remaining = minimumDuration\n    ? Math.max(state.remaining || 0, minimumDuration)\n    : state.remaining;\n  return {\n    startTime: new Date().getTime(),\n    isPaused: false,\n    remaining,\n    timerId: window.setTimeout(state.timeoutFn, remaining),\n  };\n};\n\nconst getRemaining = (state: TimerState) =>\n  state.remaining === 0 || state.remaining === undefined\n    ? state.remaining\n    : state.remaining - (new Date().getTime() - (state.startTime || 0));\n\nexport const TimerStore = () => {\n  const timer = {\n    initialState,\n    actions: (update: Stream<PatchFn>) => ({\n      /**\n       * Starts the timer\n       * @param {callback} Function Callback function that is called after completion.\n       * @param {duration} Number Timer duration in milliseconds.\n       */\n      start: (callback: TimerCallback, duration: number) => {\n        update((state: TimerState) => ({\n          ...state,\n          ...appendStopTimeout(state),\n          ...appendStartTimer(state, callback, duration, () =>\n            timer.actions(update).done(),\n          ),\n          ...(state.isPaused && appendPauseTimer(state)),\n        }));\n      },\n\n      /**\n       * Stops the timer.\n       */\n      stop: () => {\n        update((state: TimerState) => ({\n          ...state,\n          ...appendStopTimer(state),\n          ...initialState,\n        }));\n      },\n\n      /**\n       * Pauses a running timer.\n       */\n      pause: () => {\n        update((state: TimerState) => ({\n          ...state,\n          ...(!state.isPaused && appendPauseTimer(state)),\n        }));\n      },\n\n      /**\n       * Resumes a paused timer.\n       * @param {minimumDuration} Number Sets the minimum duration.\n       */\n      resume: (minimumDuration?: number) => {\n        update((state: TimerState) => ({\n          ...state,\n          ...(state.isPaused && appendResumeTimer(state, minimumDuration)),\n        }));\n      },\n\n      /**\n       * Aborts and clears a timer.\n       */\n      abort: () => {\n        update((state: TimerState) => {\n          state.onAbort();\n          return {\n            ...state,\n            ...appendStopTimeout(state),\n          };\n        });\n      },\n\n      /**\n       * Updates the current state. Used to get the state for selectors.getRemaining.\n       */\n      refresh: () => {\n        update((state: TimerState) => ({\n          ...state,\n        }));\n      },\n\n      /**\n       * Brings the timer to its initial state.\n       * Used internally.\n       */\n      done: () => {\n        update(() => initialState);\n      },\n    }),\n\n    selectors: (states: Stream<TimerState>) => ({\n      /**\n       * Returns the paused state.\n       */\n      isPaused: () => {\n        const state = states();\n        return state.isPaused;\n      },\n\n      /**\n       * Returns the remaining duration in milliseconds.\n       */\n      getRemaining: () => {\n        const state = states();\n        return state.isPaused ? state.remaining : getRemaining(state);\n      },\n\n      /**\n       * The promise that is handled when the timer is done or canceled.\n       */\n      getResultPromise: () => {\n        const state = states();\n        return state.promise;\n      },\n    }),\n  };\n\n  const update: Stream<PatchFn> = Stream<PatchFn>();\n\n  const states = Stream.scan(\n    (state: TimerState, patch: PatchFn) => patch(state),\n    {\n      ...timer.initialState,\n    },\n    update,\n  );\n\n  const actions = {\n    ...timer.actions(update),\n  };\n\n  const selectors = {\n    ...timer.selectors(states),\n  };\n\n  // states.map(state =>\n  //   console.log(JSON.stringify(state, null, 2))\n  // );\n\n  return {\n    states,\n    actions,\n    selectors,\n  };\n};\n\nexport type Timer = ReturnType<typeof TimerStore>;\n","export const isClient = typeof document !== 'undefined';\nexport const isServer = !isClient;\n\ntype Fn = (args: any) => any;\n\nexport const pipe = (...fns: Fn[]) => (x: any) =>\n  fns.filter(Boolean).reduce((y, f) => f(y), x);\n\nexport const getStyleValue = ({\n  domElement,\n  prop,\n}: {\n  domElement: HTMLElement;\n  prop: string;\n}) => {\n  const defaultView = document.defaultView;\n  if (defaultView) {\n    const style = defaultView.getComputedStyle(domElement);\n    if (style) {\n      return style.getPropertyValue(prop);\n    }\n  }\n};\n","import { getStyleValue } from './utils';\n\nexport const MODE = {\n  SHOW: 'show',\n  HIDE: 'hide',\n};\n\nexport type TransitionStylesFn = (domElement: HTMLElement) => TransitionStyles;\n\nexport type TransitionStyles = {\n  default?: Partial<CSSStyleDeclaration>;\n  showStart?: Partial<CSSStyleDeclaration>;\n  showEnd?: Partial<CSSStyleDeclaration>;\n  hideStart?: Partial<CSSStyleDeclaration>;\n  hideEnd?: Partial<CSSStyleDeclaration>;\n};\n\ntype TransitionProps = {\n  domElement?: HTMLElement;\n  className?: string;\n  styles?: TransitionStyles | TransitionStylesFn;\n  __transitionTimeoutId__?: number;\n};\n\ntype TransitionClassNames = {\n  [key: string]: string[];\n  showStart: string[];\n  showEnd: string[];\n  hideStart: string[];\n  hideEnd: string[];\n};\n\ntype TransitionStep = 'showStart' | 'showEnd' | 'hideStart' | 'hideEnd';\ntype TransitionStyleState = 'default' | TransitionStep;\n\ntype KeyValue = { [key: string]: string };\n\nconst removeTransitionClassNames = (\n  domElement: HTMLElement,\n  transitionClassNames: TransitionClassNames,\n) =>\n  domElement.classList.remove(\n    ...transitionClassNames.showStart,\n    ...transitionClassNames.showEnd,\n    ...transitionClassNames.hideStart,\n    ...transitionClassNames.hideEnd,\n  );\n\nconst applyTransitionStyles = (\n  domElement: HTMLElement,\n  step: TransitionStyleState,\n  styles: TransitionStyles,\n) => {\n  const transitionStyle = styles[step] as CSSStyleDeclaration;\n  if (transitionStyle) {\n    Object.keys(transitionStyle).forEach((key: string) => {\n      // Workaround for error \"getPropertyValue is not a function\"\n      const value = ((transitionStyle as unknown) as KeyValue)[key];\n      // eslint-disable-next-line no-param-reassign\n      ((domElement.style as unknown) as KeyValue)[key] = value;\n    });\n  }\n};\n\nconst applyNoDurationTransitionStyle = (domElement: HTMLElement) => {\n  // eslint-disable-next-line no-param-reassign\n  domElement.style.transitionDuration = '0ms';\n};\n\nconst getTransitionStyles = (\n  domElement: HTMLElement,\n  styles: TransitionStyles | TransitionStylesFn,\n) => (typeof styles === 'function' ? styles(domElement) : styles) || {};\n\nconst createClassList = (className: string, step: string) =>\n  className.split(/ /).map((n: string) => `${n}-${step}`);\n\nconst applyStylesForState = (\n  domElement: HTMLElement,\n  props: TransitionProps,\n  step: TransitionStep,\n  isEnterStep?: boolean,\n) => {\n  if (props.styles) {\n    const styles = getTransitionStyles(domElement, props.styles);\n    applyTransitionStyles(domElement, 'default', styles);\n    if (isEnterStep) {\n      applyNoDurationTransitionStyle(domElement);\n    }\n    applyTransitionStyles(domElement, step, styles);\n  }\n\n  if (props.className) {\n    const transitionClassNames: TransitionClassNames = {\n      showStart: createClassList(props.className, 'show-start'),\n      showEnd: createClassList(props.className, 'show-end'),\n      hideStart: createClassList(props.className, 'hide-start'),\n      hideEnd: createClassList(props.className, 'hide-end'),\n    };\n    removeTransitionClassNames(domElement, transitionClassNames);\n    if (transitionClassNames) {\n      domElement.classList.add(...transitionClassNames[step]);\n    }\n  }\n\n  // reflow\n  // eslint-disable-next-line no-unused-expressions\n  domElement.scrollTop;\n};\n\nconst styleDurationToMs = (durationStr: string) => {\n  const parsed =\n    parseFloat(durationStr) * (durationStr.indexOf('ms') === -1 ? 1000 : 1);\n  return Number.isNaN(parsed) ? 0 : parsed;\n};\n\nconst getDuration = (domElement: HTMLElement) => {\n  const durationStyleValue = getStyleValue({\n    domElement,\n    prop: 'transition-duration',\n  });\n  const durationValue =\n    durationStyleValue !== undefined\n      ? styleDurationToMs(durationStyleValue)\n      : 0;\n  const delayStyleValue = getStyleValue({\n    domElement,\n    prop: 'transition-delay',\n  });\n  const delayValue =\n    delayStyleValue !== undefined ? styleDurationToMs(delayStyleValue) : 0;\n  return durationValue + delayValue;\n};\n\ntype Step = {\n  nextStep?: TransitionStep;\n};\n\ntype Steps = {\n  showStart: Step;\n  showEnd: Step;\n  hideStart: Step;\n  hideEnd: Step;\n};\n\nconst steps: Steps = {\n  showStart: {\n    nextStep: 'showEnd',\n  },\n  showEnd: {\n    nextStep: undefined,\n  },\n  hideStart: {\n    nextStep: 'hideEnd',\n  },\n  hideEnd: {\n    nextStep: undefined,\n  },\n};\n\nexport const transition = (props: TransitionProps, mode?: string) => {\n  const { domElement } = props;\n  if (!domElement) {\n    return Promise.resolve('no domElement');\n  }\n  clearTimeout(props.__transitionTimeoutId__);\n\n  let currentStep: TransitionStep =\n    mode === MODE.SHOW ? 'showStart' : 'hideStart';\n\n  return new Promise(resolve => {\n    applyStylesForState(\n      domElement,\n      props,\n      currentStep,\n      currentStep === 'showStart',\n    );\n\n    setTimeout(() => {\n      const { nextStep } = steps[currentStep];\n      if (nextStep) {\n        currentStep = nextStep;\n        applyStylesForState(domElement, props, currentStep);\n        // addEventListener sometimes hangs this function because it never finishes\n        // Using setTimeout instead of addEventListener gives more consistent results\n        const duration = getDuration(domElement);\n        // eslint-disable-next-line no-param-reassign\n        props.__transitionTimeoutId__ = window.setTimeout(resolve, duration);\n      }\n    }, 0);\n  });\n};\n","/* eslint-disable no-plusplus */\nimport { Dialogic } from './index';\nimport { actions, createId, selectors } from './state/store';\nimport { Timer, TimerStore } from './state/timer';\nimport { MODE, transition } from './transition';\nimport { pipe } from './utils';\n\nexport { actions, selectors, states } from './state/store';\n\nconst localState = {\n  uid: 0,\n};\n\nconst getUid = () => {\n  if (localState.uid === Number.MAX_VALUE) {\n    localState.uid = 0;\n  } else {\n    localState.uid += 1;\n  }\n  return localState.uid;\n};\n\nenum TransitionStates {\n  Default,\n  Displaying,\n  Hiding,\n}\n\nconst getMaybeItem = <T = unknown>(ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (identityOptions?: Dialogic.IdentityOptions) =>\n  selectors.find<T>(\n    ns,\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    getMergedIdentityOptions(defaultDialogicOptions, identityOptions),\n  );\n\nconst filterBySpawn = <T = unknown>(\n  identityOptions: Dialogic.IdentityOptions,\n) => (items: Dialogic.Item<T>[]) =>\n  identityOptions.spawn !== undefined\n    ? items.filter(item => item.identityOptions.spawn === identityOptions.spawn)\n    : items;\n\nconst filterById = <T = unknown>(identityOptions: Dialogic.IdentityOptions) => (\n  items: Dialogic.Item<T>[],\n) =>\n  identityOptions.id !== undefined\n    ? items.filter(item => item.identityOptions.id === identityOptions.id)\n    : items;\n\n/**\n * Gets a list of all non-queued items.\n * From the queued items only the first item is listed.\n * */\nconst filterFirstInQueue = <T = unknown>(nsItems: Dialogic.Item<T>[]) => {\n  let queuedCount = 0;\n  return nsItems\n    .map(item => ({\n      item,\n      queueCount: item.dialogicOptions.queued ? queuedCount++ : 0,\n    }))\n    .filter(({ queueCount }) => queueCount === 0)\n    .map(({ item }) => item);\n};\n\nexport const filterCandidates = (\n  ns: string,\n  items: Dialogic.NamespaceStore,\n  identityOptions: Dialogic.IdentityOptions,\n): Dialogic.Item[] => {\n  const nsItems = (items[ns] || []) as Dialogic.Item[];\n  if (nsItems.length === 0) {\n    return [];\n  }\n  return pipe(filterBySpawn(identityOptions), filterFirstInQueue)(nsItems);\n};\n\ntype TGetPassThroughOptions = <T = unknown>(options: Dialogic.Options<T>) => T;\n\nconst getPassThroughOptions: TGetPassThroughOptions = options => {\n  const copy = {\n    ...options,\n  };\n  delete copy.dialogic;\n  return copy;\n};\n\nconst getMergedIdentityOptions = (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  identityOptions: Dialogic.IdentityOptions = {},\n) =>\n  ({\n    id: identityOptions.id || defaultDialogicOptions.id,\n    spawn: identityOptions.spawn || defaultDialogicOptions.spawn,\n  } as Dialogic.IdentityOptions);\n\nconst handleOptions = <T = unknown>(\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  options: Dialogic.Options<T> = {} as T,\n) => {\n  const identityOptions = {\n    id: options.dialogic ? options.dialogic.id : undefined,\n    spawn: options.dialogic ? options.dialogic.spawn : undefined,\n  };\n  const mergedIdentityOptions = getMergedIdentityOptions(\n    defaultDialogicOptions || ({} as Dialogic.DefaultDialogicOptions),\n    identityOptions,\n  );\n\n  const dialogicOptions: Dialogic.DialogicOptions<T> = {\n    ...defaultDialogicOptions,\n    ...options.dialogic,\n    __transitionTimeoutId__: 0,\n  };\n\n  const passThroughOptions = getPassThroughOptions(options);\n\n  return {\n    identityOptions: mergedIdentityOptions,\n    dialogicOptions,\n    passThroughOptions,\n  };\n};\n\nconst createInstance = (ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => <T = unknown>(options?: Dialogic.Options<T>) => {\n  const {\n    identityOptions,\n    dialogicOptions,\n    passThroughOptions,\n  } = handleOptions(defaultDialogicOptions, options);\n\n  // eslint-disable-next-line consistent-return\n  return new Promise<Dialogic.Item<T>>(resolve => {\n    const callbacks: Dialogic.Callbacks<T> = {\n      willShow: (item: Dialogic.Item<T>) => {\n        if (dialogicOptions.willShow) {\n          dialogicOptions.willShow(item);\n        }\n        return resolve(item);\n      },\n      willHide: (item: Dialogic.Item<T>) => {\n        if (dialogicOptions.willHide) {\n          dialogicOptions.willHide(item);\n        }\n        return resolve(item);\n      },\n      didShow: (item: Dialogic.Item<T>) => {\n        if (dialogicOptions.didShow) {\n          dialogicOptions.didShow(item);\n        }\n        return resolve(item);\n      },\n      didHide: (item: Dialogic.Item<T>) => {\n        if (dialogicOptions.didHide) {\n          dialogicOptions.didHide(item);\n        }\n        return resolve(item);\n      },\n    };\n\n    const item: Dialogic.Item<T> = {\n      ns,\n      identityOptions,\n      dialogicOptions,\n      callbacks,\n      passThroughOptions,\n      id: createId(identityOptions, ns),\n      timer: dialogicOptions.timeout ? TimerStore() : undefined, // when timeout is undefined or 0\n      key: getUid().toString(), // Uniquely identify each item for keyed display\n      transitionState: TransitionStates.Default,\n    };\n\n    const maybeExistingItem: Dialogic.MaybeItem<T> = selectors.find<T>(\n      ns,\n      identityOptions,\n    );\n\n    const existingItem = maybeExistingItem.just;\n\n    if (existingItem && dialogicOptions.toggle) {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      hide(ns)(defaultDialogicOptions)<T>(options);\n      return resolve(existingItem);\n    }\n\n    if (existingItem && !dialogicOptions.queued) {\n      const replacingItem = {\n        ...item,\n        key: existingItem.key,\n        transitionState: existingItem.transitionState,\n        dialogicOptions: existingItem.dialogicOptions, // Preserve dialogicOptions\n      };\n      actions.replace(ns, existingItem.id, replacingItem as Dialogic.Item<T>);\n    } else {\n      actions.add<T>(ns, item);\n      // This will instantiate and draw the instance\n      // The instance will call `showDialog` in `onMount`\n    }\n\n    resolve(item);\n  });\n};\n\nexport const show = createInstance;\n\nexport const hide = (ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => <T = unknown>(options?: Dialogic.Options<T>) => {\n  const {\n    identityOptions,\n    dialogicOptions,\n    passThroughOptions,\n  } = handleOptions(defaultDialogicOptions, options);\n  const maybeExistingItem: Dialogic.MaybeItem<T> = selectors.find<T>(\n    ns,\n    identityOptions,\n  );\n  const existingItem = maybeExistingItem.just;\n  if (existingItem) {\n    const item: Dialogic.Item<T> = {\n      ...existingItem,\n      dialogicOptions: {\n        ...existingItem.dialogicOptions,\n        ...dialogicOptions,\n      },\n      passThroughOptions: {\n        ...existingItem.passThroughOptions,\n        passThroughOptions,\n      },\n    };\n    actions.replace<T>(ns, existingItem.id, item);\n    if (item.transitionState !== TransitionStates.Hiding) {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return hideItem<T>(item);\n    }\n    return Promise.resolve(item);\n  }\n  return Promise.resolve({\n    ns,\n    id: identityOptions.id,\n  } as Dialogic.Item<T>);\n};\n\nexport const pause = (ns: string) => (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => <T = unknown>(identityOptions?: Dialogic.IdentityOptions) => {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  const validItems = getValidItems<T>(ns, identityOptions).filter(\n    item => !!item.timer,\n  );\n  validItems.forEach((item: Dialogic.Item<T>) => {\n    if (item.timer) {\n      item.timer.actions.pause();\n    }\n  });\n  return Promise.all(validItems);\n};\n\nexport const resume = (ns: string) => (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => <T = unknown>(commandOptions?: Dialogic.CommandOptions) => {\n  const options = commandOptions || {};\n  const identityOptions = {\n    id: options.id,\n    spawn: options.spawn,\n  };\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  const validItems = getValidItems<T>(ns, identityOptions).filter(\n    item => !!item.timer,\n  );\n  validItems.forEach((item: Dialogic.Item<T>) => {\n    if (item.timer) {\n      item.timer.actions.resume(options.minimumDuration);\n    }\n  });\n  return Promise.all(validItems);\n};\n\nconst getTimerSelectors = <T = unknown>(\n  ns: string,\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  identityOptions?: Dialogic.IdentityOptions,\n) => {\n  const maybeItem: Dialogic.MaybeItem<T> = getMaybeItem<T>(ns)(\n    defaultDialogicOptions,\n  )(identityOptions);\n  return maybeItem?.just?.timer?.selectors;\n};\n\nexport const isPaused = (ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (identityOptions?: Dialogic.IdentityOptions) =>\n  getTimerSelectors(ns, defaultDialogicOptions, identityOptions)?.isPaused() ||\n  false;\n\nexport const getRemaining = (ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (identityOptions?: Dialogic.IdentityOptions) =>\n  getTimerSelectors(\n    ns,\n    defaultDialogicOptions,\n    identityOptions,\n  )?.getRemaining() || undefined;\n\nexport const exists = (ns: string) => (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (identityOptions?: Dialogic.IdentityOptions) =>\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  !!getValidItems(ns, identityOptions).length;\n\nconst getValidItems = <T = unknown>(\n  ns: string,\n  identityOptions?: Dialogic.IdentityOptions,\n) => {\n  const allItems = selectors.getAll<T>(ns);\n  let validItems: Dialogic.Item<T>[];\n  if (identityOptions) {\n    validItems = pipe(\n      filterBySpawn(identityOptions),\n      filterById(identityOptions),\n    )(allItems);\n  } else {\n    validItems = allItems;\n  }\n  return validItems;\n};\n\nexport const resetAll = (ns: string) => (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (identityOptions?: Dialogic.IdentityOptions) => {\n  const validItems = getValidItems(ns, identityOptions);\n  const items: Dialogic.Item[] = [];\n\n  validItems.forEach((item: Dialogic.Item) => {\n    if (item.timer) {\n      item.timer.actions.abort();\n    }\n    items.push(item);\n  });\n\n  if (identityOptions) {\n    items.forEach((item: Dialogic.Item) => {\n      actions.remove(ns, item.id);\n    });\n  } else {\n    actions.removeAll(ns);\n  }\n\n  return Promise.resolve(items);\n};\n\nconst getOverridingTransitionOptions = <T = unknown>(\n  item: Dialogic.Item<T>,\n  dialogicOptions: Dialogic.DialogicOptions<T>,\n) => ({\n  ...item,\n  dialogicOptions: {\n    ...item.dialogicOptions,\n    ...dialogicOptions,\n  },\n});\n\n/**\n * Triggers a `hideItem` for each item in the store.\n * Queued items: will trigger `hideItem` only for the first item, then reset the store.\n * Optional `dialogicOptions` may be passed with specific transition options. This comes in handy when all items should hide in the same way.\n */\nexport const hideAll = (ns: string) => (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => <T = unknown>(dialogicOptions?: Dialogic.DialogicOptions<T>) => {\n  const options = dialogicOptions || {};\n  const identityOptions: Dialogic.IdentityOptions = {\n    id: options.id,\n    spawn: options.spawn,\n  };\n  const validItems = getValidItems<T>(ns, identityOptions);\n  const regularItems = validItems.filter(\n    (item: Dialogic.Item<T>) => !options.queued && !item.dialogicOptions.queued,\n  );\n  const queuedItems = validItems.filter(\n    (item: Dialogic.Item<T>) => options.queued || item.dialogicOptions.queued,\n  );\n\n  const items = [];\n\n  regularItems.forEach((item: Dialogic.Item<T>) =>\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    items.push(hideItem(getOverridingTransitionOptions<T>(item, options))),\n  );\n\n  if (queuedItems.length > 0) {\n    const [current] = queuedItems;\n    // Make sure that any remaining items don't suddenly appear\n    actions.store(ns, [current]);\n    // Transition the current item\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    items.push(hideItem(getOverridingTransitionOptions<T>(current, options)));\n  }\n\n  return Promise.all(items);\n};\n\nexport const getCount = (ns: string) => (\n  identityOptions?: Dialogic.IdentityOptions,\n) => selectors.getCount(ns, identityOptions);\n\nconst transitionItem = <T = unknown>(item: Dialogic.Item<T>, mode: string) =>\n  transition(item.dialogicOptions, mode);\n\nconst getResultPromise = <T = unknown>() => (ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (identityOptions?: Dialogic.IdentityOptions) => {\n  const maybeItem: Dialogic.MaybeItem<T> = getMaybeItem<T>(ns)(\n    defaultDialogicOptions,\n  )(identityOptions);\n  if (maybeItem.just) {\n    if (maybeItem.just && maybeItem.just.timer) {\n      return maybeItem.just.timer.selectors.getResultPromise();\n    }\n    return undefined;\n  }\n  return undefined;\n};\n\nconst deferredHideItem = async <T = unknown>(\n  item: Dialogic.Item<T>,\n  timer: Timer,\n  timeout: number,\n) => {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  timer.actions.start(() => hideItem(item), timeout);\n  return getResultPromise<T>();\n};\n\nexport const showItem: Dialogic.InitiateItemTransitionFn = async <T = unknown>(\n  item: Dialogic.Item<T>,\n) => {\n  if (item.callbacks.willShow) {\n    item.callbacks.willShow(item);\n  }\n  if (item.transitionState !== TransitionStates.Displaying) {\n    // eslint-disable-next-line no-param-reassign\n    item.transitionState = TransitionStates.Displaying;\n    await transitionItem(item, MODE.SHOW);\n  }\n  if (item.callbacks.didShow) {\n    item.callbacks.didShow(item);\n  }\n  if (item.dialogicOptions.timeout && item.timer) {\n    await deferredHideItem(item, item.timer, item.dialogicOptions.timeout);\n  }\n  return Promise.resolve(item);\n};\n\n/**\n * Hides an item. Any timer will be stopped. Any callbacks will be called.\n * @returns A Promise with (a copy of) the data of the removed item.\n */\nexport const hideItem = async <T = unknown>(\n  item: Dialogic.Item<T>,\n): Promise<Dialogic.Item<T>> => {\n  // eslint-disable-next-line no-param-reassign\n  item.transitionState = TransitionStates.Hiding;\n  // Stop any running timer\n  if (item.timer) {\n    item.timer.actions.stop();\n  }\n  if (item.callbacks.willHide) {\n    item.callbacks.willHide(item);\n  }\n  await transitionItem(item, MODE.HIDE);\n  if (item.callbacks.didHide) {\n    item.callbacks.didHide(item);\n  }\n  const copy = {\n    ...item,\n  };\n  actions.remove(item.ns, item.id);\n  return Promise.resolve(copy);\n};\n\nexport const setDomElement = <T = unknown>(\n  domElement: HTMLElement,\n  item: Dialogic.Item<T>,\n) => {\n  // eslint-disable-next-line no-param-reassign\n  item.dialogicOptions.domElement = domElement;\n};\n","import {\n  show,\n  hide,\n  hideAll,\n  resetAll,\n  getCount,\n  pause,\n  resume,\n  isPaused,\n  getRemaining,\n  exists,\n} from './dialogic';\nimport { Dialogic } from './index';\n\nexport const dialogical = ({\n  ns,\n  queued,\n  timeout,\n}: {\n  ns: string;\n  queued?: boolean;\n  timeout?: number;\n}) => {\n  const defaultId = `default_${ns}`;\n  const defaultSpawn = `default_${ns}`;\n  const defaultDialogicOptions: Dialogic.DefaultDialogicOptions = {\n    id: defaultId,\n    spawn: defaultSpawn,\n    ...(queued && { queued }),\n    ...(timeout !== undefined && { timeout }),\n  };\n\n  return {\n    // Identification\n    ns,\n    defaultId,\n    defaultSpawn,\n    // Configuration\n    defaultDialogicOptions,\n    // Commands\n    show: show(ns)(defaultDialogicOptions),\n    hide: hide(ns)(defaultDialogicOptions),\n    hideAll: hideAll(ns)(defaultDialogicOptions),\n    resetAll: resetAll(ns)(defaultDialogicOptions),\n    // Timer commands\n    pause: pause(ns)(defaultDialogicOptions),\n    resume: resume(ns)(defaultDialogicOptions),\n    // State\n    exists: exists(ns)(defaultDialogicOptions),\n    getCount: getCount(ns),\n    // Timer state\n    isPaused: isPaused(ns)(defaultDialogicOptions),\n    getRemaining: getRemaining(ns)(defaultDialogicOptions),\n  };\n};\n","import { dialogical } from './dialogical';\n\nexport const dialog = dialogical({ ns: 'dialog' });\n","import { dialogical } from './dialogical';\n\nexport const notification = dialogical({\n  ns: 'notification',\n  queued: true,\n  timeout: 3000,\n});\n","/**\n * Utility script that uses an animation frame to pass the current remaining value\n * (which is utilized when setting `timeout`).\n */\n\nimport { DialogicInstance } from './types';\n\ntype RemainingProps = {\n  /**\n   * Dialogic instance: notification, dialog, or custom.\n   */\n  instance: DialogicInstance;\n\n  id?: string;\n  spawn?: string;\n\n  /**\n   * Set to true to return seconds instead of milliseconds.\n   */\n  roundToSeconds?: boolean;\n\n  /**\n   * Returns the remaining time as milliseconds. Returns `undefined` when the timer is not running (before and after the timer runs).\n   */\n  callback: (displayValue: number | undefined) => unknown;\n};\n\nexport const remaining = (props: RemainingProps) => {\n  let displayValue: number | undefined;\n  let reqId: number;\n  let isCanceled: boolean = false;\n  const identity = {\n    id: props.id,\n    spawn: props.spawn,\n  };\n\n  const update = () => {\n    const remainingValue = props.instance.getRemaining(identity);\n    if (displayValue !== remainingValue) {\n      displayValue =\n        remainingValue === undefined\n          ? remainingValue\n          : props.roundToSeconds\n          ? Math.round(Math.max(remainingValue, 0) / 1000)\n          : Math.max(remainingValue, 0);\n    }\n    props.callback(displayValue);\n    if (!props.instance.exists(identity)) {\n      window.cancelAnimationFrame(reqId);\n      isCanceled = true;\n    } else if (!isCanceled) {\n      reqId = window.requestAnimationFrame(update);\n    }\n  };\n  reqId = window.requestAnimationFrame(update);\n};\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","itemIndex","id","items","item","find","findItem","indexOf","createId","identityOptions","ns","spawn","filter","Boolean","join","store","initialState","actions","update","add","state","timer","states","map","refresh","remove","remaining","index","splice","removeItem","replace","newItem","removeAll","newItems","selectors","fns","getStore","fitem","just","nothing","undefined","getAll","itemsBySpawn","getCount","length","Stream","scan","patch","callback","isPaused","onAbort","onDone","promise","startTime","timeoutFn","timerId","appendStopTimeout","window","clearTimeout","appendPauseTimer","getRemaining","Date","getTime","TimerStore","start","duration","updateState","setTimeout","appendStartTimer","stop","appendStopTimer","pause","resume","minimumDuration","Math","max","appendResumeTimer","abort","getResultPromise","pipe","x","reduce","y","f","getStyleValue","domElement","prop","defaultView","document","style","getComputedStyle","getPropertyValue","MODE","applyTransitionStyles","styles","transitionStyle","Object","keys","forEach","key","createClassList","className","split","n","applyStylesForState","props","isEnterStep","getTransitionStyles","transitionDuration","applyNoDurationTransitionStyle","transitionClassNames","showStart","showEnd","hideStart","hideEnd","classList","removeTransitionClassNames","scrollTop","styleDurationToMs","durationStr","parsed","parseFloat","Number","isNaN","steps","nextStep","transition","mode","__transitionTimeoutId__","currentStep","durationStyleValue","durationValue","delayStyleValue","getDuration","localState","uid","TransitionStates","getMaybeItem","defaultDialogicOptions","getMergedIdentityOptions","filterBySpawn","filterFirstInQueue","nsItems","queuedCount","queueCount","dialogicOptions","queued","handleOptions","options","dialogic","passThroughOptions","copy","getPassThroughOptions","show","callbacks","willShow","willHide","didShow","didHide","timeout","MAX_VALUE","toString","transitionState","Default","existingItem","toggle","hide","replacingItem","Hiding","hideItem","validItems","getValidItems","all","commandOptions","getTimerSelectors","maybeItem","exists","allItems","filterById","resetAll","push","getOverridingTransitionOptions","hideAll","regularItems","queuedItems","current","transitionItem","deferredHideItem","dialogical","defaultId","defaultSpawn","dialog","notification","displayValue","reqId","isCanceled","identity","remainingValue","instance","roundToSeconds","round","requestAnimationFrame","cancelAnimationFrame","Displaying"],"mappings":"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"}