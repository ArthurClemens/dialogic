{"version":3,"file":"dialogic.js","sources":["../../../node_modules/tslib/tslib.es6.js","../src/utils.ts","../src/transition.ts","../src/state/store.ts","../src/state/timer.ts","../src/dialogic.ts","../src/dialogical.ts","../src/dialog.ts","../src/notification.ts","../src/remaining.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export const isClient = typeof document !== 'undefined';\nexport const isServer = !isClient;\n\ntype Fn = (args: any) => any;\n\nexport const pipe = (...fns: Fn[]) => (x: any) =>\n  fns.filter(Boolean).reduce((y, f) => f(y), x);\n\nexport const getStyleValue = ({\n  domElement,\n  prop,\n}: {\n  domElement: HTMLElement;\n  prop: string;\n}) => {\n  const defaultView = document.defaultView;\n  if (defaultView) {\n    const style = defaultView.getComputedStyle(domElement);\n    if (style) {\n      return style.getPropertyValue(prop);\n    }\n  }\n};\n","import { getStyleValue } from './utils';\nimport { Dialogic } from '../index';\n\nexport const MODE = {\n  SHOW: 'show',\n  HIDE: 'hide',\n};\n\ntype TransitionProps = {\n  domElement?: HTMLElement;\n  className?: string;\n  styles?: Dialogic.TransitionStyles | Dialogic.TransitionStylesFn;\n  __transitionTimeoutId__?: number;\n};\n\ntype TransitionClassNames = {\n  [key: string]: string[];\n  showStart: string[];\n  showEnd: string[];\n  hideStart: string[];\n  hideEnd: string[];\n};\n\ntype TransitionStep = 'showStart' | 'showEnd' | 'hideStart' | 'hideEnd';\ntype TransitionStyleState = 'default' | TransitionStep;\n\nconst removeTransitionClassNames = (\n  domElement: HTMLElement,\n  transitionClassNames: TransitionClassNames,\n) =>\n  domElement.classList.remove(\n    ...transitionClassNames.showStart,\n    ...transitionClassNames.showEnd,\n    ...transitionClassNames.hideStart,\n    ...transitionClassNames.hideEnd,\n  );\n\nconst applyTransitionStyles = (\n  domElement: HTMLElement,\n  step: TransitionStyleState,\n  styles: Dialogic.TransitionStyles,\n) => {\n  const transitionStyle = (styles[step] as CSSStyleDeclaration) || {};\n  Object.keys(transitionStyle).forEach((key: any) => {\n    const value = transitionStyle[key].toString();\n    domElement.style[key] = value;\n    // if (domElement.style[key] !== value) {\n    // \tconsole.warn(`Invalid style: ${key}: ${value} (${domElement.style[key]})`);\n    // }\n  });\n};\n\nconst applyNoDurationTransitionStyle = (domElement: HTMLElement) =>\n  (domElement.style.transitionDuration = '0ms');\n\nconst getTransitionStyles = (\n  domElement: HTMLElement,\n  styles: Dialogic.TransitionStyles | Dialogic.TransitionStylesFn,\n) => (typeof styles === 'function' ? styles(domElement) : styles) || {};\n\nconst createClassList = (className: string, step: string) =>\n  className.split(/ /).map((n: string) => `${n}-${step}`);\n\nconst applyStylesForState = (\n  domElement: HTMLElement,\n  props: TransitionProps,\n  step: TransitionStep,\n  isEnterStep?: boolean,\n) => {\n  if (props.styles) {\n    const styles = getTransitionStyles(domElement, props.styles);\n    applyTransitionStyles(domElement, 'default', styles);\n    isEnterStep && applyNoDurationTransitionStyle(domElement);\n    applyTransitionStyles(domElement, step, styles);\n  }\n\n  if (props.className) {\n    const transitionClassNames: TransitionClassNames = {\n      showStart: createClassList(props.className, 'show-start'),\n      showEnd: createClassList(props.className, 'show-end'),\n      hideStart: createClassList(props.className, 'hide-start'),\n      hideEnd: createClassList(props.className, 'hide-end'),\n    };\n    removeTransitionClassNames(domElement, transitionClassNames);\n    transitionClassNames &&\n      domElement.classList.add(...transitionClassNames[step]);\n  }\n\n  // reflow\n  domElement.scrollTop;\n};\n\nconst getDuration = (domElement: HTMLElement) => {\n  const durationStyleValue = getStyleValue({\n    domElement,\n    prop: 'transition-duration',\n  });\n  const durationValue =\n    durationStyleValue !== undefined\n      ? styleDurationToMs(durationStyleValue)\n      : 0;\n  const delayStyleValue = getStyleValue({\n    domElement,\n    prop: 'transition-delay',\n  });\n  const delayValue =\n    delayStyleValue !== undefined ? styleDurationToMs(delayStyleValue) : 0;\n  return durationValue + delayValue;\n};\n\ntype Step = {\n  nextStep?: TransitionStep;\n};\n\ntype Steps = {\n  showStart: Step;\n  showEnd: Step;\n  hideStart: Step;\n  hideEnd: Step;\n};\n\nconst steps: Steps = {\n  showStart: {\n    nextStep: 'showEnd',\n  },\n  showEnd: {\n    nextStep: undefined,\n  },\n  hideStart: {\n    nextStep: 'hideEnd',\n  },\n  hideEnd: {\n    nextStep: undefined,\n  },\n};\n\nexport const transition = (props: TransitionProps, mode?: string) => {\n  const domElement = props.domElement;\n  if (!domElement) {\n    return Promise.resolve('no domElement');\n  }\n  clearTimeout(props.__transitionTimeoutId__);\n\n  let currentStep: TransitionStep =\n    mode === MODE.SHOW ? 'showStart' : 'hideStart';\n\n  return new Promise(resolve => {\n    applyStylesForState(\n      domElement,\n      props,\n      currentStep,\n      currentStep === 'showStart',\n    );\n\n    setTimeout(() => {\n      const nextStep = steps[currentStep].nextStep;\n      if (nextStep) {\n        currentStep = nextStep;\n        applyStylesForState(domElement, props, currentStep);\n        // addEventListener sometimes hangs this function because it never finishes\n        // Using setTimeout instead of addEventListener gives more consistent results\n        const duration = getDuration(domElement);\n        props.__transitionTimeoutId__ = window.setTimeout(resolve, duration);\n      }\n    }, 0);\n  });\n};\n\nconst styleDurationToMs = (durationStr: string) => {\n  const parsed =\n    parseFloat(durationStr) * (durationStr.indexOf('ms') === -1 ? 1000 : 1);\n  return isNaN(parsed) ? 0 : parsed;\n};\n","import Stream from 'mithril/stream';\nimport { Dialogic } from '../..';\n\ntype PatchFn = (state: Dialogic.State) => Dialogic.State;\n\nconst findItem = (id: string, items: any[]) => {\n  return items.find(item => item.id === id);\n};\n\nconst itemIndex = (id: string, items: any[]) => {\n  const item = findItem(id, items);\n  return items.indexOf(item);\n};\n\nconst removeItem = (id: string, items: any[]) => {\n  const index = itemIndex(id, items);\n  if (index !== -1) {\n    items.splice(index, 1);\n  }\n  return items;\n};\n\nexport const createId = (\n  identityOptions: Dialogic.IdentityOptions,\n  ns: string,\n) => [ns, identityOptions.id, identityOptions.spawn].filter(Boolean).join('-');\n\nconst store = {\n  initialState: {\n    store: {},\n  },\n\n  actions: (update: Stream<PatchFn>) => {\n    return {\n      /**\n       * Add an item to the end of the list.\n       */\n      add: (ns: string, item: Dialogic.Item<unknown>) => {\n        update((state: Dialogic.State) => {\n          const items = state.store[ns] || [];\n          state.store[ns] = [...items, item as Dialogic.Item<unknown>];\n          if (item.timer) {\n            // When the timer state updates, refresh the store so that UI can pick up the change\n            item.timer.states.map(() => store.actions(update).refresh());\n          }\n          return state;\n        });\n      },\n\n      /**\n       * Removes the first item with a match on `id`.\n       */\n      remove: (ns: string, id: string) => {\n        update((state: Dialogic.State) => {\n          const items = state.store[ns] || [];\n          const remaining = removeItem(id, items);\n          state.store[ns] = remaining;\n          return state;\n        });\n      },\n\n      /**\n       * Replaces the first item with a match on `id` with a newItem.\n       */\n      replace: (ns: string, id: string, newItem: Dialogic.Item<unknown>) => {\n        update((state: Dialogic.State) => {\n          const items = state.store[ns] || [];\n          if (items) {\n            const index = itemIndex(id, items);\n            if (index !== -1) {\n              items[index] = newItem;\n              state.store[ns] = [...items];\n            }\n          }\n          return state;\n        });\n      },\n\n      /**\n       * Removes all items within a namespace.\n       */\n      removeAll: (ns: string) => {\n        update((state: Dialogic.State) => {\n          state.store[ns] = [];\n          return state;\n        });\n      },\n\n      /**\n       * Replaces all items within a namespace.\n       */\n      store: (ns: string, newItems: Dialogic.Item<unknown>[]) => {\n        update((state: Dialogic.State) => {\n          state.store[ns] = [...newItems];\n          return state;\n        });\n      },\n\n      refresh: () => {\n        update((state: Dialogic.State) => {\n          return {\n            ...state,\n          };\n        });\n      },\n    };\n  },\n\n  selectors: (states: Stream<Dialogic.State>) => {\n    const fns = {\n      getStore: () => {\n        const state = states();\n        return state.store;\n      },\n\n      find: <T>(ns: string, identityOptions: Dialogic.IdentityOptions) => {\n        const state = states();\n        const items = state.store[ns] || [];\n        const id = createId(identityOptions, ns);\n        const item = items.find(\n          (item: Dialogic.Item<unknown>) => item.id === id,\n        ) as Dialogic.Item<T>;\n        return item ? { just: item } : { nothing: undefined };\n      },\n\n      getAll: (ns: string, identityOptions?: Dialogic.IdentityOptions) => {\n        const state = states();\n        const items = state.store[ns] || [];\n        const spawn =\n          identityOptions !== undefined ? identityOptions.spawn : undefined;\n        const id =\n          identityOptions !== undefined ? identityOptions.id : undefined;\n        const itemsBySpawn =\n          spawn !== undefined\n            ? items.filter(item => item.identityOptions.spawn === spawn)\n            : items;\n        const itemsById =\n          id !== undefined\n            ? itemsBySpawn.filter(item => item.identityOptions.id === id)\n            : itemsBySpawn;\n        return itemsById;\n      },\n\n      getCount: (ns: string, identityOptions?: Dialogic.IdentityOptions) =>\n        fns.getAll(ns, identityOptions).length,\n    };\n\n    return fns;\n  },\n};\n\nconst update: Stream<PatchFn> = Stream<PatchFn>();\n\nexport const states: Dialogic.States = Stream.scan(\n  (state: Dialogic.State, patch: PatchFn) => patch(state),\n  {\n    ...store.initialState,\n  },\n  update,\n);\n\nexport const actions = {\n  ...store.actions(update),\n};\n\nexport const selectors: Dialogic.StateSelectors = {\n  ...store.selectors(states),\n};\n\n// states.map(state =>\n//   console.log(JSON.stringify(state, null, 2))\n// );\n","import Stream from 'mithril/stream';\nimport { Dialogic } from '../..';\n\ntype PatchFn = (state: Dialogic.TimerState) => Dialogic.TimerState;\n\nconst initialState = {\n  callback: () => {},\n  isPaused: false,\n  onAbort: () => {},\n  onDone: () => {},\n  promise: undefined,\n  remaining: undefined,\n  startTime: undefined,\n  timeoutFn: () => {},\n  timerId: undefined,\n};\n\nconst appendStartTimer = (\n  state: Dialogic.TimerState,\n  callback: Dialogic.TimerCallback,\n  duration: number,\n  updateState: () => any,\n) => {\n  const timeoutFn = () => {\n    callback();\n    state.onDone();\n    updateState();\n  };\n  return {\n    timeoutFn,\n    promise: new Promise<void>(resolve => {\n      state.onDone = () => resolve();\n      state.onAbort = () => resolve();\n    }),\n    ...(state.isPaused\n      ? {}\n      : {\n          startTime: new Date().getTime(),\n          timerId: window.setTimeout(timeoutFn, duration),\n          remaining: duration,\n        }),\n  };\n};\n\nconst appendStopTimeout = (state: Dialogic.TimerState) => {\n  window.clearTimeout(state.timerId);\n  return {\n    timerId: initialState.timerId,\n  };\n};\n\nconst appendStopTimer = (state: Dialogic.TimerState) => {\n  return {\n    ...appendStopTimeout(state),\n  };\n};\n\nconst appendPauseTimer = (state: Dialogic.TimerState) => {\n  return {\n    ...appendStopTimeout(state),\n    isPaused: true,\n    remaining: getRemaining(state),\n  };\n};\n\nconst appendResumeTimer = (\n  state: Dialogic.TimerState,\n  minimumDuration?: number,\n) => {\n  window.clearTimeout(state.timerId);\n  const remaining = minimumDuration\n    ? Math.max(state.remaining || 0, minimumDuration)\n    : state.remaining;\n  return {\n    startTime: new Date().getTime(),\n    isPaused: false,\n    remaining,\n    timerId: window.setTimeout(state.timeoutFn, remaining),\n  };\n};\n\nconst getRemaining = (state: Dialogic.TimerState) =>\n  state.remaining === 0 || state.remaining === undefined\n    ? state.remaining\n    : state.remaining - (new Date().getTime() - (state.startTime || 0));\n\nexport const Timer = () => {\n  const timer = {\n    initialState,\n    actions: (update: Stream<PatchFn>) => {\n      return {\n        start: (callback: Dialogic.TimerCallback, duration: number) => {\n          update((state: Dialogic.TimerState) => {\n            return {\n              ...state,\n              ...appendStopTimeout(state),\n              ...appendStartTimer(state, callback, duration, () =>\n                timer.actions(update).done(),\n              ),\n              ...(state.isPaused && appendPauseTimer(state)),\n            };\n          });\n        },\n\n        stop: () => {\n          update((state: Dialogic.TimerState) => {\n            return {\n              ...state,\n              ...appendStopTimer(state),\n              ...initialState,\n            };\n          });\n        },\n\n        pause: () => {\n          update((state: Dialogic.TimerState) => {\n            return {\n              ...state,\n              ...(!state.isPaused && appendPauseTimer(state)),\n            };\n          });\n        },\n\n        resume: (minimumDuration?: number) => {\n          update((state: Dialogic.TimerState) => {\n            return {\n              ...state,\n              ...(state.isPaused && appendResumeTimer(state, minimumDuration)),\n            };\n          });\n        },\n\n        abort: () => {\n          update((state: Dialogic.TimerState) => {\n            state.onAbort();\n            return {\n              ...state,\n              ...appendStopTimeout(state),\n            };\n          });\n        },\n\n        done: () => {\n          update((state: Dialogic.TimerState) => {\n            return initialState;\n          });\n        },\n\n        refresh: () => {\n          update((state: Dialogic.TimerState) => {\n            return {\n              ...state,\n            };\n          });\n        },\n      };\n    },\n\n    selectors: (states: Stream<Dialogic.TimerState>) => {\n      return {\n        isPaused: () => {\n          const state = states();\n          return state.isPaused;\n        },\n\n        getRemaining: () => {\n          const state = states();\n          return state.isPaused ? state.remaining : getRemaining(state);\n        },\n\n        getResultPromise: () => {\n          const state = states();\n          return state.promise;\n        },\n      };\n    },\n  };\n\n  const update: Stream<PatchFn> = Stream<PatchFn>();\n\n  const states: Dialogic.TimerStates = Stream.scan(\n    (state: Dialogic.TimerState, patch: PatchFn) => patch(state),\n    {\n      ...timer.initialState,\n    },\n    update,\n  );\n\n  const actions = {\n    ...timer.actions(update),\n  };\n\n  const selectors: Dialogic.TimerStateSelectors = {\n    ...timer.selectors(states),\n  };\n\n  // states.map(state =>\n  //   console.log(JSON.stringify(state, null, 2))\n  // );\n\n  return {\n    states,\n    actions,\n    selectors,\n  };\n};\n","import { transition, MODE } from './transition';\nimport { actions, selectors, createId } from './state/store';\nimport { Timer } from './state/timer';\nimport { Dialogic } from '../index';\nimport { pipe } from './utils';\n\nexport { states, actions, selectors } from './state/store';\n\nlet uid = 0;\nconst getUid = () => (uid === Number.MAX_VALUE ? 0 : uid++);\n\nconst transitionStates = {\n  default: 0,\n  displaying: 1,\n  hiding: 2,\n};\n\nconst getMaybeItem = <T>(ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (identityOptions?: Dialogic.IdentityOptions) =>\n  selectors.find<T>(\n    ns,\n    getMergedIdentityOptions(defaultDialogicOptions, identityOptions),\n  );\n\nconst filterBySpawn = <T>(identityOptions: Dialogic.IdentityOptions) => (\n  items: Dialogic.Item<T>[],\n) =>\n  identityOptions.spawn !== undefined\n    ? items.filter(item => item.identityOptions.spawn === identityOptions.spawn)\n    : items;\n\nconst filterById = <T>(identityOptions: Dialogic.IdentityOptions) => (\n  items: Dialogic.Item<T>[],\n) =>\n  identityOptions.id !== undefined\n    ? items.filter(item => item.identityOptions.id === identityOptions.id)\n    : items;\n\n/**\n * Gets a list of all non-queued items.\n * From the queued items only the first item is listed.\n * */\nconst filterFirstInQueue = <T>(nsItems: Dialogic.Item<T>[]) => {\n  let queuedCount = 0;\n  return nsItems\n    .map(item => ({\n      item,\n      queueCount: item.dialogicOptions.queued ? queuedCount++ : 0,\n    }))\n    .filter(({ queueCount }) => queueCount === 0)\n    .map(({ item }) => item);\n};\n\nexport const filterCandidates = (\n  ns: string,\n  items: Dialogic.NamespaceStore,\n  identityOptions: Dialogic.IdentityOptions,\n) => {\n  const nsItems = items[ns] || [];\n  if (nsItems.length == 0) {\n    return [];\n  }\n  return pipe(filterBySpawn(identityOptions), filterFirstInQueue)(nsItems);\n};\n\ntype TGetPassThroughOptions = <T>(options: Dialogic.Options<T>) => T;\n\nconst getPassThroughOptions: TGetPassThroughOptions = options => {\n  const copy = {\n    ...options,\n  };\n  delete copy.dialogic;\n  return copy;\n};\n\nconst getMergedIdentityOptions = (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  identityOptions: Dialogic.IdentityOptions = {},\n) =>\n  ({\n    id: identityOptions.id || defaultDialogicOptions.id,\n    spawn: identityOptions.spawn || defaultDialogicOptions.spawn,\n  } as Dialogic.IdentityOptions);\n\nconst handleOptions = <T>(\n  defaultDialogicOptions?: Dialogic.DefaultDialogicOptions,\n  options: Dialogic.Options<T> = {} as T,\n) => {\n  const identityOptions = {\n    id: options.dialogic ? options.dialogic.id : undefined,\n    spawn: options.dialogic ? options.dialogic.spawn : undefined,\n  };\n  const mergedIdentityOptions = getMergedIdentityOptions(\n    defaultDialogicOptions || ({} as Dialogic.DefaultDialogicOptions),\n    identityOptions,\n  );\n\n  const dialogicOptions: Dialogic.DialogicOptions<T> = {\n    ...defaultDialogicOptions,\n    ...options.dialogic,\n    __transitionTimeoutId__: 0,\n  };\n\n  const passThroughOptions = getPassThroughOptions(options);\n\n  return {\n    identityOptions: mergedIdentityOptions,\n    dialogicOptions,\n    passThroughOptions,\n  };\n};\n\nconst createInstance = <T>(ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (options: Dialogic.Options<T> = {} as T) => {\n  const {\n    identityOptions,\n    dialogicOptions,\n    passThroughOptions,\n  } = handleOptions(defaultDialogicOptions, options);\n\n  return new Promise(resolve => {\n    const callbacks: Dialogic.Callbacks<T> = {\n      willShow: (item: Dialogic.Item<T>) => {\n        if (dialogicOptions.willShow) {\n          dialogicOptions.willShow(item);\n        }\n        return resolve(item);\n      },\n      willHide: (item: Dialogic.Item<T>) => {\n        if (dialogicOptions.willHide) {\n          dialogicOptions.willHide(item);\n        }\n        return resolve(item);\n      },\n      didShow: (item: Dialogic.Item<T>) => {\n        if (dialogicOptions.didShow) {\n          dialogicOptions.didShow(item);\n        }\n        return resolve(item);\n      },\n      didHide: (item: Dialogic.Item<T>) => {\n        if (dialogicOptions.didHide) {\n          dialogicOptions.didHide(item);\n        }\n        return resolve(item);\n      },\n    };\n\n    const item: Dialogic.Item<T> = {\n      ns,\n      identityOptions,\n      dialogicOptions,\n      callbacks,\n      passThroughOptions,\n      id: createId(identityOptions, ns),\n      timer: dialogicOptions.timeout ? Timer() : undefined, // when timeout is undefined or 0\n      key: getUid().toString(), // Uniquely identify each item for keyed display\n      transitionState: transitionStates.default,\n    };\n\n    const maybeExistingItem: Dialogic.MaybeItem<T> = selectors.find<T>(\n      ns,\n      identityOptions,\n    );\n\n    if (maybeExistingItem.just && dialogicOptions.toggle) {\n      const hideResult = hide<T>(ns)(defaultDialogicOptions)(options);\n      return resolve(hideResult);\n    }\n\n    if (maybeExistingItem.just && !dialogicOptions.queued) {\n      const existingItem = maybeExistingItem.just;\n      // Preserve dialogicOptions\n      const dialogicOptions = existingItem.dialogicOptions;\n      const replacingItem = {\n        ...item,\n        key: existingItem.key,\n        transitionState: existingItem.transitionState,\n        dialogicOptions,\n      };\n      actions.replace(\n        ns,\n        existingItem.id,\n        replacingItem as Dialogic.Item<unknown>,\n      );\n    } else {\n      actions.add(ns, item as Dialogic.Item<unknown>);\n      // This will instantiate and draw the instance\n      // The instance will call `showDialog` in `onMount`\n    }\n\n    resolve(item);\n  });\n};\n\nexport const show = createInstance;\n\nexport const hide = <T>(ns: string) => (\n  defaultDialogicOptions?: Dialogic.DefaultDialogicOptions,\n) => (options?: Dialogic.Options<T>) => {\n  const {\n    identityOptions,\n    dialogicOptions,\n    passThroughOptions,\n  } = handleOptions(defaultDialogicOptions, options);\n  const maybeExistingItem: Dialogic.MaybeItem<T> = selectors.find<T>(\n    ns,\n    identityOptions,\n  );\n  if (maybeExistingItem.just) {\n    const existingItem = maybeExistingItem.just;\n    const item = {\n      ...existingItem,\n      dialogicOptions: {\n        ...existingItem.dialogicOptions,\n        ...dialogicOptions,\n      },\n      passThroughOptions: {\n        ...existingItem.passThroughOptions,\n        passThroughOptions,\n      },\n    };\n    actions.replace(ns, existingItem.id, item as Dialogic.Item<unknown>);\n    if (item.transitionState !== transitionStates.hiding) {\n      return hideItem(item);\n    } else {\n      return Promise.resolve(item);\n    }\n  }\n  return Promise.resolve();\n};\n\nexport const pause = (ns: string) => (\n  defaultDialogicOptions?: Dialogic.DefaultDialogicOptions,\n) => (identityOptions?: Dialogic.IdentityOptions) => {\n  const items = getValidItems(ns, identityOptions).filter(item => !!item.timer);\n  items.forEach(\n    (item: Dialogic.Item<unknown>) => item.timer && item.timer.actions.pause(),\n  );\n  return Promise.all(items);\n};\n\nexport const resume = (ns: string) => (\n  defaultDialogicOptions?: Dialogic.DefaultDialogicOptions,\n) => (commandOptions?: Dialogic.CommandOptions) => {\n  const options = commandOptions || {};\n  const identityOptions = {\n    id: options.id,\n    spawn: options.spawn,\n  };\n  const items = getValidItems(ns, identityOptions).filter(item => !!item.timer);\n  items.forEach(\n    (item: Dialogic.Item<unknown>) =>\n      item.timer && item.timer.actions.resume(options.minimumDuration),\n  );\n  return Promise.all(items);\n};\n\nexport const getTimerProperty = (\n  timerProp: 'isPaused' | 'getRemaining' | 'getResultPromise',\n  defaultValue: false | 0 | undefined,\n) => (ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (identityOptions?: Dialogic.IdentityOptions) => {\n  const maybeItem: Dialogic.MaybeItem<unknown> = getMaybeItem<unknown>(ns)(\n    defaultDialogicOptions,\n  )(identityOptions);\n  if (maybeItem.just) {\n    if (maybeItem.just && maybeItem.just.timer) {\n      return maybeItem.just.timer.selectors[timerProp]();\n    } else {\n      return defaultValue;\n    }\n  } else {\n    return defaultValue;\n  }\n};\n\nexport const isPaused = getTimerProperty('isPaused', false);\nexport const getRemaining = getTimerProperty('getRemaining', undefined);\n\nexport const exists = (ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (identityOptions: Dialogic.IdentityOptions) =>\n  !!getValidItems(ns, identityOptions).length;\n\ntype getValidItemsFn = <T>(\n  ns: string,\n  identityOptions?: Dialogic.IdentityOptions,\n) => Dialogic.Item<T>[];\n\nconst getValidItems: getValidItemsFn = (ns, identityOptions) => {\n  const allItems = selectors.getAll(ns);\n  let validItems;\n  if (identityOptions) {\n    validItems = pipe(\n      filterBySpawn(identityOptions),\n      filterById(identityOptions),\n    )(allItems);\n  } else {\n    validItems = allItems;\n  }\n  return validItems;\n};\n\nexport const resetAll = (ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (identityOptions?: Dialogic.IdentityOptions) => {\n  const validItems = getValidItems(ns, identityOptions);\n  const items: Dialogic.Item<unknown>[] = [];\n\n  validItems.forEach((item: Dialogic.Item<unknown>) => {\n    item.timer && item.timer.actions.abort();\n    items.push(item);\n  });\n\n  if (identityOptions) {\n    items.forEach((item: Dialogic.Item<unknown>) => {\n      actions.remove(ns, item.id);\n    });\n  } else {\n    actions.removeAll(ns);\n  }\n\n  return Promise.resolve(items);\n};\n\nconst getOverridingTransitionOptions = <T>(\n  item: Dialogic.Item<T>,\n  dialogicOptions: Dialogic.DialogicOptions<T>,\n) => {\n  return {\n    ...item,\n    dialogicOptions: {\n      ...item.dialogicOptions,\n      ...dialogicOptions,\n    },\n  };\n};\n\n/**\n * Triggers a `hideItem` for each item in the store.\n * Queued items: will trigger `hideItem` only for the first item, then reset the store.\n * Optional `dialogicOptions` may be passed with specific transition options. This comes in handy when all items should hide in the same way.\n */\nexport const hideAll = (ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (dialogicOptions?: Dialogic.DialogicOptions<unknown>) => {\n  const options = dialogicOptions || {};\n  const identityOptions: Dialogic.IdentityOptions = {\n    id: options.id,\n    spawn: options.spawn,\n  };\n  const validItems = getValidItems(ns, identityOptions);\n  const regularItems = validItems.filter(\n    (item: Dialogic.Item<unknown>) =>\n      !options.queued && !item.dialogicOptions.queued,\n  );\n  const queuedItems = validItems.filter(\n    (item: Dialogic.Item<unknown>) =>\n      options.queued || item.dialogicOptions.queued,\n  );\n\n  const items = [];\n\n  regularItems.forEach((item: Dialogic.Item<unknown>) =>\n    items.push(hideItem(getOverridingTransitionOptions(item, options))),\n  );\n\n  if (queuedItems.length > 0) {\n    const [current] = queuedItems;\n    // Make sure that any remaining items don't suddenly appear\n    actions.store(ns, [current]);\n    // Transition the current item\n    items.push(hideItem(getOverridingTransitionOptions(current, options)));\n  }\n\n  return Promise.all(items);\n};\n\nexport const getCount = (ns: string) => (\n  identityOptions?: Dialogic.IdentityOptions,\n) => selectors.getCount(ns, identityOptions);\n\nconst transitionItem = <T>(item: Dialogic.Item<T>, mode: string) =>\n  transition(item.dialogicOptions, mode);\n\nconst deferredHideItem = async function <T>(\n  item: Dialogic.Item<T>,\n  timer: Dialogic.Timer,\n  timeout: number,\n) {\n  timer.actions.start(() => hideItem(item), timeout);\n  return getTimerProperty('getResultPromise', undefined);\n};\n\nexport const showItem: Dialogic.InitiateItemTransitionFn = async function (\n  item,\n) {\n  if (item.callbacks.willShow) {\n    item.callbacks.willShow(item);\n  }\n  if (item.transitionState !== transitionStates.displaying) {\n    item.transitionState = transitionStates.displaying;\n    await transitionItem(item, MODE.SHOW);\n  }\n  if (item.callbacks.didShow) {\n    item.callbacks.didShow(item);\n  }\n  if (item.dialogicOptions.timeout && item.timer) {\n    await deferredHideItem(item, item.timer, item.dialogicOptions.timeout);\n  }\n  return Promise.resolve(item);\n};\n\nexport const hideItem: Dialogic.InitiateItemTransitionFn = async function (\n  item,\n) {\n  item.transitionState = transitionStates.hiding;\n  // Stop any running timer\n  if (item.timer) {\n    item.timer.actions.stop();\n  }\n  if (item.callbacks.willHide) {\n    item.callbacks.willHide(item);\n  }\n  await transitionItem(item, MODE.HIDE);\n  if (item.callbacks.didHide) {\n    item.callbacks.didHide(item);\n  }\n  const copy = {\n    ...item,\n  };\n  actions.remove(item.ns, item.id);\n  return Promise.resolve(copy);\n};\n\nexport const setDomElement = <T>(\n  domElement: HTMLElement,\n  item: Dialogic.Item<T>,\n) => {\n  item.dialogicOptions.domElement = domElement;\n};\n","import {\n  show,\n  hide,\n  hideAll,\n  resetAll,\n  getCount,\n  pause,\n  resume,\n  isPaused,\n  getRemaining,\n  exists,\n} from './dialogic';\nimport { Dialogic } from '../index';\n\nexport const dialogical = ({\n  ns,\n  queued,\n  timeout,\n}: {\n  ns: string;\n  queued?: boolean;\n  timeout?: number;\n}) => {\n  const defaultId = `default_${ns}`;\n  const defaultSpawn = `default_${ns}`;\n  const defaultDialogicOptions: Dialogic.DefaultDialogicOptions = {\n    id: defaultId,\n    spawn: defaultSpawn,\n    ...(queued && { queued }),\n    ...(timeout !== undefined && { timeout }),\n  };\n\n  return {\n    // Identification\n    ns,\n    defaultId,\n    defaultSpawn,\n    // Configuration\n    defaultDialogicOptions,\n    // Commands\n    show: show(ns)(defaultDialogicOptions),\n    hide: hide(ns)(defaultDialogicOptions),\n    hideAll: hideAll(ns)(defaultDialogicOptions),\n    resetAll: resetAll(ns)(defaultDialogicOptions),\n    // Timer commands\n    pause: pause(ns)(defaultDialogicOptions),\n    resume: resume(ns)(defaultDialogicOptions),\n    // State\n    exists: exists(ns)(defaultDialogicOptions),\n    getCount: getCount(ns),\n    // Timer state\n    isPaused: isPaused(ns)(defaultDialogicOptions),\n    getRemaining: getRemaining(ns)(defaultDialogicOptions),\n  };\n};\n","import { dialogical } from './dialogical';\n\nexport const dialog = dialogical({ ns: 'dialog' });\n","import { dialogical } from './dialogical';\n\nexport const notification = dialogical({\n  ns: 'notification',\n  queued: true,\n  timeout: 3000,\n});\n","/**\n * Utility script that uses an animation frame to pass the current remaining value\n * (which is utilized when setting `timeout`).\n */\n\nimport { Dialogic } from '../index';\n\nexport const remaining = (props: Dialogic.RemainingProps) => {\n  let displayValue: number | undefined = undefined;\n  let reqId: number;\n  let isCanceled: boolean = false;\n  const identity = {\n    id: props.id,\n    spawn: props.spawn,\n  };\n\n  const update = () => {\n    const remaining = props.instance.getRemaining(identity);\n    if (displayValue !== remaining) {\n      displayValue =\n        remaining === undefined\n          ? remaining\n          : props.roundToSeconds\n          ? Math.round(Math.max(remaining, 0) / 1000)\n          : Math.max(remaining, 0);\n    }\n    props.callback(displayValue);\n    if (!props.instance.exists(identity)) {\n      window.cancelAnimationFrame(reqId);\n      isCanceled = true;\n    } else if (!isCanceled) {\n      reqId = window.requestAnimationFrame(update);\n    }\n  };\n  reqId = window.requestAnimationFrame(update);\n};\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","pipe","fns","x","filter","Boolean","reduce","y","f","getStyleValue","domElement","prop","defaultView","document","style","getComputedStyle","getPropertyValue","MODE","applyTransitionStyles","styles","transitionStyle","Object","keys","forEach","key","toString","createClassList","className","split","map","n","applyStylesForState","props","isEnterStep","getTransitionStyles","transitionDuration","applyNoDurationTransitionStyle","transitionClassNames","showStart","showEnd","hideStart","hideEnd","classList","remove","removeTransitionClassNames","add","scrollTop","steps","nextStep","undefined","transition","mode","clearTimeout","__transitionTimeoutId__","currentStep","setTimeout","duration","durationStyleValue","durationValue","styleDurationToMs","delayStyleValue","getDuration","window","durationStr","parsed","parseFloat","indexOf","isNaN","itemIndex","id","items","item","find","findItem","createId","identityOptions","ns","spawn","join","store","initialState","actions","update","state","timer","states","refresh","remaining","index","splice","removeItem","replace","newItem","removeAll","newItems","selectors","getStore","just","nothing","getAll","itemsBySpawn","getCount","length","Stream","scan","patch","callback","isPaused","onAbort","onDone","promise","startTime","timeoutFn","timerId","appendStopTimeout","appendPauseTimer","getRemaining","Date","getTime","Timer","start","updateState","appendStartTimer","stop","appendStopTimer","pause","resume","minimumDuration","Math","max","appendResumeTimer","abort","getResultPromise","uid","transitionStates","filterBySpawn","filterFirstInQueue","nsItems","queuedCount","queueCount","dialogicOptions","queued","getMergedIdentityOptions","defaultDialogicOptions","handleOptions","options","dialogic","passThroughOptions","copy","getPassThroughOptions","show","callbacks","willShow","willHide","didShow","didHide","timeout","Number","MAX_VALUE","transitionState","maybeExistingItem","toggle","hideResult","hide","existingItem","replacingItem","hideItem","getValidItems","all","commandOptions","getTimerProperty","timerProp","defaultValue","maybeItem","getMaybeItem","exists","allItems","validItems","filterById","resetAll","push","getOverridingTransitionOptions","hideAll","regularItems","queuedItems","current","transitionItem","dialogical","defaultId","defaultSpawn","dialog","notification","reqId","displayValue","isCanceled","identity","instance","roundToSeconds","round","requestAnimationFrame","cancelAnimationFrame","deferredHideItem"],"mappings":"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"}