{"version":3,"file":"dialogic.js","sources":["../src/utils.ts","../src/transition.ts","../src/state/store.ts","../src/state/timer.ts","../src/dialogic.ts","../src/dialogical.ts","../src/dialog.ts","../src/notification.ts","../src/remaining.ts"],"sourcesContent":["export const isClient = typeof document !== 'undefined';\nexport const isServer = !isClient;\n\ntype Fn = (args: any) => any;\n\nexport const pipe = (...fns: Fn[]) => (x: any) =>\n  fns.filter(Boolean).reduce((y, f) => f(y), x);\n\nexport const getStyleValue = ({\n  domElement,\n  prop,\n}: {\n  domElement: HTMLElement;\n  prop: string;\n}) => {\n  const defaultView = document.defaultView;\n  if (defaultView) {\n    const style = defaultView.getComputedStyle(domElement);\n    if (style) {\n      return style.getPropertyValue(prop);\n    }\n  }\n};\n","import { getStyleValue } from './utils';\nimport { Dialogic } from '../index';\n\nexport const MODE = {\n  SHOW: 'show',\n  HIDE: 'hide',\n};\n\ntype TransitionProps = {\n  domElement?: HTMLElement;\n  className?: string;\n  styles?: Dialogic.TransitionStyles | Dialogic.TransitionStylesFn;\n  __transitionTimeoutId__?: number;\n};\n\ntype TransitionClassNames = {\n  [key: string]: string[];\n  showStart: string[];\n  showEnd: string[];\n  hideStart: string[];\n  hideEnd: string[];\n};\n\ntype TransitionStep = 'showStart' | 'showEnd' | 'hideStart' | 'hideEnd';\ntype TransitionStyleState = 'default' | TransitionStep;\n\nconst removeTransitionClassNames = (\n  domElement: HTMLElement,\n  transitionClassNames: TransitionClassNames,\n) =>\n  domElement.classList.remove(\n    ...transitionClassNames.showStart,\n    ...transitionClassNames.showEnd,\n    ...transitionClassNames.hideStart,\n    ...transitionClassNames.hideEnd,\n  );\n\nconst applyTransitionStyles = (\n  domElement: HTMLElement,\n  step: TransitionStyleState,\n  styles: Dialogic.TransitionStyles,\n) => {\n  const transitionStyle = (styles[step] as CSSStyleDeclaration) || {};\n  Object.keys(transitionStyle).forEach((key: any) => {\n    const value = transitionStyle[key].toString();\n    domElement.style[key] = value;\n    // if (domElement.style[key] !== value) {\n    // \tconsole.warn(`Invalid style: ${key}: ${value} (${domElement.style[key]})`);\n    // }\n  });\n};\n\nconst applyNoDurationTransitionStyle = (domElement: HTMLElement) =>\n  (domElement.style.transitionDuration = '0ms');\n\nconst getTransitionStyles = (\n  domElement: HTMLElement,\n  styles: Dialogic.TransitionStyles | Dialogic.TransitionStylesFn,\n) => (typeof styles === 'function' ? styles(domElement) : styles) || {};\n\nconst createClassList = (className: string, step: string) =>\n  className.split(/ /).map((n: string) => `${n}-${step}`);\n\nconst applyStylesForState = (\n  domElement: HTMLElement,\n  props: TransitionProps,\n  step: TransitionStep,\n  isEnterStep?: boolean,\n) => {\n  if (props.styles) {\n    const styles = getTransitionStyles(domElement, props.styles);\n    applyTransitionStyles(domElement, 'default', styles);\n    isEnterStep && applyNoDurationTransitionStyle(domElement);\n    applyTransitionStyles(domElement, step, styles);\n  }\n\n  if (props.className) {\n    const transitionClassNames: TransitionClassNames = {\n      showStart: createClassList(props.className, 'show-start'),\n      showEnd: createClassList(props.className, 'show-end'),\n      hideStart: createClassList(props.className, 'hide-start'),\n      hideEnd: createClassList(props.className, 'hide-end'),\n    };\n    removeTransitionClassNames(domElement, transitionClassNames);\n    transitionClassNames &&\n      domElement.classList.add(...transitionClassNames[step]);\n  }\n\n  // reflow\n  domElement.scrollTop;\n};\n\nconst getDuration = (domElement: HTMLElement) => {\n  const durationStyleValue = getStyleValue({\n    domElement,\n    prop: 'transition-duration',\n  });\n  const durationValue =\n    durationStyleValue !== undefined\n      ? styleDurationToMs(durationStyleValue)\n      : 0;\n  const delayStyleValue = getStyleValue({\n    domElement,\n    prop: 'transition-delay',\n  });\n  const delayValue =\n    delayStyleValue !== undefined ? styleDurationToMs(delayStyleValue) : 0;\n  return durationValue + delayValue;\n};\n\ntype Step = {\n  nextStep?: TransitionStep;\n};\n\ntype Steps = {\n  showStart: Step;\n  showEnd: Step;\n  hideStart: Step;\n  hideEnd: Step;\n};\n\nconst steps: Steps = {\n  showStart: {\n    nextStep: 'showEnd',\n  },\n  showEnd: {\n    nextStep: undefined,\n  },\n  hideStart: {\n    nextStep: 'hideEnd',\n  },\n  hideEnd: {\n    nextStep: undefined,\n  },\n};\n\nexport const transition = (props: TransitionProps, mode?: string) => {\n  const domElement = props.domElement;\n  if (!domElement) {\n    return Promise.resolve('no domElement');\n  }\n  clearTimeout(props.__transitionTimeoutId__);\n\n  let currentStep: TransitionStep =\n    mode === MODE.SHOW ? 'showStart' : 'hideStart';\n\n  return new Promise(resolve => {\n    applyStylesForState(\n      domElement,\n      props,\n      currentStep,\n      currentStep === 'showStart',\n    );\n\n    setTimeout(() => {\n      const nextStep = steps[currentStep].nextStep;\n      if (nextStep) {\n        currentStep = nextStep;\n        applyStylesForState(domElement, props, currentStep);\n        // addEventListener sometimes hangs this function because it never finishes\n        // Using setTimeout instead of addEventListener gives more consistent results\n        const duration = getDuration(domElement);\n        props.__transitionTimeoutId__ = setTimeout(resolve, duration);\n      }\n    }, 0);\n  });\n};\n\nconst styleDurationToMs = (durationStr: string) => {\n  const parsed =\n    parseFloat(durationStr) * (durationStr.indexOf('ms') === -1 ? 1000 : 1);\n  return isNaN(parsed) ? 0 : parsed;\n};\n","import Stream from 'mithril/stream';\nimport { Dialogic } from '../..';\n\ntype PatchFn = (state: Dialogic.State) => Dialogic.State;\n\nconst findItem = (id: string, items: any[]) => {\n  return items.find(item => item.id === id);\n};\n\nconst itemIndex = (id: string, items: any[]) => {\n  const item = findItem(id, items);\n  return items.indexOf(item);\n};\n\nconst removeItem = (id: string, items: any[]) => {\n  const index = itemIndex(id, items);\n  if (index !== -1) {\n    items.splice(index, 1);\n  }\n  return items;\n};\n\nexport const createId = (\n  identityOptions: Dialogic.IdentityOptions,\n  ns: string,\n) => [ns, identityOptions.id, identityOptions.spawn].filter(Boolean).join('-');\n\nconst store = {\n  initialState: {\n    store: {},\n  },\n\n  actions: (update: Stream<PatchFn>) => {\n    return {\n      /**\n       * Add an item to the end of the list.\n       */\n      add: (ns: string, item: Dialogic.Item<unknown>) => {\n        update((state: Dialogic.State) => {\n          const items = state.store[ns] || [];\n          state.store[ns] = [...items, item as Dialogic.Item<unknown>];\n          if (item.timer) {\n            // When the timer state updates, refresh the store so that UI can pick up the change\n            item.timer.states.map(() => store.actions(update).refresh());\n          }\n          return state;\n        });\n      },\n\n      /**\n       * Removes the first item with a match on `id`.\n       */\n      remove: (ns: string, id: string) => {\n        update((state: Dialogic.State) => {\n          const items = state.store[ns] || [];\n          const remaining = removeItem(id, items);\n          state.store[ns] = remaining;\n          return state;\n        });\n      },\n\n      /**\n       * Replaces the first item with a match on `id` with a newItem.\n       */\n      replace: (ns: string, id: string, newItem: Dialogic.Item<unknown>) => {\n        update((state: Dialogic.State) => {\n          const items = state.store[ns] || [];\n          if (items) {\n            const index = itemIndex(id, items);\n            if (index !== -1) {\n              items[index] = newItem;\n              state.store[ns] = [...items];\n            }\n          }\n          return state;\n        });\n      },\n\n      /**\n       * Removes all items within a namespace.\n       */\n      removeAll: (ns: string) => {\n        update((state: Dialogic.State) => {\n          state.store[ns] = [];\n          return state;\n        });\n      },\n\n      /**\n       * Replaces all items within a namespace.\n       */\n      store: (ns: string, newItems: Dialogic.Item<unknown>[]) => {\n        update((state: Dialogic.State) => {\n          state.store[ns] = [...newItems];\n          return state;\n        });\n      },\n\n      refresh: () => {\n        update((state: Dialogic.State) => {\n          return {\n            ...state,\n          };\n        });\n      },\n    };\n  },\n\n  selectors: (states: Stream<Dialogic.State>) => {\n    const fns = {\n      getStore: () => {\n        const state = states();\n        return state.store;\n      },\n\n      find: <T>(ns: string, identityOptions: Dialogic.IdentityOptions) => {\n        const state = states();\n        const items = state.store[ns] || [];\n        const id = createId(identityOptions, ns);\n        const item = items.find(\n          (item: Dialogic.Item<unknown>) => item.id === id,\n        ) as Dialogic.Item<T>;\n        return item ? { just: item } : { nothing: undefined };\n      },\n\n      getAll: (ns: string, identityOptions?: Dialogic.IdentityOptions) => {\n        const state = states();\n        const items = state.store[ns] || [];\n        const spawn =\n          identityOptions !== undefined ? identityOptions.spawn : undefined;\n        const id =\n          identityOptions !== undefined ? identityOptions.id : undefined;\n        const itemsBySpawn =\n          spawn !== undefined\n            ? items.filter(item => item.identityOptions.spawn === spawn)\n            : items;\n        const itemsById =\n          id !== undefined\n            ? itemsBySpawn.filter(item => item.identityOptions.id === id)\n            : itemsBySpawn;\n        return itemsById;\n      },\n\n      getCount: (ns: string, identityOptions?: Dialogic.IdentityOptions) =>\n        fns.getAll(ns, identityOptions).length,\n    };\n\n    return fns;\n  },\n};\n\nconst update: Stream<PatchFn> = Stream<PatchFn>();\n\nexport const states: Dialogic.States = Stream.scan(\n  (state: Dialogic.State, patch: PatchFn) => patch(state),\n  {\n    ...store.initialState,\n  },\n  update,\n);\n\nexport const actions = {\n  ...store.actions(update),\n};\n\nexport const selectors: Dialogic.StateSelectors = {\n  ...store.selectors(states),\n};\n\n// states.map(state =>\n//   console.log(JSON.stringify(state, null, 2))\n// );\n","import Stream from 'mithril/stream';\nimport { Dialogic } from '../..';\n\ntype PatchFn = (state: Dialogic.TimerState) => Dialogic.TimerState;\n\nconst initialState = {\n  callback: () => {},\n  isPaused: false,\n  onAbort: () => {},\n  onDone: () => {},\n  promise: undefined,\n  remaining: undefined,\n  startTime: undefined,\n  timeoutFn: () => {},\n  timerId: undefined,\n};\n\nconst appendStartTimer = (\n  state: Dialogic.TimerState,\n  callback: Dialogic.TimerCallback,\n  duration: number,\n  updateState: () => any,\n) => {\n  const timeoutFn = () => {\n    callback();\n    state.onDone();\n    updateState();\n  };\n  return {\n    timeoutFn,\n    promise: new Promise<void>(resolve => {\n      state.onDone = () => resolve();\n      state.onAbort = () => resolve();\n    }),\n    ...(state.isPaused\n      ? {}\n      : {\n          startTime: new Date().getTime(),\n          timerId: window.setTimeout(timeoutFn, duration),\n          remaining: duration,\n        }),\n  };\n};\n\nconst appendStopTimeout = (state: Dialogic.TimerState) => {\n  window.clearTimeout(state.timerId);\n  return {\n    timerId: initialState.timerId,\n  };\n};\n\nconst appendStopTimer = (state: Dialogic.TimerState) => {\n  return {\n    ...appendStopTimeout(state),\n  };\n};\n\nconst appendPauseTimer = (state: Dialogic.TimerState) => {\n  return {\n    ...appendStopTimeout(state),\n    isPaused: true,\n    remaining: getRemaining(state),\n  };\n};\n\nconst appendResumeTimer = (\n  state: Dialogic.TimerState,\n  minimumDuration?: number,\n) => {\n  window.clearTimeout(state.timerId);\n  const remaining = minimumDuration\n    ? Math.max(state.remaining || 0, minimumDuration)\n    : state.remaining;\n  return {\n    startTime: new Date().getTime(),\n    isPaused: false,\n    remaining,\n    timerId: window.setTimeout(state.timeoutFn, remaining),\n  };\n};\n\nconst getRemaining = (state: Dialogic.TimerState) =>\n  state.remaining === 0 || state.remaining === undefined\n    ? state.remaining\n    : state.remaining - (new Date().getTime() - (state.startTime || 0));\n\nexport const Timer = () => {\n  const timer = {\n    initialState,\n    actions: (update: Stream<PatchFn>) => {\n      return {\n        start: (callback: Dialogic.TimerCallback, duration: number) => {\n          update((state: Dialogic.TimerState) => {\n            return {\n              ...state,\n              ...appendStopTimeout(state),\n              ...appendStartTimer(state, callback, duration, () =>\n                timer.actions(update).done(),\n              ),\n              ...(state.isPaused && appendPauseTimer(state)),\n            };\n          });\n        },\n\n        stop: () => {\n          update((state: Dialogic.TimerState) => {\n            return {\n              ...state,\n              ...appendStopTimer(state),\n              ...initialState,\n            };\n          });\n        },\n\n        pause: () => {\n          update((state: Dialogic.TimerState) => {\n            return {\n              ...state,\n              ...(!state.isPaused && appendPauseTimer(state)),\n            };\n          });\n        },\n\n        resume: (minimumDuration?: number) => {\n          update((state: Dialogic.TimerState) => {\n            return {\n              ...state,\n              ...(state.isPaused && appendResumeTimer(state, minimumDuration)),\n            };\n          });\n        },\n\n        abort: () => {\n          update((state: Dialogic.TimerState) => {\n            state.onAbort();\n            return {\n              ...state,\n              ...appendStopTimeout(state),\n            };\n          });\n        },\n\n        done: () => {\n          update((state: Dialogic.TimerState) => {\n            return initialState;\n          });\n        },\n\n        refresh: () => {\n          update((state: Dialogic.TimerState) => {\n            return {\n              ...state,\n            };\n          });\n        },\n      };\n    },\n\n    selectors: (states: Stream<Dialogic.TimerState>) => {\n      return {\n        isPaused: () => {\n          const state = states();\n          return state.isPaused;\n        },\n\n        getRemaining: () => {\n          const state = states();\n          return state.isPaused ? state.remaining : getRemaining(state);\n        },\n\n        getResultPromise: () => {\n          const state = states();\n          return state.promise;\n        },\n      };\n    },\n  };\n\n  const update: Stream<PatchFn> = Stream<PatchFn>();\n\n  const states: Dialogic.TimerStates = Stream.scan(\n    (state: Dialogic.TimerState, patch: PatchFn) => patch(state),\n    {\n      ...timer.initialState,\n    },\n    update,\n  );\n\n  const actions = {\n    ...timer.actions(update),\n  };\n\n  const selectors: Dialogic.TimerStateSelectors = {\n    ...timer.selectors(states),\n  };\n\n  // states.map(state =>\n  //   console.log(JSON.stringify(state, null, 2))\n  // );\n\n  return {\n    states,\n    actions,\n    selectors,\n  };\n};\n","import { transition, MODE } from './transition';\nimport { actions, selectors, createId } from './state/store';\nimport { Timer } from './state/timer';\nimport { Dialogic } from '../index';\nimport { pipe } from './utils';\n\nexport { states, actions, selectors } from './state/store';\n\nlet uid = 0;\nconst getUid = () => (uid === Number.MAX_VALUE ? 0 : uid++);\n\nconst transitionStates = {\n  default: 0,\n  displaying: 1,\n  hiding: 2,\n};\n\nconst getMaybeItem = <T>(ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (identityOptions?: Dialogic.IdentityOptions) =>\n  selectors.find<T>(\n    ns,\n    getMergedIdentityOptions(defaultDialogicOptions, identityOptions),\n  );\n\nconst filterBySpawn = <T>(identityOptions: Dialogic.IdentityOptions) => (\n  items: Dialogic.Item<T>[],\n) =>\n  identityOptions.spawn !== undefined\n    ? items.filter(item => item.identityOptions.spawn === identityOptions.spawn)\n    : items;\n\nconst filterById = <T>(identityOptions: Dialogic.IdentityOptions) => (\n  items: Dialogic.Item<T>[],\n) =>\n  identityOptions.id !== undefined\n    ? items.filter(item => item.identityOptions.id === identityOptions.id)\n    : items;\n\n/**\n * Gets a list of all non-queued items.\n * From the queued items only the first item is listed.\n * */\nconst filterFirstInQueue = <T>(nsItems: Dialogic.Item<T>[]) => {\n  let queuedCount = 0;\n  return nsItems\n    .map(item => ({\n      item,\n      queueCount: item.dialogicOptions.queued ? queuedCount++ : 0,\n    }))\n    .filter(({ queueCount }) => queueCount === 0)\n    .map(({ item }) => item);\n};\n\nexport const filterCandidates = (\n  ns: string,\n  items: Dialogic.NamespaceStore,\n  identityOptions: Dialogic.IdentityOptions,\n) => {\n  const nsItems = items[ns] || [];\n  if (nsItems.length == 0) {\n    return [];\n  }\n  return pipe(filterBySpawn(identityOptions), filterFirstInQueue)(nsItems);\n};\n\ntype TGetPassThroughOptions = <T>(options: Dialogic.Options<T>) => T;\n\nconst getPassThroughOptions: TGetPassThroughOptions = options => {\n  const copy = {\n    ...options,\n  };\n  delete copy.dialogic;\n  return copy;\n};\n\nconst getMergedIdentityOptions = (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n  identityOptions: Dialogic.IdentityOptions = {},\n) =>\n  ({\n    id: identityOptions.id || defaultDialogicOptions.id,\n    spawn: identityOptions.spawn || defaultDialogicOptions.spawn,\n  } as Dialogic.IdentityOptions);\n\nconst handleOptions = <T>(\n  defaultDialogicOptions?: Dialogic.DefaultDialogicOptions,\n  options: Dialogic.Options<T> = {} as T,\n) => {\n  const identityOptions = {\n    id: options.dialogic ? options.dialogic.id : undefined,\n    spawn: options.dialogic ? options.dialogic.spawn : undefined,\n  };\n  const mergedIdentityOptions = getMergedIdentityOptions(\n    defaultDialogicOptions || ({} as Dialogic.DefaultDialogicOptions),\n    identityOptions,\n  );\n\n  const dialogicOptions: Dialogic.DialogicOptions<T> = {\n    ...defaultDialogicOptions,\n    ...options.dialogic,\n    __transitionTimeoutId__: 0,\n  };\n\n  const passThroughOptions = getPassThroughOptions(options);\n\n  return {\n    identityOptions: mergedIdentityOptions,\n    dialogicOptions,\n    passThroughOptions,\n  };\n};\n\nconst createInstance = <T>(ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (options: Dialogic.Options<T> = {} as T) => {\n  const {\n    identityOptions,\n    dialogicOptions,\n    passThroughOptions,\n  } = handleOptions(defaultDialogicOptions, options);\n\n  return new Promise(resolve => {\n    const callbacks: Dialogic.Callbacks<T> = {\n      willShow: (item: Dialogic.Item<T>) => {\n        if (dialogicOptions.willShow) {\n          dialogicOptions.willShow(item);\n        }\n        return resolve(item);\n      },\n      willHide: (item: Dialogic.Item<T>) => {\n        if (dialogicOptions.willHide) {\n          dialogicOptions.willHide(item);\n        }\n        return resolve(item);\n      },\n      didShow: (item: Dialogic.Item<T>) => {\n        if (dialogicOptions.didShow) {\n          dialogicOptions.didShow(item);\n        }\n        return resolve(item);\n      },\n      didHide: (item: Dialogic.Item<T>) => {\n        if (dialogicOptions.didHide) {\n          dialogicOptions.didHide(item);\n        }\n        return resolve(item);\n      },\n    };\n\n    const item: Dialogic.Item<T> = {\n      ns,\n      identityOptions,\n      dialogicOptions,\n      callbacks,\n      passThroughOptions,\n      id: createId(identityOptions, ns),\n      timer: dialogicOptions.timeout ? Timer() : undefined, // when timeout is undefined or 0\n      key: getUid().toString(), // Uniquely identify each item for keyed display\n      transitionState: transitionStates.default,\n    };\n\n    const maybeExistingItem: Dialogic.MaybeItem<T> = selectors.find<T>(\n      ns,\n      identityOptions,\n    );\n\n    if (maybeExistingItem.just && dialogicOptions.toggle) {\n      const hideResult = hide<T>(ns)(defaultDialogicOptions)(options);\n      return resolve(hideResult);\n    }\n\n    if (maybeExistingItem.just && !dialogicOptions.queued) {\n      const existingItem = maybeExistingItem.just;\n      // Preserve dialogicOptions\n      const dialogicOptions = existingItem.dialogicOptions;\n      const replacingItem = {\n        ...item,\n        key: existingItem.key,\n        transitionState: existingItem.transitionState,\n        dialogicOptions,\n      };\n      actions.replace(\n        ns,\n        existingItem.id,\n        replacingItem as Dialogic.Item<unknown>,\n      );\n    } else {\n      actions.add(ns, item as Dialogic.Item<unknown>);\n      // This will instantiate and draw the instance\n      // The instance will call `showDialog` in `onMount`\n    }\n\n    resolve(item);\n  });\n};\n\nexport const show = createInstance;\n\nexport const hide = <T>(ns: string) => (\n  defaultDialogicOptions?: Dialogic.DefaultDialogicOptions,\n) => (options?: Dialogic.Options<T>) => {\n  const {\n    identityOptions,\n    dialogicOptions,\n    passThroughOptions,\n  } = handleOptions(defaultDialogicOptions, options);\n  const maybeExistingItem: Dialogic.MaybeItem<T> = selectors.find<T>(\n    ns,\n    identityOptions,\n  );\n  if (maybeExistingItem.just) {\n    const existingItem = maybeExistingItem.just;\n    const item = {\n      ...existingItem,\n      dialogicOptions: {\n        ...existingItem.dialogicOptions,\n        ...dialogicOptions,\n      },\n      passThroughOptions: {\n        ...existingItem.passThroughOptions,\n        passThroughOptions,\n      },\n    };\n    actions.replace(ns, existingItem.id, item as Dialogic.Item<unknown>);\n    if (item.transitionState !== transitionStates.hiding) {\n      return hideItem(item);\n    } else {\n      return Promise.resolve(item);\n    }\n  }\n  return Promise.resolve();\n};\n\nexport const pause = (ns: string) => (\n  defaultDialogicOptions?: Dialogic.DefaultDialogicOptions,\n) => (identityOptions?: Dialogic.IdentityOptions) => {\n  const items = getValidItems(ns, identityOptions).filter(item => !!item.timer);\n  items.forEach(\n    (item: Dialogic.Item<unknown>) => item.timer && item.timer.actions.pause(),\n  );\n  return Promise.all(items);\n};\n\nexport const resume = (ns: string) => (\n  defaultDialogicOptions?: Dialogic.DefaultDialogicOptions,\n) => (commandOptions?: Dialogic.CommandOptions) => {\n  const options = commandOptions || {};\n  const identityOptions = {\n    id: options.id,\n    spawn: options.spawn,\n  };\n  const items = getValidItems(ns, identityOptions).filter(item => !!item.timer);\n  items.forEach(\n    (item: Dialogic.Item<unknown>) =>\n      item.timer && item.timer.actions.resume(options.minimumDuration),\n  );\n  return Promise.all(items);\n};\n\nexport const getTimerProperty = (\n  timerProp: 'isPaused' | 'getRemaining' | 'getResultPromise',\n  defaultValue: false | 0 | undefined,\n) => (ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (identityOptions?: Dialogic.IdentityOptions) => {\n  const maybeItem: Dialogic.MaybeItem<unknown> = getMaybeItem<unknown>(ns)(\n    defaultDialogicOptions,\n  )(identityOptions);\n  if (maybeItem.just) {\n    if (maybeItem.just && maybeItem.just.timer) {\n      return maybeItem.just.timer.selectors[timerProp]();\n    } else {\n      return defaultValue;\n    }\n  } else {\n    return defaultValue;\n  }\n};\n\nexport const isPaused = getTimerProperty('isPaused', false);\nexport const getRemaining = getTimerProperty('getRemaining', undefined);\n\nexport const exists = (ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (identityOptions: Dialogic.IdentityOptions) =>\n  !!getValidItems(ns, identityOptions).length;\n\ntype getValidItemsFn = <T>(\n  ns: string,\n  identityOptions?: Dialogic.IdentityOptions,\n) => Dialogic.Item<T>[];\n\nconst getValidItems: getValidItemsFn = (ns, identityOptions) => {\n  const allItems = selectors.getAll(ns);\n  let validItems;\n  if (identityOptions) {\n    validItems = pipe(\n      filterBySpawn(identityOptions),\n      filterById(identityOptions),\n    )(allItems);\n  } else {\n    validItems = allItems;\n  }\n  return validItems;\n};\n\nexport const resetAll = (ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (identityOptions?: Dialogic.IdentityOptions) => {\n  const validItems = getValidItems(ns, identityOptions);\n  const items: Dialogic.Item<unknown>[] = [];\n\n  validItems.forEach((item: Dialogic.Item<unknown>) => {\n    item.timer && item.timer.actions.abort();\n    items.push(item);\n  });\n\n  if (identityOptions) {\n    items.forEach((item: Dialogic.Item<unknown>) => {\n      actions.remove(ns, item.id);\n    });\n  } else {\n    actions.removeAll(ns);\n  }\n\n  return Promise.resolve(items);\n};\n\nconst getOverridingTransitionOptions = <T>(\n  item: Dialogic.Item<T>,\n  dialogicOptions: Dialogic.DialogicOptions<T>,\n) => {\n  return {\n    ...item,\n    dialogicOptions: {\n      ...item.dialogicOptions,\n      ...dialogicOptions,\n    },\n  };\n};\n\n/**\n * Triggers a `hideItem` for each item in the store.\n * Queued items: will trigger `hideItem` only for the first item, then reset the store.\n * Optional `dialogicOptions` may be passed with specific transition options. This comes in handy when all items should hide in the same way.\n */\nexport const hideAll = (ns: string) => (\n  defaultDialogicOptions: Dialogic.DefaultDialogicOptions,\n) => (dialogicOptions?: Dialogic.DialogicOptions<unknown>) => {\n  const options = dialogicOptions || {};\n  const identityOptions: Dialogic.IdentityOptions = {\n    id: options.id,\n    spawn: options.spawn,\n  };\n  const validItems = getValidItems(ns, identityOptions);\n  const regularItems = validItems.filter(\n    (item: Dialogic.Item<unknown>) =>\n      !options.queued && !item.dialogicOptions.queued,\n  );\n  const queuedItems = validItems.filter(\n    (item: Dialogic.Item<unknown>) =>\n      options.queued || item.dialogicOptions.queued,\n  );\n\n  const items = [];\n\n  regularItems.forEach((item: Dialogic.Item<unknown>) =>\n    items.push(hideItem(getOverridingTransitionOptions(item, options))),\n  );\n\n  if (queuedItems.length > 0) {\n    const [current] = queuedItems;\n    // Make sure that any remaining items don't suddenly appear\n    actions.store(ns, [current]);\n    // Transition the current item\n    items.push(hideItem(getOverridingTransitionOptions(current, options)));\n  }\n\n  return Promise.all(items);\n};\n\nexport const getCount = (ns: string) => (\n  identityOptions?: Dialogic.IdentityOptions,\n) => selectors.getCount(ns, identityOptions);\n\nconst transitionItem = <T>(item: Dialogic.Item<T>, mode: string) =>\n  transition(item.dialogicOptions, mode);\n\nconst deferredHideItem = async function <T>(\n  item: Dialogic.Item<T>,\n  timer: Dialogic.Timer,\n  timeout: number,\n) {\n  timer.actions.start(() => hideItem(item), timeout);\n  return getTimerProperty('getResultPromise', undefined);\n};\n\nexport const showItem: Dialogic.InitiateItemTransitionFn = async function (\n  item,\n) {\n  if (item.callbacks.willShow) {\n    item.callbacks.willShow(item);\n  }\n  if (item.transitionState !== transitionStates.displaying) {\n    item.transitionState = transitionStates.displaying;\n    await transitionItem(item, MODE.SHOW);\n  }\n  if (item.callbacks.didShow) {\n    item.callbacks.didShow(item);\n  }\n  if (item.dialogicOptions.timeout && item.timer) {\n    await deferredHideItem(item, item.timer, item.dialogicOptions.timeout);\n  }\n  return Promise.resolve(item);\n};\n\nexport const hideItem: Dialogic.InitiateItemTransitionFn = async function (\n  item,\n) {\n  item.transitionState = transitionStates.hiding;\n  // Stop any running timer\n  if (item.timer) {\n    item.timer.actions.stop();\n  }\n  if (item.callbacks.willHide) {\n    item.callbacks.willHide(item);\n  }\n  await transitionItem(item, MODE.HIDE);\n  if (item.callbacks.didHide) {\n    item.callbacks.didHide(item);\n  }\n  const copy = {\n    ...item,\n  };\n  actions.remove(item.ns, item.id);\n  return Promise.resolve(copy);\n};\n\nexport const setDomElement = <T>(\n  domElement: HTMLElement,\n  item: Dialogic.Item<T>,\n) => {\n  item.dialogicOptions.domElement = domElement;\n};\n","import {\n  show,\n  hide,\n  hideAll,\n  resetAll,\n  getCount,\n  pause,\n  resume,\n  isPaused,\n  getRemaining,\n  exists,\n} from './dialogic';\nimport { Dialogic } from '../index';\n\nexport const dialogical = ({\n  ns,\n  queued,\n  timeout,\n}: {\n  ns: string;\n  queued?: boolean;\n  timeout?: number;\n}) => {\n  const defaultId = `default_${ns}`;\n  const defaultSpawn = `default_${ns}`;\n  const defaultDialogicOptions: Dialogic.DefaultDialogicOptions = {\n    id: defaultId,\n    spawn: defaultSpawn,\n    ...(queued && { queued }),\n    ...(timeout !== undefined && { timeout }),\n  };\n\n  return {\n    // Identification\n    ns,\n    defaultId,\n    defaultSpawn,\n    // Configuration\n    defaultDialogicOptions,\n    // Commands\n    show: show(ns)(defaultDialogicOptions),\n    hide: hide(ns)(defaultDialogicOptions),\n    hideAll: hideAll(ns)(defaultDialogicOptions),\n    resetAll: resetAll(ns)(defaultDialogicOptions),\n    // Timer commands\n    pause: pause(ns)(defaultDialogicOptions),\n    resume: resume(ns)(defaultDialogicOptions),\n    // State\n    exists: exists(ns)(defaultDialogicOptions),\n    getCount: getCount(ns),\n    // Timer state\n    isPaused: isPaused(ns)(defaultDialogicOptions),\n    getRemaining: getRemaining(ns)(defaultDialogicOptions),\n  };\n};\n","import { dialogical } from './dialogical';\n\nexport const dialog = dialogical({ ns: 'dialog' });\n","import { dialogical } from './dialogical';\n\nexport const notification = dialogical({\n  ns: 'notification',\n  queued: true,\n  timeout: 3000,\n});\n","/**\n * Utility script that uses an animation frame to pass the current remaining value\n * (which is utilized when setting `timeout`).\n */\n\nimport { Dialogic } from '../index';\n\nexport const remaining = (props: Dialogic.RemainingProps) => {\n  let displayValue: number | undefined = undefined;\n  let reqId: number;\n  let isCanceled: boolean = false;\n  const identity = {\n    id: props.id,\n    spawn: props.spawn,\n  };\n\n  const update = () => {\n    const remaining = props.instance.getRemaining(identity);\n    if (displayValue !== remaining) {\n      displayValue =\n        remaining === undefined\n          ? remaining\n          : props.roundToSeconds\n          ? Math.round(Math.max(remaining, 0) / 1000)\n          : Math.max(remaining, 0);\n    }\n    props.callback(displayValue);\n    if (!props.instance.exists(identity)) {\n      window.cancelAnimationFrame(reqId);\n      isCanceled = true;\n    } else if (!isCanceled) {\n      reqId = window.requestAnimationFrame(update);\n    }\n  };\n  reqId = window.requestAnimationFrame(update);\n};\n"],"names":["pipe","fns","x","filter","Boolean","reduce","y","f","getStyleValue","domElement","prop","defaultView","document","style","getComputedStyle","getPropertyValue","MODE","applyTransitionStyles","step","styles","transitionStyle","Object","keys","forEach","key","value","toString","createClassList","className","split","map","n","applyStylesForState","props","isEnterStep","getTransitionStyles","transitionDuration","applyNoDurationTransitionStyle","transitionClassNames","showStart","showEnd","hideStart","hideEnd","classList","remove","removeTransitionClassNames","add","scrollTop","steps","nextStep","undefined","transition","mode","Promise","resolve","clearTimeout","__transitionTimeoutId__","currentStep","setTimeout","duration","durationStyleValue","durationValue","styleDurationToMs","delayStyleValue","getDuration","durationStr","parsed","parseFloat","indexOf","isNaN","itemIndex","id","items","item","find","findItem","createId","identityOptions","ns","spawn","join","store","initialState","actions","update","state","timer","states","refresh","remaining","index","splice","removeItem","replace","newItem","removeAll","newItems","selectors","getStore","just","nothing","getAll","itemsBySpawn","getCount","length","Stream","scan","patch","callback","isPaused","onAbort","onDone","promise","startTime","timeoutFn","timerId","appendStartTimer","updateState","Date","getTime","window","appendStopTimeout","appendStopTimer","appendPauseTimer","getRemaining","appendResumeTimer","minimumDuration","Math","max","Timer","start","done","stop","pause","resume","abort","getResultPromise","uid","transitionStates","filterBySpawn","filterFirstInQueue","nsItems","queuedCount","queueCount","dialogicOptions","queued","getMergedIdentityOptions","defaultDialogicOptions","handleOptions","options","dialogic","passThroughOptions","copy","getPassThroughOptions","show","callbacks","willShow","willHide","didShow","didHide","timeout","Number","MAX_VALUE","transitionState","maybeExistingItem","toggle","hideResult","hide","existingItem","replacingItem","hideItem","getValidItems","all","commandOptions","getTimerProperty","timerProp","defaultValue","maybeItem","getMaybeItem","exists","allItems","validItems","filterById","resetAll","push","getOverridingTransitionOptions","hideAll","regularItems","queuedItems","current","transitionItem","async","dialogical","defaultId","defaultSpawn","dialog","notification","reqId","displayValue","isCanceled","identity","instance","roundToSeconds","round","requestAnimationFrame","cancelAnimationFrame","deferredHideItem"],"mappings":"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"}